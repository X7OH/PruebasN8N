{"createdAt":"2025-10-15T16:06:50.973Z","updatedAt":"2025-10-16T19:41:41.000Z","id":"wDIfVDMoYUvKr3Ho","name":"Pruebas - PMOSaldoInicialCxC","active":true,"isArchived":false,"nodes":[{"parameters":{"method":"=POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables\"]?.context?.runExecutionData \n  ? $('Variables').first().json.telefono \n  : $('Variables1').first().json.telefono \n}}"},{"name":"body","value":"={{ $('Unificar Errores Productos').item.json.mensaje }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[5856,-112],"id":"44d24f8e-d3cd-46c0-a9e3-9e4459ab36fd","name":"Confirmacion","executeOnce":false},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';\n\nconst POSTGRES_NODE = 'AdOrgOB';          // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Organizacion'];    // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // saltos/tabs -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim();                                  // SOLO recorta bordes (no colapsa interiores)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return { json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } };\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return { json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } };\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo trim en bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\n// En un Code node en modo \"Run Once\", devuelve UN SOLO objeto:\nreturn { json: { mensaje } };\n\n/** Si prefieres la salida detallada, usa esto (tambi√©n como objeto √∫nico):\nreturn {\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n};\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1712,592],"id":"24c7179e-f2e0-4dd3-abf6-6481373eb2f5","name":"Code3"},{"parameters":{"jsCode":"// Lee todo lo que llega del Merge y decide EXITO / ERROR\nfunction pickMsgs(items) {\n  return items.map(i => String(i.json?.mensaje ?? '').trim()).filter(Boolean);\n}\nfunction hasErr(s) { return /error/i.test(s); }\nfunction bullets(msg) {\n  const m = String(msg).match(/errores?\\s+encontrados:\\s*([\\s\\S]*)/i);\n  const body = (m ? m[1] : msg).replace(/\\r/g, '');\n  const set = new Set(body.split('\\n').map(x => x.trim()).filter(Boolean));\n  return Array.from(set).map(x => x.startsWith('-') ? x : `- ${x}`);\n}\n\nconst msgs = pickMsgs($items('Merge2'));\nconst errs = msgs.filter(hasErr);\n\nlet resultado, mensaje;\nif (errs.length === 0) {\n  resultado = 'EXITO';\n  mensaje = 'CXC - ‚úÖ Todo Correcto';\n} else {\n  const all = errs.flatMap(bullets);\n  resultado = 'ERROR';\n  mensaje = `CXC - üö´ Errores encontrados:\\n${all.join('\\n')}`;\n}\n\n// Nombre del nodo a verificar\nconst nodeName = 'CxC';\n\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\n\n\nreturn [{ json: { resultado, mensaje, totalMensajes: msgs.length, totalConError: errs.length, ejecutado } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5632,-112],"id":"1e5f506d-2acc-4b6b-bd8b-4e7a1d861c3a","name":"Unificar Errores Productos"},{"parameters":{"numberInputs":10},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5136,-544],"id":"6b03881d-478c-4efa-9301-7a27fee95799","name":"Merge"},{"parameters":{"jsCode":"// n8n Function Node\n\n// Columnas a verificar duplicados\nconst COLS_DUP = [\"No documento\", \"No referencia\"];\n\n// Columnas de fecha a validar \"aaaa-mm-dd\"\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"];\n\n// Columnas permitidas vac√≠as y columnas a ignorar en validaci√≥n\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);\nconst IGNORE_COLS = new Set([\"row_number\"]);\n\n// Regex de control/saltos de p√°gina y otros controles (excluimos \\n y \\r aqu√≠, los tratamos aparte)\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g; // incluye \\f (\\x0C) y otros controles\nconst PAGE_BREAK_REGEX = /\\f/g; // expl√≠cito\n// Saltos de l√≠nea/enter (incluye CRLF, CR, LF y separadores Unicode de l√≠nea/p√°rrafo)\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;\n\n// Permitidos por car√°cter (ya sin \\n/\\r porque los normalizamos a espacio)\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\n// Validaci√≥n de fecha aaaa-mm-dd + calendario real (bisiestos, etc.)\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\n// Helpers\nconst toRowNum = (row, idx) => {\n  if (row && row.row_number != null) return row.row_number;\n  return (idx + 2);\n};\n\n// SOLO trim al inicio/fin; NO colapsar espacios internos\nconst cleanText = (val) => {\n  if (typeof val !== \"string\") return val;\n  let cleaned = val;\n\n  // 1) Normalizar saltos de l√≠nea/enter -> espacio\n  cleaned = cleaned.replace(LINEBREAK_REGEX, \" \");\n\n  // 2) Normalizar saltos de p√°gina/control chars -> espacio\n  cleaned = cleaned.replace(PAGE_BREAK_REGEX, \" \");\n  cleaned = cleaned.replace(CONTROL_CHARS_REGEX, \" \");\n\n  // 3) Solo recortar bordes (no tocar espacios intermedios)\n  cleaned = cleaned.trim();\n\n  return cleaned;\n};\n\nconst findSpecials = (val) => {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n};\n\n// --- Proceso ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza + caracteres especiales + vac√≠os\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return; // omitir campos meta\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      // Limpieza\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      // Vac√≠o no permitido (excepto columnas permitidas)\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      // Detecci√≥n de caracteres especiales no permitidos post-limpieza\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // No-string: verificar nulos/indefinidos como vac√≠o (0 num√©rico es v√°lido)\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de formato y valor de fechas (aaaa-mm-dd)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim(); // solo bordes\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // tambi√©n aplica regla de \"no vac√≠o\" para fechas\n      if (!COLS_ALLOW_EMPTY.has(col)) {\n        errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  }\n\n  // Preparar detecci√≥n de duplicados (con valores ya limpios; recorte SOLO en bordes)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// (Opcional) Filas con error ya limpias, por si luego las quieres devolver\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Mensaje final requerido\nconst mensaje = errores.length\n  ? `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`\n  : 'CXC - ‚úÖ Todo Correcto';\n\nreturn [{\n  json: {\n    mensaje\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1872,-480],"id":"6c0ad0ba-ca2d-4d53-951c-85e570303491","name":"InitCleaning","alwaysOutputData":false,"executeOnce":false},{"parameters":{"operation":"executeQuery","query":"select name from ad_org where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1696,336],"id":"a48dbb6a-c980-4ba0-9749-230493e1d92e","name":"AdOrgOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select documentno from c_invoice where issotrx='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1920,336],"id":"adc8e0a9-28ff-4596-bfc9-ea3269d535ac","name":"FacturasOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select name  from c_doctype  where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2160,336],"id":"9288ee60-1a70-4af7-a06a-ceccb712db70","name":"DoctypeOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';\n// Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'FacturasOB';    // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'documentno';   // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['No documento','No referencia']; // columnas del Sheet a validar contra Postgres\n\nconst NORMALIZAR = true;   // true: sin tildes y MAY√öSCULAS (se preservan espacios internos)\nconst TRIM_EMPTY = true;   // true: ignora vac√≠os\n\n// === Normalizadores (NO colapsan espacios internos) ===\nconst cleanDisplay = (s) => {\n  let out = (s ?? '').toString();\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // forma can√≥nica\n  return out.trim();                               // SOLO bordes; NO tocar espacios internos\n};\n\nconst norm = (s) => {\n  let out = cleanDisplay(s);\n  if (TRIM_EMPTY && out === '') return '';\n  if (!NORMALIZAR) return out;\n  // quitar tildes + pasar a MAY√öSCULAS; preserva espacios intermedios\n  return out.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toUpperCase();\n};\n\n// === 1) Datasheet (Google Sheets) ===\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `PRODUCTOS - üö´ No hay datos desde el nodo Sheet \"${SHEET_NODE}\"`, totalErrores: 1 } }];\n}\nconst sheetRows = sheetItems.map((it, i) => {\n  const r = it.json || {};\n  const base = { rowNumber: r.row_number ?? (i + 2) }; // encabezado en fila 1\n  for (const col of COLS_VALIDAR) {\n    base[`${col}Raw`]  = cleanDisplay(r[col]);  // muestra (solo trim bordes)\n    base[`${col}Norm`] = norm(r[col]);          // clave de comparaci√≥n\n  }\n  return base;\n});\n\n// === 2) Postgres (UNA sola columna) ===\nconst obRows = ($items(POSTGRES_NODE) || []).map(it => it.json || {});\nconst obSet = new Set(\n  obRows.map(r => norm(r[POSTGRES_FIELD])).filter(v => v !== '')\n);\n\n// === 3) Acumular coincidencias (valores del sheet que YA existen en OB) ===\nconst dupPorColumna = {};\nfor (const col of COLS_VALIDAR) dupPorColumna[col] = new Map();\n\nfor (const r of sheetRows) {\n  for (const col of COLS_VALIDAR) {\n    const key = r[`${col}Norm`];\n    if (!key) continue;\n    if (obSet.has(key)) {\n      const entry = dupPorColumna[col].get(key) || { muestra: r[`${col}Raw`] || '(vac√≠o)', rows: [] };\n      entry.rows.push(r.rowNumber);\n      dupPorColumna[col].set(key, entry);\n    }\n  }\n}\n\n// === 4) Mensajes en el formato solicitado ===\nconst errores = [];\nconst sortByMuestra = (a, b) => a.muestra.localeCompare(b.muestra, 'es', { sensitivity: 'base' });\n\nfor (const col of COLS_VALIDAR) {\n  const valores = [...dupPorColumna[col].values()].sort(sortByMuestra);\n  valores.forEach(e => {\n    e.rows.sort((a, b) => a - b);\n    errores.push(`Duplicado en columna \"${col}\": valor \"${e.muestra}\" en filas ${e.rows.join(', ')}`);\n  });\n}\n\n// === 5) Salida ===\nconst mensaje = errores.length === 0\n  ? `CxC - ‚úÖ Todo Correcto`\n  : `CxC (existentes en OB) - üö´ Error Coincidencias encontradas:\\n- ${errores.join('\\n- ')}`;\n\nreturn [{\n  json: {\n    mensaje,\n    totalErrores: errores.length\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1920,592],"id":"9f954c4a-0766-4264-9f79-1391c2814414","name":"FactOB"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';\n\nconst POSTGRES_NODE = 'DoctypeOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();    // respeta espacios tal cual\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2160,592],"id":"ec1c65cc-cbc4-4f9f-8ec4-1d63424959a8","name":"DtOB"},{"parameters":{"operation":"executeQuery","query":"select taxid from c_bpartner where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2416,336],"id":"9b9161b8-9323-4d13-b9af-2eec719336d8","name":"PartnerOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';\n// Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'DoctypeOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2416,592],"id":"05885773-a86b-4820-94fc-97aa6097d4f2","name":"BPOB"},{"parameters":{"operation":"executeQuery","query":"select name from m_pricelist where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2656,336],"id":"86191383-831a-4694-a165-8a362398f525","name":"PriceListOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';\n// Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PriceListOB';      // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Lista de precios']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia sin tocar espacios internos: reemplaza CR/LF/TAB por un espacio,\n// elimina NBSP/zero-width, normaliza unicode y SOLO trim de bordes.\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // CR/LF/TAB -> espacio\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim();                                  // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia exacta por nombre limpio) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) }; // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (conserva espacios internos)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2656,592],"id":"2c2f63d6-2a5a-4982-8951-4b2ab81bb58c","name":"ValidaPriceList"},{"parameters":{"operation":"executeQuery","query":"select iso_code from c_currency where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2896,336],"id":"ba800d6d-2740-4bd1-aa70-c7198ac99f66","name":"MonedaOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';\n// Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'MonedaOB';         // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'iso_code';        // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Moneda'];          // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2896,592],"id":"62fbd65f-7f62-4f7f-8b33-ab3c1e0fc72e","name":"ValidaCurrency"},{"parameters":{"operation":"executeQuery","query":"select name from fin_paymentmethod where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3136,336],"id":"1fc02d07-f81d-41a1-8540-878bb0c065f4","name":"PaymentMethodOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                 \n// Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentMethodOB';  // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Forma de pago'];   // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia caracteres invisibles y saltos a espacios, y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3136,592],"id":"38f2a32d-7514-46b1-b1ef-2677cc06ed4c","name":"ValidaPaymentMethod"},{"parameters":{"operation":"executeQuery","query":"select name from c_paymentterm where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3376,336],"id":"d766c2b0-0338-4782-9e77-f845c85b3242","name":"PaymentTermOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                \n// Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentTermOB';    // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Condiciones de pago']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos a espacios y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> un espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3376,592],"id":"da290f5a-dd04-40f8-96dc-66b747fad268","name":"ValidaPaymentTerm"},{"parameters":{"operation":"executeQuery","query":"select name from m_product where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3600,336],"id":"ddcf3415-2857-4400-8531-eca5bc0c176b","name":"ProductOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'ProductOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Producto'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos a espacios y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> un espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3600,592],"id":"2b04b1a6-f049-49b3-b60a-cc08a58623c6","name":"ValidaProduct"},{"parameters":{"operation":"executeQuery","query":"select uomsymbol from c_uom where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3824,336],"id":"7f1eee94-a041-4bd4-baf3-35f0830bfe69","name":"UnidadOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'UnidadOB';         // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'uomsymbol';       // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Unidad de la orden']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos y SOLO recorta bordes (no toca espacios internos normales)\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                 // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3824,592],"id":"e88b9a4a-8844-497d-82fc-04b5ec7f21ed","name":"ValidaUnidad"},{"parameters":{"operation":"executeQuery","query":"select name from c_tax where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4064,336],"id":"a231e5c4-69a5-4871-9883-1781dd8fae84","name":"TaxOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"operation":"executeQuery","query":"select name from c_costcenter where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4304,336],"id":"10d3b5ea-0bfc-459b-a90d-bf4e92605e4b","name":"CostCenterOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"operation":"executeQuery","query":"select name from user1 where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4544,336],"id":"b7dc924b-2311-4fae-aff9-a759753d77df","name":"User1OB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"numberInputs":6},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5424,-176],"id":"f7b5056a-d0f6-48c7-a926-2039376f22de","name":"Merge2"},{"parameters":{"formTitle":"Saldos Iniciales CxC","formFields":{"values":[{"fieldLabel":"Plantilla","fieldType":"file","multipleFiles":false,"acceptFileTypes":".xlsx","requiredField":true},{"fieldLabel":"Telefono Celular","requiredField":true}]},"options":{}},"type":"n8n-nodes-base.formTrigger","typeVersion":2.2,"position":[-2464,-656],"id":"dc16889d-1104-4994-b78e-dd47ce15eda3","name":"CargarProductos","webhookId":"b90fc8f4-f1f2-4a24-99a5-48b30649fc01"},{"parameters":{"inputDataFieldName":"=data","name":"={{ $('Variables1').item.json.fileName }}","driveId":{"__rl":true,"mode":"list","value":"My Drive"},"folderId":{"__rl":true,"value":"={{ $('Variables1').item.json.uploadFilesDirectory }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-464,-896],"id":"c649b6fc-c792-476f-9b08-50f93785a22d","name":"Upload file1","credentials":{"googleDriveOAuth2Api":{"id":"2D5m9UCVL0y0GKgC","name":"Google Drive account"}}},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"13IxZ60e9aoBpSIIxNBk01_zZxbkVPkow","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Az-ZFrPX8NLT3-AOv8lUBOLu-wS2c34i","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://admchat.duckdns.org/wa-decrypt/decrypt-document","type":"string"},{"id":"f197f9b9-0992-47b5-8faf-85fecda67503","name":"fileName","value":false,"type":"string"},{"id":"1071c733-64c4-46b4-9933-ad3c843c05fb","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"343aeec5-aa95-461c-9272-d17dedf033ca","name":"telefono","value":"={{ $('Homologar_msg').item.json.telefono }}","type":"string"}]},"includeOtherFields":true,"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-1264,208],"id":"e57e04f4-2330-4ff2-9644-dde1d0996bb4","name":"Variables"},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"13IxZ60e9aoBpSIIxNBk01_zZxbkVPkow","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Az-ZFrPX8NLT3-AOv8lUBOLu-wS2c34i","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://admchat.duckdns.org/wa-decrypt/decrypt-document","type":"string"},{"id":"e85da8f3-3311-4594-b365-55aadab8176e","name":"fileName","value":"CxC","type":"string"},{"id":"00dbcc54-57ea-4710-9124-a6979416f3cd","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"293163d2-3cb2-4103-a8de-90080923e03f","name":"telefono","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}","type":"string"}]},"includeOtherFields":true,"options":{"stripBinary":true}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-1440,-912],"id":"6c687a13-29e0-42c3-a8ca-947e60e589bc","name":"Variables1"},{"parameters":{"operation":"binaryToPropery","binaryPropertyName":"Plantilla","options":{}},"type":"n8n-nodes-base.extractFromFile","typeVersion":1,"position":[-2032,-672],"id":"1fe6eeb1-9091-405f-8037-0718332a26a0","name":"Extract from File"},{"parameters":{"operation":"toBinary","sourceProperty":"data","binaryPropertyName":"=data","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[-800,-912],"id":"922f9104-91df-4712-87b8-04aa41eb9548","name":"Convert to File"},{"parameters":{"workflowId":{"__rl":true,"value":"={{ $('Variables1').item.json.subworkflowID }}","mode":"id"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"options":{"waitForSubWorkflow":true}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[-1232,-1040],"id":"ba2dbe07-ebd6-4f9d-870b-b9d703bccf22","name":"Execute Workflow","alwaysOutputData":true,"notesInFlow":false,"executeOnce":false,"retryOnFail":false},{"parameters":{"mode":"chooseBranch","useDataOfInput":2},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-960,-912],"id":"c624647a-0ad9-4484-84a2-482559fb6177","name":"Merge3"},{"parameters":{"workflowId":{"__rl":true,"value":"={{ $('Variables').item.json.subworkflowID }}","mode":"id","cachedResultUrl":"/workflow/=%7B%7B%20$('Variables').item.json.subworkflowID%20%7D%7D"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"options":{"waitForSubWorkflow":true}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[-832,16],"id":"95bb776d-6574-41a0-bf5b-68961e503c59","name":"Execute Workflow1","alwaysOutputData":true,"notesInFlow":false,"executeOnce":false,"retryOnFail":false},{"parameters":{"mode":"chooseBranch","useDataOfInput":2},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-592,224],"id":"fd00ed4a-a5f9-4402-8cf5-fccc98767cee","name":"Merge4"},{"parameters":{"method":"POST","url":"=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy","authentication":"predefinedCredentialType","nodeCredentialType":"googleOAuth2Api","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables1').item.json.convertedFilesDirectory }}\"]\n}","options":{}},"id":"36d5f8f8-4e2d-442d-9fdf-760d1b72a995","name":"Convert File2","type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-288,-912],"credentials":{"googleOAuth2Api":{"id":"N3sd298xjJQFZGOz","name":"Google account"}},"onError":"continueErrorOutput"},{"parameters":{"jsCode":"// Clasifica: 'texto' | 'imagen' | 'audio' | 'video' | 'documento'\n// Mantiene SIEMPRE el mismo formato de retorno:\n// { kind, text, media, raw, sender, timestamp }\n\nfunction unwrap(m) {\n  if (!m) return m;\n  if (m.ephemeralMessage?.message) return unwrap(m.ephemeralMessage.message);\n  if (m.viewOnceMessage?.message) return unwrap(m.viewOnceMessage.message);\n  if (m.viewOnceMessageV2?.message) return unwrap(m.viewOnceMessageV2.message);\n  return m;\n}\n\nfunction toNum(x) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction isImageMime(mt) {\n  return typeof mt === \"string\" && mt.toLowerCase().startsWith(\"image/\");\n}\n\nfunction isImageFilename(name) {\n  if (!name) return false;\n  return /\\.(jpe?g|png|webp|gif|bmp|tif?f)$/i.test(String(name));\n}\n\nfunction detectar(body) {\n  const msg = unwrap(body?.message || {});\n  if (!msg) return { kind: \"desconocido\", text: \"\", media: null, raw: body };\n\n  // === AUDIO ===\n  if (msg.audioMessage) {\n    const a = msg.audioMessage;\n    const url = a.url || \"\";\n    return {\n      kind: \"audio\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: a.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: a.mediaKey || null,\n        directPath: a.directPath || null,\n        seconds: typeof a.seconds === \"number\" ? a.seconds : toNum(a.seconds),\n        ptt: Boolean(a.ptt)\n      },\n      raw: body\n    };\n  }\n\n  // === VIDEO ===\n  if (msg.videoMessage) {\n    const v = msg.videoMessage;\n    const url = v.url || \"\";\n    return {\n      kind: \"video\",\n      text: v.caption || \"\",\n      media: {\n        url,\n        mimetype: v.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: v.mediaKey || null,\n        directPath: v.directPath || null,\n        seconds: typeof v.seconds === \"number\" ? v.seconds : toNum(v.seconds),\n        gifPlayback: Boolean(v.gifPlayback)\n      },\n      raw: body\n    };\n  }\n\n  // === STICKER (tratar como IMAGEN) ===\n  if (msg.stickerMessage) {\n    const s = msg.stickerMessage;\n    const url = s.url || \"\";\n    return {\n      kind: \"imagen\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: s.mimetype || \"image/webp\",\n        encrypted: url.includes(\".enc\"),\n        mediaKey: s.mediaKey || null,\n        directPath: s.directPath || null,\n        isSticker: true,\n        isAnimated: Boolean(s.isAnimated)\n      },\n      raw: body\n    };\n  }\n\n  // === IMAGEN ===\n  if (msg.imageMessage) {\n    const i = msg.imageMessage;\n    const url = i.url || \"\";\n    return {\n      kind: \"imagen\",\n      text: i.caption || \"\",\n      media: {\n        url,\n        mimetype: i.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: i.mediaKey || null,\n        directPath: i.directPath || null\n      },\n      raw: body\n    };\n  }\n\n  // === DOCUMENTO (si es imagen -> clasificar como IMAGEN; si no, DOCUMENTO) ===\n  if (msg.documentMessage) {\n    const d = msg.documentMessage;\n    const url = d.url || \"\";\n    const fileName = d.fileName || d.title || null;\n    const mime = d.mimetype || null;\n\n    if (isImageMime(mime) || isImageFilename(fileName)) {\n      // document enviado como imagen -> tratar como imagen\n      return {\n        kind: \"imagen\",\n        text: \"\",\n        media: {\n          url,\n          mimetype: mime || \"image/jpeg\",\n          encrypted: url.includes(\".enc\"),\n          mediaKey: d.mediaKey || null,\n          directPath: d.directPath || null,\n          fromDocument: true,\n          fileName,\n          fileLength: toNum(d.fileLength),\n          fileSha256: d.fileSha256 || null,\n          fileEncSha256: d.fileEncSha256 || null,\n          mediaKeyTimestamp: toNum(d.mediaKeyTimestamp)\n        },\n        raw: body\n      };\n    }\n\n    // documento \"normal\"\n    return {\n      kind: \"documento\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: mime,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: d.mediaKey || null,\n        directPath: d.directPath || null,\n        fileName,\n        fileLength: toNum(d.fileLength),\n        pageCount: toNum(d.pageCount),\n        fileSha256: d.fileSha256 || null,\n        fileEncSha256: d.fileEncSha256 || null,\n        mediaKeyTimestamp: toNum(d.mediaKeyTimestamp),\n        // miniatura (si existe)\n        thumbnail: {\n          jpegThumbnail: d.jpegThumbnail || null,\n          thumbnailDirectPath: d.thumbnailDirectPath || null,\n          thumbnailSha256: d.thumbnailSha256 || null,\n          thumbnailEncSha256: d.thumbnailEncSha256 || null,\n          width: toNum(d.thumbnailWidth),\n          height: toNum(d.thumbnailHeight)\n        }\n      },\n      raw: body\n    };\n  }\n\n  // === TEXTO ===\n  if (msg.conversation || msg.extendedTextMessage?.text) {\n    return {\n      kind: \"texto\",\n      text: msg.conversation || msg.extendedTextMessage?.text || \"\",\n      media: null,\n      raw: body\n    };\n  }\n\n  // Desconocido\n  return { kind: \"desconocido\", text: \"\", media: null, raw: body };\n}\n\nreturn items.map(it => {\n  const body = it.json?.body ?? it.json;\n  const out = detectar(body);\n  const ts = body?.messageTimestamp ? new Date(Number(body.messageTimestamp) * 1000).toISOString() : null;\n\n  return {\n    json: {\n      kind: out.kind,      // 'audio' | 'video' | 'imagen' | 'documento' | 'texto' | 'desconocido'\n      text: out.text,\n      media: out.media,\n      raw: out.raw,\n      sender: {\n        name: body?.pushName || \"\",\n        remoteJid: body?.key?.remoteJid || \"\",\n        fromMe: Boolean(body?.key?.fromMe),\n        id: body?.key?.id || null\n      },\n      timestamp: ts\n    }\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2656,80],"id":"5bdfaf08-e0b8-4cc7-bd7d-364f30095701","name":"Code1"},{"parameters":{"httpMethod":"POST","path":"d4a09f90-7c99-4ea0-886b-51a8321f90bb","responseMode":"lastNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-3024,80],"id":"338112bd-25eb-4926-b633-92bb6e6cfba2","name":"Webhook","webhookId":"d4a09f90-7c99-4ea0-886b-51a8321f90bb"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"a3e61211-0ab1-47f7-89d7-4dcd56af7e7b","leftValue":"={{ $json.kind }}","rightValue":"documento","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Documento"}]},"options":{"fallbackOutput":"extra"}},"type":"n8n-nodes-base.switch","typeVersion":3.2,"position":[-1856,64],"id":"84f071a1-69ef-4263-a965-daf2c892dc4f","name":"Switch"},{"parameters":{"method":"POST","url":" https://agileapichat.sidesoftcorp.com/api/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer linea1"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=Documento No Soportado"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-1552,336],"id":"57f0bb58-99d4-4343-a433-44d41f557f70","name":"Response"},{"parameters":{"jsCode":"return items.map(item => {\n  const body = item.json.body;\n  const msg = body.message || {};\n  const telefono = $input.first().json.body.key.remoteJid.split('@')[0];\n\n  let messageText = \"\";\n\n  // Caso 1: texto plano\n  if (msg.conversation) {\n    messageText = msg.conversation;\n  }\n\n  // Caso 2: texto extendido (con contexto)\n  else if (msg.extendedTextMessage?.text) {\n    messageText = msg.extendedTextMessage.text;\n  }\n\n  // Caso 3: imagen con caption\n  else if (msg.imageMessage?.caption) {\n    messageText = msg.imageMessage.caption;\n  }\n\n  // Caso 4: video con caption\n  else if (msg.videoMessage?.caption) {\n    messageText = msg.videoMessage.caption;\n  }\n\n  // Caso 5: audio/nota de voz (no trae texto, solo informamos)\n  else if (msg.audioMessage) {\n    messageText = \"[Audio recibido]\";\n  }\n\n  // Caso 6: bot√≥n presionado\n  else if (msg.buttonsResponseMessage?.selectedButtonId) {\n    messageText = msg.buttonsResponseMessage.selectedButtonId;\n  }\n\n  // Caso 7: lista seleccionada\n  else if (msg.listResponseMessage?.singleSelectReply?.selectedRowId) {\n    messageText = msg.listResponseMessage.singleSelectReply.selectedRowId;\n  }\n\n  // Caso 8: sticker\n  else if (msg.stickerMessage) {\n    messageText = \"[Sticker recibido]\";\n  }\n\n  // Caso 9: documento\n  else if (msg.documentMessage?.fileName) {\n    messageText = `[Documento: ${msg.documentMessage.fileName}]`;\n  }\n\n  // Si no hay nada reconocible\n  else {\n    messageText = \"[Mensaje no reconocido]\";\n  }\n\n  return {\n    json: {\n      ...item.json,\n      userMessage: messageText,   // üîπ campo unificado para usar en AI Agent\n      telefono\n    }\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2832,80],"id":"ff55383c-e2c6-4f31-a91c-36aafb21c67b","name":"Homologar_msg"},{"parameters":{"method":"POST","url":"http://agente.alldigital-marketing.com/","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"mimetype","value":"={{ $('Code1').item.json.raw.message.documentMessage.mimetype }}"},{"name":"mediaKey","value":"={{ $('Code1').item.json.raw.message.documentMessage.mediaKey }}"},{"name":"fileEncSha256","value":"={{ $('Code1').item.json.raw.message.documentMessage.fileEncSha256 }}"},{"name":"mediaKeyTimestamp","value":"={{ $('Code1').item.json.raw.message.documentMessage.mediaKeyTimestamp }}"},{"name":"directPath","value":"={{ $('Code1').item.json.raw.message.documentMessage.directPath }}"},{"name":"fileSha256","value":"={{ $('Code1').item.json.raw.message.documentMessage.fileSha256 }}"},{"name":"filename","value":"={{ $('Code1').item.json.raw.message.documentMessage.fileName }}"}]},"options":{"allowUnauthorizedCerts":true}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-416,224],"id":"4cf0371f-0f34-453b-ad3a-4bf455ef5a45","name":"HTTP Request","retryOnFail":true,"maxTries":5,"waitBetweenTries":2000},{"parameters":{"method":"POST","url":"=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy","authentication":"predefinedCredentialType","nodeCredentialType":"googleOAuth2Api","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables').item.json.convertedFilesDirectory }}\"]\n}","options":{}},"id":"05e234f5-eb18-4b7d-8233-2e9f107f73c3","name":"Convert File3","type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[256,240],"credentials":{"googleOAuth2Api":{"id":"N3sd298xjJQFZGOz","name":"Google account"}},"onError":"continueErrorOutput"},{"parameters":{"documentId":{"__rl":true,"value":"={{ $json.id }}","mode":"id"},"sheetName":{"__rl":true,"value":"CxC","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[1184,-208],"id":"4e8a792b-f891-4739-b6ba-100eb385a5b6","name":"CxC","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=Error al Convertir Media Intente Nuevamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[416,368],"id":"d39e4611-bcbe-4a7b-a5a6-232c4ed7a0e7","name":"Response1"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}"},{"name":"body","value":"=Error al Convertir Media Intente Nuevamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-16,-688],"id":"4dd92d8e-19ec-42e1-9db5-cb08620de8fe","name":"Response2"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=üëã Hola, inicio la revisi√≥n de la plantilla de CxC, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-1536,48],"id":"75728941-911e-455a-90d5-63fee5547d83","name":"MsgInicial"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}"},{"name":"body","value":"=üëã Hola, inicio la revisi√≥n de la plantilla de CxC, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-2032,-896],"id":"2334a376-cd8d-4093-a932-795dc0d2cc70","name":"MsgInicial2"},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"1hhic6Um17LbZv1B3fCQr27X-SASoagsH","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Ujakb61OzHsUIEXRQtT2oz7LutRh-THi","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://admchat.duckdns.org/wa-decrypt/decrypt-document","type":"string"},{"id":"f197f9b9-0992-47b5-8faf-85fecda67503","name":"fileName","value":"CxP","type":"string"},{"id":"1071c733-64c4-46b4-9933-ad3c843c05fb","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"343aeec5-aa95-461c-9272-d17dedf033ca","name":"telefono","value":"={{ $('Homologar_msg').item.json.telefono }}","type":"string"}]},"includeOtherFields":true,"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-1248,512],"id":"e752b744-b68e-4c5b-97de-4172bf6b6d62","name":"Variables2"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"a3e61211-0ab1-47f7-89d7-4dcd56af7e7b","leftValue":"={{ $json.kind }}","rightValue":"documento","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Documento"}]},"options":{"fallbackOutput":"extra"}},"type":"n8n-nodes-base.switch","typeVersion":3.2,"position":[-1824,656],"id":"ff273635-f611-48d3-a417-3ad89fe08802","name":"Switch1"},{"parameters":{"method":"POST","url":" https://agileapichat.sidesoftcorp.com/api/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer linea1"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=Documento No Soportado"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-1520,848],"id":"664cf12c-21eb-41ab-8fe8-2a0dab9f8058","name":"Response3"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=üëã Hola, inicio la revisi√≥n de la plantilla de CxP, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-1504,640],"id":"4ea138df-4ec3-4706-8e64-560e1aeaed19","name":"MsgInicial1"},{"parameters":{"jsCode":"// Usa el fileName que viene del mensaje de WhatsApp\nconst fileName = String(\n  $json.raw?.message?.documentMessage?.fileName || ''\n);\nconst ext = (fileName.split('.').pop() || '').toLowerCase();\nconst mime = String($json.raw?.message?.documentMessage?.mimetype || '');\n\nlet tipo = '';\nif (/cxp/i.test(fileName)) tipo = 'CXP';\nelse if (/cxc/i.test(fileName)) tipo = 'CXC';\nelse if (ext === 'xlsx') tipo = 'XLSX';\nelse if (ext === 'csv') tipo = 'CSV';\nelse tipo = 'OTRO';\n\nreturn [{\n  json: {\n    ...$json,\n    archivo_nombre: fileName,\n    archivo_ext: ext,\n    archivo_mime: mime,\n    tipo_archivo: tipo\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2480,80],"id":"92723878-144b-44ef-874c-66c8797d9560","name":"Code4"},{"parameters":{"documentId":{"__rl":true,"value":"={{ \n$node[\"Convert File3\"]?.context?.runExecutionData \n  ? $('Convert File3').first().json.id \n  : $('Convert File2').first().json.id \n}}","mode":"id"},"sheetName":{"__rl":true,"value":"CxC","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[7328,-320],"id":"9a9fec9a-5879-4d04-94ca-e3c29b8aa2d8","name":"CxCCarga","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"// n8n Function Node\n\n// --- Par√°metros de validaci√≥n ---\nconst COLS_DUP = [\"No documento\", \"No referencia\"];           // columnas a chequear duplicados\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"]; // fechas YMD requeridas\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);            // columnas que s√≠ pueden venir vac√≠as\nconst IGNORE_COLS = new Set([\"row_number\"]);                  // columnas que se ignoran en validaci√≥n y/o se eliminan al salir\n\n// --- Expresiones utilitarias ---\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g;  // controles (excepto \\n/\\r)\nconst PAGE_BREAK_REGEX = /\\f/g;                                    // salto de p√°gina\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;               // saltos de l√≠nea\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\nconst toRowNum = (row, idx) => row?.row_number != null ? row.row_number : (idx + 2);\n\n// Solo recorta bordes; NO colapsa espacios internos\nfunction cleanText(val) {\n  if (typeof val !== \"string\") return val;\n  return val\n    .replace(LINEBREAK_REGEX, \" \")    // saltos de l√≠nea -> espacio\n    .replace(PAGE_BREAK_REGEX, \" \")   // salto de p√°gina -> espacio\n    .replace(CONTROL_CHARS_REGEX, \" \")// otros controles -> espacio\n    .trim();                          // recorta SOLO al inicio/fin\n}\n\nfunction findSpecials(val) {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n}\n\n// --- Proceso principal ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza/normalizaci√≥n campo a campo\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return;\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de fechas YMD (permitimos espacios en bordes)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else if (!COLS_ALLOW_EMPTY.has(col)) {\n      errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n      rowsWithIssues.add(rowNum);\n    }\n  }\n\n  // Duplicados (solo recorte de bordes en la clave)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// Filas con error (ya limpias)\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Salida con errores\nif (errores.length > 0) {\n  const mensaje = `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`;\n  return [{\n    json: {\n      ok: false,\n      mensaje,\n      errores,\n      filasConError\n    }\n  }];\n}\n\n// Salida correcta: items limpios (sin IGNORE_COLS)\nconst salidaLimpia = cleanedItems.map(ci => {\n  const out = { ...ci.row };\n  for (const k of IGNORE_COLS) {\n    if (k in out) delete out[k];\n  }\n  return { json: out };\n});\n\nif (salidaLimpia.length === 0) {\n  return [{ json: { ok: true, mensaje: 'CXC - ‚úÖ Todo Correcto (sin filas)', rows: 0 } }];\n}\n\nreturn salidaLimpia;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7520,-320],"id":"98d8f509-d901-472b-a59e-066e067be587","name":"InitCleaningCarga","alwaysOutputData":false,"executeOnce":false},{"parameters":{"operation":"executeQuery","query":"select ad_client_id from ad_client where ad_client_id not in ('0') ","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[6960,-320],"id":"e2e8eb9b-2579-4b47-b60f-0d04dd2765e4","name":"ADClient","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select ad_org_id from ad_org where ad_org_id='0'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[7136,-320],"id":"0f955ee9-6553-4bae-ac4b-a1fab2ccc28a","name":"ADOrg","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"{{$json.sql_cabecera}}","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[7920,-320],"id":"78c16f85-8b54-46a1-ac8b-5480cae1d3fa","name":"InsertCabecera","retryOnFail":false,"alwaysOutputData":true,"credentials":{"postgres":{"id":"nPk4aB6nOLV1cRfH","name":"Postgres account 4"}},"onError":"continueRegularOutput"},{"parameters":{"content":"##**Cargamos la Data?** \n**Cargar** \n**Isso TRX** ","height":624},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[6480,-416],"id":"4d963820-3f16-4e3c-8f18-5fee5de039da","name":"Sticky Note"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Code node: CrearSQLCabecera\n// Mode: Run Once for Each Item\n\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Datos de soporte desde ADClient (un √∫nico registro) ===\nconst adClient = $items(\"ADClient\", 0, 0)[0]?.json;\nconst adClientId = adClient?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n\n// === Fila actual (ya limpia) ===\nconst row = $json;\n\n// Si no tienes row_number de Sheets, usa √≠ndice + 2 (cabecera = fila 1)\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Metadatos √∫tiles para logs\nconst _doc = row['No documento'];\nconst _ref = row['No referencia'];\n\n// === Construir SQL de CABECERA (multi-l√≠nea) ===\nlet sql = `\nINSERT INTO c_invoice(\n  c_invoice_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  issotrx, documentno, docstatus, docaction, processing, processed, posted,\n  c_doctype_id, c_doctypetarget_id, c_order_id, description, isprinted, salesrep_id,\n  dateinvoiced, dateprinted, dateacct, c_bpartner_id, c_bpartner_location_id,\n  poreference, isdiscountprinted, dateordered, c_currency_id, paymentrule, c_paymentterm_id,\n  c_charge_id, chargeamt, m_pricelist_id, istaxincluded, c_campaign_id, c_project_id,\n  c_activity_id, createfrom, generateto, ad_user_id, copyfrom, isselfservice, ad_orgtrx_id,\n  user2_id, withholdingamount, taxdate, c_withholding_id, fin_paymentmethod_id, c_costcenter_id,\n  user1_id\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(), '100', now(), '100',\n  'Y',\n  ${sqlSafe(row['No documento'])},\n  'DR','CO','N','N','N',\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  NULL,\n  ${sqlSafe(row['Descripcion'])},\n  'N',\n  NULL,\n  to_date(${sqlSafe(row['Fecha de la factura'])}, 'yyyy-mm-dd'),\n  NULL,\n  to_date(${sqlSafe(row['Fecha contable'])}, 'yyyy-mm-dd'),\n  (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])}),\n  (SELECT c_bpartner_location_id\n     FROM c_bpartner_location\n    WHERE c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND isbillto = 'Y'\n    LIMIT 1),\n  ${sqlSafe(row['No referencia'])},\n  'Y',\n  NULL,\n  (select c_currency_id from c_currency where iso_code = ${sqlSafe(row['Moneda'])}),\n  '2',\n  (select c_paymentterm_id from c_paymentterm where name = ${sqlSafe(row['Condiciones de pago'])}),\n  NULL,\n  NULL,\n  (select m_pricelist_id from m_pricelist where name = ${sqlSafe(row['Lista de precios'])}),\n  'N',\n  NULL, NULL, NULL,\n  'N','N',\n  NULL,\n  'N','N',\n  NULL,\n  NULL,\n  0,\n  to_date(${sqlSafe(row['Fecha impuesto'])}, 'yyyy-mm-dd'),\n  NULL,\n  (SELECT fin_paymentmethod_id FROM fin_paymentmethod WHERE name = ${sqlSafe(row['Forma de pago'])}),\n  (SELECT c_costcenter_id FROM c_costcenter WHERE name = ${sqlSafe(row['Centro de costo'])}),\n  (SELECT user1_id FROM user1 WHERE name = ${sqlSafe(row['Usuario1'])})\n);\n`.trim();\n\n// === Normalizaci√≥n m√≠nima ===\n// Quitar saltos de l√≠nea y tabs para que el Postgres node reciba una sola l√≠nea,\n// pero SIN colapsar espacios internos.\nsql = sql\n  .replace(/\\r?\\n|\\r/g, ' ')\n  .replace(/\\t/g, ' ')\n  .trim();\n\n// >>> DEVOLVER UN SOLO OBJETO (no array) <<<\nreturn {\n  json: {\n    ...row,\n    _rowNum,\n    _doc,\n    _ref,\n    sql_cabecera: sql\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7712,-320],"id":"16c0c8a8-f58a-4d36-a826-89a34a1a3d58","name":"CrearSQLCabecera"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"45850144-ae70-437c-bf45-523fa1499141","leftValue":"={{ !!$json.error }}","rightValue":"","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[8080,-320],"id":"86002052-6174-4d29-b5c8-da37d63e6016","name":"If"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Code: BuildSQLLinea  (NO colapsa espacios internos)\n\n// Escapa solo comillas simples; NO hace trim ni colapsa espacios del valor\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Meta com√∫n tomada de otros nodos ===\n// ADClient ‚Üí toma el id del nodo Postgres \"ADClient\"\nconst adClientItems = $items(\"ADClient\", 0, 0);\nconst adClientId = adClientItems[0]?.json?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst valCx = ejecutado ? 'Y' : 'N';   \n\n// === Meta de la l√≠nea actual ===\nconst row = $json;\n\n// Si tu Function previo no preserva row_number de Sheets,\n// usa √≠ndice + 2 (para contar encabezado):\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Guarda metadatos √∫tiles para depuraci√≥n:\n$json._rowNum = _rowNum;\n$json._doc    = row['No documento'];   // para relacionar con cabecera\n$json._line   = row['Linea'];          // nro de l√≠nea (si existe)\n$json._prod   = row['Producto'];       // id/nombre producto (si existe)\n\n// === Construye el SQL de la l√≠nea ===\n// (Dejamos el SQL con saltos de l√≠nea para legibilidad; no colapsamos espacios)\nconst sql = `\nINSERT INTO c_invoiceline(\n  c_invoiceline_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  c_invoice_id, c_orderline_id, m_inoutline_id, line, description, m_product_id,\n  qtyinvoiced, pricelist, priceactual, pricelimit, linenetamt,\n  c_charge_id, chargeamt, c_uom_id, c_tax_id, s_resourceassignment_id, taxamt,\n  m_attributesetinstance_id, isdescription, quantityorder, m_product_uom_id,\n  c_invoice_discount_id, c_projectline_id, m_offer_id, pricestd, excludeforwithholding\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(),'100', now(),'100',\n  (SELECT c_invoice_id\n     FROM c_invoice\n    WHERE documentno = ${sqlSafe(row['No documento'])}\n      AND c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND issotrx = '${valCx}'),\n  NULL, NULL,\n  ${row['Linea'] ? sqlSafe(row['Linea']) : '10'},\n  ${sqlSafe(row['Descripcion'])},\n  sswh_m_product_get(${sqlSafe(row['Producto'])}),\n  ${sqlSafe(row['Cnt.'])},\n  0,\n  to_number(${sqlSafe(row['Precio unitario'])}),\n  0,\n  to_number(${sqlSafe(row['Total'])}),\n  NULL, 0,\n  (SELECT c_uom_id FROM c_uom WHERE uomsymbol = ${sqlSafe(row['Unidad de la orden'])}),\n  (SELECT c_tax_id FROM c_tax WHERE name = ${sqlSafe(row['Impuesto'])}),\n  NULL, NULL, NULL,\n  'N', NULL, NULL, NULL, NULL, NULL,\n  to_number(${sqlSafe(row['Precio unitario'])}),\n  'Y'\n);\n`;\n// Nota: NO usamos .trim() ni reemplazos que cambien espacios internos de los valores\n\n$json.sql_linea = sql;\n\n// En modo \"Run Once for Each Item\" devuelve UN SOLO objeto\nreturn { json: $json };\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[9072,-176],"id":"9748832a-d978-4a39-b3de-afa333b23209","name":"CrearSQLLinea"},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[6720,-576],"id":"558f8a14-7548-4a52-88f2-750403765a75","name":"When clicking ‚ÄòExecute workflow‚Äô"},{"parameters":{"operation":"executeQuery","query":"select cb.taxid, cbpl.c_bpartner_location_id\nfrom c_bpartner_location cbpl \njoin c_bpartner cb on cb.c_bpartner_id=cbpl.c_bpartner_id and cbpl.isbillto='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4800,336],"id":"b3bcd6ca-1c0c-4e7e-8b61-41b5d08fff27","name":"BPLocationOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"c44052ed-6bb8-4a85-ac54-fbf2ecc20b40","leftValue":"={{ $('Unificar Errores Productos').item.json.resultado }}","rightValue":"EXITO","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[6032,-112],"id":"95e6b365-9a19-434d-ac09-59a17204c5d1","name":"IfCxCErrGen"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables\"]?.context?.runExecutionData \n  ? $('Variables').first().json.telefono \n  : $('Variables1').first().json.telefono \n}}"},{"name":"body","value":"=üë©‚Äçüíª Iniciando la carga de CxC"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[6320,-256],"id":"baed2baa-4794-4841-849e-bf46f55a0e1e","name":"NotificacionCargaCxC","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables\"]?.context?.runExecutionData \n  ? $('Variables').first().json.telefono \n  : $('Variables1').first().json.telefono \n}}"},{"name":"body","value":"=‚úÖ Cabeceras Cargadas exitosamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[8480,-176],"id":"79f33400-e63c-4987-8564-84ef667f54ab","name":"CabecerasOK","executeOnce":false},{"parameters":{"documentId":{"__rl":true,"value":"={{ \n$node[\"Convert File3\"]?.context?.runExecutionData \n  ? $('Convert File3').first().json.id \n  : $('Convert File2').first().json.id \n}}","mode":"id"},"sheetName":{"__rl":true,"value":"CxC","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[8656,-176],"id":"cae4c0e6-d581-44a3-9b4c-41638d96daee","name":"CxCCarga1","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"// n8n Function Node\n\n// --- Par√°metros de validaci√≥n ---\nconst COLS_DUP = [\"No documento\", \"No referencia\"];           // columnas a chequear duplicados\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"]; // fechas YMD requeridas\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);            // columnas que s√≠ pueden venir vac√≠as\nconst IGNORE_COLS = new Set([\"row_number\"]);                  // columnas que se ignoran en validaci√≥n y/o se eliminan al salir\n\n// --- Expresiones utilitarias ---\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g;  // controles (excepto \\n/\\r)\nconst PAGE_BREAK_REGEX = /\\f/g;                                    // salto de p√°gina\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;               // saltos de l√≠nea\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\nconst toRowNum = (row, idx) => row?.row_number != null ? row.row_number : (idx + 2);\n\n// Solo recorta bordes; NO colapsa espacios internos\nfunction cleanText(val) {\n  if (typeof val !== \"string\") return val;\n  return val\n    .replace(LINEBREAK_REGEX, \" \")    // saltos de l√≠nea -> espacio\n    .replace(PAGE_BREAK_REGEX, \" \")   // salto de p√°gina -> espacio\n    .replace(CONTROL_CHARS_REGEX, \" \")// otros controles -> espacio\n    .trim();                          // recorta SOLO al inicio/fin\n}\n\nfunction findSpecials(val) {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n}\n\n// --- Proceso principal ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza/normalizaci√≥n campo a campo\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return;\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de fechas YMD (permitimos espacios en bordes)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else if (!COLS_ALLOW_EMPTY.has(col)) {\n      errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n      rowsWithIssues.add(rowNum);\n    }\n  }\n\n  // Duplicados (solo recorte de bordes en la clave)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// Filas con error (ya limpias)\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\n\n// Salida con errores\nif (errores.length > 0) {\n  const mensaje = `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`;\n  return [{\n    json: {\n      ok: false,\n      mensaje,\n      errores,\n      filasConError,\n      ejecutado\n    }\n  }];\n}\n\n// Salida correcta: items limpios (sin IGNORE_COLS)\nconst salidaLimpia = cleanedItems.map(ci => {\n  const out = { ...ci.row };\n  for (const k of IGNORE_COLS) {\n    if (k in out) delete out[k];\n  }\n  return { json: out };\n});\n\nif (salidaLimpia.length === 0) {\n  return [{ json: { ok: true, mensaje: 'CXC - ‚úÖ Todo Correcto (sin filas)', rows: 0 } }];\n}\n\nreturn salidaLimpia;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[8832,-176],"id":"f691c959-2b18-4a33-955c-0667b37b8cf7","name":"InitCleaningCarga1","alwaysOutputData":false,"executeOnce":false},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"45850144-ae70-437c-bf45-523fa1499141","leftValue":"={{ !!$json.error }}","rightValue":"","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[9440,-176],"id":"d2b14dd6-255e-4650-9e0e-4e20f20f570b","name":"If1"},{"parameters":{"operation":"executeQuery","query":"{{$json.sql_linea}}","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[9280,-176],"id":"0cb05e95-f194-4124-8859-89bd510f3ef8","name":"InsertLineas1","retryOnFail":false,"alwaysOutputData":true,"credentials":{"postgres":{"id":"nPk4aB6nOLV1cRfH","name":"Postgres account 4"}},"onError":"continueRegularOutput"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables\"]?.context?.runExecutionData \n  ? $('Variables').first().json.telefono \n  : $('Variables1').first().json.telefono \n}}"},{"name":"body","value":"=‚úÖ Lineas Cargadas exitosamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[9968,-112],"id":"968d57c3-33e3-41ff-9f90-f5ef7ef8b8e2","name":"CabecerasOK1","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables\"]?.context?.runExecutionData \n  ? $('Variables').first().json.telefono \n  : $('Variables1').first().json.telefono \n}}"},{"name":"body","value":"=üö´ Cabeceras Registro no se completo, revise los logs\nError:\n{{ $json.message }}\n{{ $json.error.description }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[8320,-384],"id":"88c94660-3d84-4e65-a2a4-6ec37bcfd6d7","name":"BloqueoCxC1","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables\"]?.context?.runExecutionData \n  ? $('Variables').first().json.telefono \n  : $('Variables1').first().json.telefono \n}}"},{"name":"body","value":"=üö´ Lineas Registro no se completo, revise los logs\nErrores:\n{{ $json.message }}\n{{ $json.error.description }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[9712,-272],"id":"454e7ded-3add-4fe2-9888-e2ab717633cc","name":"BloqueoCxC2","executeOnce":false},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'TaxOB';            // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Impuesto'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4064,592],"id":"311fe592-dcbc-4a89-b5de-47d2cc18685a","name":"ValidaTax"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'CostCenterOB';     // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Centro de costo']; // Columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4304,592],"id":"a3ed6823-202e-41be-8cf2-c37851f3511f","name":"ValidaCosCenter"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'User1OB';          // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Usuario1'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4544,592],"id":"9489cf5d-744a-42ba-bc14-ac406c58292b","name":"ValidaUser1"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nlet ejecutado = false;\ntry {\n  const items = $('CxC').all(); // todos los items del nodo \"CxC\"\n  ejecutado = Array.isArray(items) && items.length > 0;\n} catch (error) {\n  ejecutado = false;\n}\nconst SHEET_NODE = ejecutado ? 'CxC' : 'CxP';                // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'BPLocationOB';     // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'taxid';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Tercero'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos y SOLO recorta bordes (no toca espacios intermedios)\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* Tercero sin Direccion`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4800,592],"id":"4273d929-5356-4b22-bcf3-5681bb0fb9ac","name":"ValidaBPLocation"},{"parameters":{"content":"## Validacion que no Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)","height":576,"width":224},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[1856,208],"id":"6fc0c6b9-de21-4ccb-b040-a0ffaac632fd","name":"Sticky Note1"},{"parameters":{"content":"## Validacion que si Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)","height":576,"width":208,"color":6},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[1648,208],"id":"095ec304-f989-41bd-911d-14b66b8fb28a","name":"Sticky Note2"},{"parameters":{"content":"## Validacion que si Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)","height":576,"width":2880,"color":6},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[2080,208],"id":"1e31dbf0-702e-43e0-9772-0e5082806f07","name":"Sticky Note3"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Code1').item.json.raw.message.documentMessage.title }}","rightValue":"CxC.xlsx","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-1056,32],"id":"4060e7e9-9c36-4c62-b538-6362b4dafb34","name":"If2"},{"parameters":{"workflowId":{"__rl":true,"value":"={{ $('Variables2').item.json.subworkflowID }}","mode":"id","cachedResultUrl":"/workflow/=%7B%7B%20$('Variables2').item.json.subworkflowID%20%7D%7D"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"options":{"waitForSubWorkflow":true}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[-896,608],"id":"a5a23d71-deae-4c5e-97cd-dbc1bd31d763","name":"Execute Workflow4","alwaysOutputData":true,"notesInFlow":false,"executeOnce":false,"retryOnFail":false},{"parameters":{"name":"={{ $('Variables').item.json.fileName }}\n","driveId":{"__rl":true,"value":"My Drive","mode":"list","cachedResultName":"My Drive","cachedResultUrl":"https://drive.google.com/drive/my-drive"},"folderId":{"__rl":true,"value":"={{ $('Variables').item.json.uploadFilesDirectory }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[32,240],"id":"05ff5655-4cc2-4030-ace2-cff4262291b1","name":"Upload file2","credentials":{"googleDriveOAuth2Api":{"id":"2D5m9UCVL0y0GKgC","name":"Google Drive account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Code1').item.json.raw.message.documentMessage.title }}","rightValue":"CxC.xlsx","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-112,496],"id":"8137d634-51ba-46d5-9841-a32afd60ab1d","name":"If4"},{"parameters":{"name":"={{ $('Variables2').item.json.fileName }}","driveId":{"__rl":true,"value":"My Drive","mode":"list","cachedResultName":"My Drive","cachedResultUrl":"https://drive.google.com/drive/my-drive"},"folderId":{"__rl":true,"value":"={{ $('Variables2').item.json.uploadFilesDirectory }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[48,704],"id":"0f6d428b-1110-440d-a79d-719e63689a28","name":"Upload file4","credentials":{"googleDriveOAuth2Api":{"id":"2D5m9UCVL0y0GKgC","name":"Google Drive account"}}},{"parameters":{"method":"POST","url":"=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy","authentication":"predefinedCredentialType","nodeCredentialType":"googleOAuth2Api","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables2').item.json.convertedFilesDirectory }}\"]\n}","options":{}},"id":"fe1a8665-3f62-491f-af32-a706d8e1f4c6","name":"Convert File5","type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[272,704],"credentials":{"googleOAuth2Api":{"id":"N3sd298xjJQFZGOz","name":"Google account"}},"onError":"continueErrorOutput"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=Error al Convertir Media Intente Nuevamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[464,864],"id":"c2f2b8d4-4127-41cd-979f-7ff111273093","name":"Response6"},{"parameters":{"documentId":{"__rl":true,"value":"={{ $json.id }}","mode":"id"},"sheetName":{"__rl":true,"value":"CxP","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[1168,352],"id":"701a78dd-d94d-47e6-b7dd-972845bfd363","name":"CxP","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"mode":"chooseBranch","useDataOfInput":2},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-1792,-688],"id":"bc8631b6-42d4-469e-962d-7d068b857fcf","name":"Merge8"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('CargarProductos').item.json.Plantilla.filename }}","rightValue":"CxC.xlsx","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-1584,-560],"id":"2766f29a-c215-4148-8280-559958daa0fd","name":"If3"},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"1hhic6Um17LbZv1B3fCQr27X-SASoagsH","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Ujakb61OzHsUIEXRQtT2oz7LutRh-THi","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://admchat.duckdns.org/wa-decrypt/decrypt-document","type":"string"},{"id":"e85da8f3-3311-4594-b365-55aadab8176e","name":"fileName","value":"CxP","type":"string"},{"id":"00dbcc54-57ea-4710-9124-a6979416f3cd","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"293163d2-3cb2-4103-a8de-90080923e03f","name":"telefono","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}","type":"string"}]},"includeOtherFields":true,"options":{"stripBinary":true}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-1440,-368],"id":"9d8bb2b6-0e83-4680-96dc-a0f3be28cafe","name":"Variables3"},{"parameters":{"method":"POST","url":"=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy","authentication":"predefinedCredentialType","nodeCredentialType":"googleOAuth2Api","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables3').item.json.convertedFilesDirectory }}\"]\n}","options":{}},"id":"34200f4e-9260-4867-9e09-05c49e094561","name":"Convert File1","type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-272,-480],"credentials":{"googleOAuth2Api":{"id":"N3sd298xjJQFZGOz","name":"Google account"}},"onError":"continueErrorOutput"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('CargarProductos1').item.json['Telefono Celular'] }}"},{"name":"body","value":"=Error al Convertir Media Intente Nuevamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-32,-272],"id":"ec99a530-5211-4100-940a-e8a4d3fa02a8","name":"Response7"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('CargarProductos').item.json.Plantilla.filename }}","rightValue":"CxC.xlsx","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-640,-608],"id":"c3afb3ff-5129-463e-aa43-1e08fd564c5b","name":"If5"},{"parameters":{"workflowId":{"__rl":true,"value":"={{ $('Variables3').item.json.subworkflowID }}","mode":"id"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"options":{"waitForSubWorkflow":true}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[-1232,-720],"id":"7b0dfa16-381a-46ab-b50e-feed1a068bc8","name":"Execute Workflow5","alwaysOutputData":true,"notesInFlow":false,"executeOnce":false,"retryOnFail":false},{"parameters":{"inputDataFieldName":"=data","name":"={{ $('Variables3').item.json.fileName }}","driveId":{"__rl":true,"mode":"list","value":"My Drive"},"folderId":{"__rl":true,"value":"={{ $('Variables3').item.json.uploadFilesDirectory }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-448,-480],"id":"e2525a49-c95d-47cf-96ac-60d65694366e","name":"Upload file5","credentials":{"googleDriveOAuth2Api":{"id":"2D5m9UCVL0y0GKgC","name":"Google Drive account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $json.ejecutado }}","rightValue":"CXC - ‚úÖ Todo Correcto","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[5728,160],"id":"88c6cd42-c1d0-4ac2-989e-02d4c2536c66","name":"If6"},{"parameters":{"jsCode":"// n8n Function Node\n\n// Columnas a verificar duplicados\nconst COLS_DUP = [\"No documento\", \"No referencia\"];\n\n// Columnas de fecha a validar \"aaaa-mm-dd\"\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"];\n\n// Columnas permitidas vac√≠as y columnas a ignorar en validaci√≥n\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);\nconst IGNORE_COLS = new Set([\"row_number\"]);\n\n// Regex de control/saltos de p√°gina y otros controles (excluimos \\n y \\r aqu√≠, los tratamos aparte)\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g; // incluye \\f (\\x0C) y otros controles\nconst PAGE_BREAK_REGEX = /\\f/g; // expl√≠cito\n// Saltos de l√≠nea/enter (incluye CRLF, CR, LF y separadores Unicode de l√≠nea/p√°rrafo)\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;\n\n// Permitidos por car√°cter (ya sin \\n/\\r porque los normalizamos a espacio)\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\n// Validaci√≥n de fecha aaaa-mm-dd + calendario real (bisiestos, etc.)\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\n// Helpers\nconst toRowNum = (row, idx) => {\n  if (row && row.row_number != null) return row.row_number;\n  return (idx + 2);\n};\n\n// SOLO trim al inicio/fin; NO colapsar espacios internos\nconst cleanText = (val) => {\n  if (typeof val !== \"string\") return val;\n  let cleaned = val;\n\n  // 1) Normalizar saltos de l√≠nea/enter -> espacio\n  cleaned = cleaned.replace(LINEBREAK_REGEX, \" \");\n\n  // 2) Normalizar saltos de p√°gina/control chars -> espacio\n  cleaned = cleaned.replace(PAGE_BREAK_REGEX, \" \");\n  cleaned = cleaned.replace(CONTROL_CHARS_REGEX, \" \");\n\n  // 3) Solo recortar bordes (no tocar espacios intermedios)\n  cleaned = cleaned.trim();\n\n  return cleaned;\n};\n\nconst findSpecials = (val) => {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n};\n\n// --- Proceso ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza + caracteres especiales + vac√≠os\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return; // omitir campos meta\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      // Limpieza\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      // Vac√≠o no permitido (excepto columnas permitidas)\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      // Detecci√≥n de caracteres especiales no permitidos post-limpieza\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // No-string: verificar nulos/indefinidos como vac√≠o (0 num√©rico es v√°lido)\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de formato y valor de fechas (aaaa-mm-dd)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim(); // solo bordes\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // tambi√©n aplica regla de \"no vac√≠o\" para fechas\n      if (!COLS_ALLOW_EMPTY.has(col)) {\n        errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  }\n\n  // Preparar detecci√≥n de duplicados (con valores ya limpios; recorte SOLO en bordes)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// (Opcional) Filas con error ya limpias, por si luego las quieres devolver\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Mensaje final requerido\nconst mensaje = errores.length\n  ? `CXP - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`\n  : 'CXP - ‚úÖ Todo Correcto';\n\nreturn [{\n  json: {\n    mensaje\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1888,-288],"id":"1ac5e05e-7e0b-4db3-a5bb-e247ca828361","name":"InitCleaning1","alwaysOutputData":false,"executeOnce":false},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Unificar Errores Productos').item.json.ejecutado }}","rightValue":"CXC - ‚úÖ Todo Correcto","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[6160,160],"id":"06c7b07b-bd4b-45e7-9cd5-c90d72defba9","name":"If7"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables2\"]?.context?.runExecutionData \n  ? $('Variables2').first().json.telefono \n  : $('Variables3').first().json.telefono \n}}"},{"name":"body","value":"=üë©‚Äçüíª Iniciando la carga de CxP"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[6400,320],"id":"2866c99b-0db3-48ce-967d-b3d21316e67d","name":"NotificacionCargaCxP","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables2\"]?.context?.runExecutionData \n  ? $('Variables2').first().json.telefono \n  : $('Variables3').first().json.telefono \n}}"},{"name":"body","value":"={{ $('Unificar Errores Productos').item.json.mensaje }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[5904,176],"id":"cb3b8fba-af72-4776-9597-47f5719d17b2","name":"ConfirmacionCXP","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Variables').first().json.telefono }}"},{"name":"body","value":"=üö´ No se puede proceder con la carga de los Saldos Iniciales"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[6336,-16],"id":"28ce2bd9-749f-4296-b914-94d6fa7f79bc","name":"BloqueoCxC/CXP","executeOnce":false},{"parameters":{"assignments":{"assignments":[{"id":"0ff4cbdf-2dbe-4a3d-953e-bed14de88ccc","name":"carga","value":"=Y","type":"string"},{"id":"840c1449-634a-4076-802a-71440699945f","name":"issotxx","value":"Y","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[6544,-176],"id":"12e53688-e839-4624-8ae5-129f3debbc73","name":"CargarCXC"},{"parameters":{"assignments":{"assignments":[{"id":"0ff4cbdf-2dbe-4a3d-953e-bed14de88ccc","name":"carga","value":"N","type":"string"},{"id":"840c1449-634a-4076-802a-71440699945f","name":"issotxx","value":"N","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[6560,96],"id":"96c56c43-d600-4171-9973-f0e474beddf1","name":"CargarCXP"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Unificar Errores Productos').item.json.ejecutado }}","rightValue":"CXC - ‚úÖ Todo Correcto","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[7216,0],"id":"62818def-3559-44eb-8e4c-4b257c1e4425","name":"If9"},{"parameters":{"documentId":{"__rl":true,"value":"={{ \n$node[\"Convert File5\"]?.context?.runExecutionData \n  ? $('Convert File5').first().json.id \n  : $('Convert File1').first().json.id \n}}","mode":"id"},"sheetName":{"__rl":true,"value":"CxP","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[7392,16],"id":"f2be1b10-8b9d-4bbe-91e6-d0f40fc612ef","name":"CxCCarga2","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Unificar Errores Productos').item.json.ejecutado }}","rightValue":"CXC - ‚úÖ Todo Correcto","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[8224,-32],"id":"5cc64599-ccc1-4325-a26c-cf1c9f4d42b4","name":"If10"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables2\"]?.context?.runExecutionData \n  ? $('Variables2').first().json.telefono \n  : $('Variables3').first().json.telefono \n}}"},{"name":"body","value":"=‚úÖ Cabeceras Cargadas exitosamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[8464,272],"id":"edbca7c7-07c9-4a18-84f1-7a85fff28896","name":"CabecerasOK2","executeOnce":false},{"parameters":{"documentId":{"__rl":true,"value":"={{ \n$node[\"Convert File5\"]?.context?.runExecutionData \n  ? $('Convert File5').first().json.id \n  : $('Convert File1').first().json.id \n}}","mode":"id"},"sheetName":{"__rl":true,"value":"CxP","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[8640,272],"id":"52f587c0-a30f-4fa6-893a-2f775d4ec5d1","name":"CxCCarga3","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ \n$node[\"Variables2\"]?.context?.runExecutionData \n  ? $('Variables2').first().json.telefono \n  : $('Variables3').first().json.telefono \n}}"},{"name":"body","value":"=‚úÖ Lineas Cargadas exitosamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[9952,240],"id":"12ea8f37-7174-4ad3-9153-73b3787f6072","name":"CabecerasOK3","executeOnce":false},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Unificar Errores Productos').item.json.ejecutado }}","rightValue":"CXC - ‚úÖ Todo Correcto","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[9648,48],"id":"eb524b10-938d-487e-b9c4-f21a1d5633b1","name":"If11"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Code node: CrearSQLCabecera\n// Mode: Run Once for Each Item\n\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Datos de soporte desde ADClient (un √∫nico registro) ===\nconst adClient = $items(\"ADClient\", 0, 0)[0]?.json;\nconst adClientId = adClient?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n\n// === Fila actual (ya limpia) ===\nconst row = $json;\n\n// Si no tienes row_number de Sheets, usa √≠ndice + 2 (cabecera = fila 1)\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Metadatos √∫tiles para logs\nconst _doc = row['No documento'];\nconst _ref = row['No referencia'];\n\n// === Construir SQL de CABECERA (multi-l√≠nea) ===\nlet sql = `\nINSERT INTO c_invoice(\n  c_invoice_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  issotrx, documentno, docstatus, docaction, processing, processed, posted,\n  c_doctype_id, c_doctypetarget_id, c_order_id, description, isprinted, salesrep_id,\n  dateinvoiced, dateprinted, dateacct, c_bpartner_id, c_bpartner_location_id,\n  poreference, isdiscountprinted, dateordered, c_currency_id, paymentrule, c_paymentterm_id,\n  c_charge_id, chargeamt, m_pricelist_id, istaxincluded, c_campaign_id, c_project_id,\n  c_activity_id, createfrom, generateto, ad_user_id, copyfrom, isselfservice, ad_orgtrx_id,\n  user2_id, withholdingamount, taxdate, c_withholding_id, fin_paymentmethod_id, c_costcenter_id,\n  user1_id\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(), '100', now(), '100',\n  'N',\n  ${sqlSafe(row['No documento'])},\n  'DR','CO','N','N','N',\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  NULL,\n  ${sqlSafe(row['Descripcion'])},\n  'N',\n  NULL,\n  to_date(${sqlSafe(row['Fecha de la factura'])}, 'yyyy-mm-dd'),\n  NULL,\n  to_date(${sqlSafe(row['Fecha contable'])}, 'yyyy-mm-dd'),\n  (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])}),\n  (SELECT c_bpartner_location_id\n     FROM c_bpartner_location\n    WHERE c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND isbillto = 'Y'\n    LIMIT 1),\n  ${sqlSafe(row['No referencia'])},\n  'Y',\n  NULL,\n  (select c_currency_id from c_currency where iso_code = ${sqlSafe(row['Moneda'])}),\n  '2',\n  (select c_paymentterm_id from c_paymentterm where name = ${sqlSafe(row['Condiciones de pago'])}),\n  NULL,\n  NULL,\n  (select m_pricelist_id from m_pricelist where name = ${sqlSafe(row['Lista de precios'])}),\n  'N',\n  NULL, NULL, NULL,\n  'N','N',\n  NULL,\n  'N','N',\n  NULL,\n  NULL,\n  0,\n  to_date(${sqlSafe(row['Fecha impuesto'])}, 'yyyy-mm-dd'),\n  NULL,\n  (SELECT fin_paymentmethod_id FROM fin_paymentmethod WHERE name = ${sqlSafe(row['Forma de pago'])}),\n  (SELECT c_costcenter_id FROM c_costcenter WHERE name = ${sqlSafe(row['Centro de costo'])}),\n  (SELECT user1_id FROM user1 WHERE name = ${sqlSafe(row['Usuario1'])})\n);\n`.trim();\n\n// === Normalizaci√≥n m√≠nima ===\n// Quitar saltos de l√≠nea y tabs para que el Postgres node reciba una sola l√≠nea,\n// pero SIN colapsar espacios internos.\nsql = sql\n  .replace(/\\r?\\n|\\r/g, ' ')\n  .replace(/\\t/g, ' ')\n  .trim();\n\n// >>> DEVOLVER UN SOLO OBJETO (no array) <<<\nreturn {\n  json: {\n    ...row,\n    _rowNum,\n    _doc,\n    _ref,\n    sql_cabecera: sql\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7824,32],"id":"3c8272b1-93b2-4a28-93d5-5269a46b2d8f","name":"CrearSQLCabecera1"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d2942958-a1dd-445c-a182-c7ac9bbc9630","leftValue":"={{ $('Unificar Errores Productos').item.json.ejecutado }}","rightValue":"CXC - ‚úÖ Todo Correcto","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[7616,16],"id":"cfd526e3-7b29-492d-9a64-62b186448e46","name":"If8"},{"parameters":{"operation":"toBinary","sourceProperty":"data","binaryPropertyName":"=data","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[-288,496],"id":"dfaf29e5-80e1-4e62-91cd-8ecd3868540a","name":"Convert to File1"}],"connections":{"Code3":{"main":[[{"node":"Merge","type":"main","index":1},{"node":"FacturasOB","type":"main","index":0}]]},"Unificar Errores Productos":{"main":[[{"node":"If6","type":"main","index":0}]]},"Merge":{"main":[[{"node":"Merge2","type":"main","index":3}]]},"InitCleaning":{"main":[[{"node":"Merge","type":"main","index":0}]]},"AdOrgOB":{"main":[[{"node":"Code3","type":"main","index":0}]]},"FacturasOB":{"main":[[{"node":"FactOB","type":"main","index":0}]]},"DoctypeOB":{"main":[[{"node":"DtOB","type":"main","index":0}]]},"FactOB":{"main":[[{"node":"Merge","type":"main","index":2},{"node":"DoctypeOB","type":"main","index":0}]]},"DtOB":{"main":[[{"node":"Merge","type":"main","index":3},{"node":"PartnerOB","type":"main","index":0}]]},"PartnerOB":{"main":[[{"node":"BPOB","type":"main","index":0}]]},"BPOB":{"main":[[{"node":"Merge","type":"main","index":4},{"node":"PriceListOB","type":"main","index":0}]]},"PriceListOB":{"main":[[{"node":"ValidaPriceList","type":"main","index":0}]]},"ValidaPriceList":{"main":[[{"node":"MonedaOB","type":"main","index":0},{"node":"Merge2","type":"main","index":4}]]},"MonedaOB":{"main":[[{"node":"ValidaCurrency","type":"main","index":0}]]},"PaymentMethodOB":{"main":[[{"node":"ValidaPaymentMethod","type":"main","index":0}]]},"ValidaPaymentMethod":{"main":[[{"node":"PaymentTermOB","type":"main","index":0},{"node":"Merge","type":"main","index":6}]]},"PaymentTermOB":{"main":[[{"node":"ValidaPaymentTerm","type":"main","index":0}]]},"ValidaCurrency":{"main":[[{"node":"PaymentMethodOB","type":"main","index":0},{"node":"Merge","type":"main","index":5}]]},"ValidaPaymentTerm":{"main":[[{"node":"Merge","type":"main","index":7},{"node":"ProductOB","type":"main","index":0}]]},"ProductOB":{"main":[[{"node":"ValidaProduct","type":"main","index":0}]]},"ValidaProduct":{"main":[[{"node":"UnidadOB","type":"main","index":0},{"node":"Merge","type":"main","index":8}]]},"UnidadOB":{"main":[[{"node":"ValidaUnidad","type":"main","index":0}]]},"ValidaUnidad":{"main":[[{"node":"Merge","type":"main","index":9},{"node":"TaxOB","type":"main","index":0}]]},"TaxOB":{"main":[[{"node":"ValidaTax","type":"main","index":0}]]},"CostCenterOB":{"main":[[{"node":"ValidaCosCenter","type":"main","index":0}]]},"User1OB":{"main":[[{"node":"ValidaUser1","type":"main","index":0}]]},"Merge2":{"main":[[{"node":"Unificar Errores Productos","type":"main","index":0}]]},"CargarProductos":{"main":[[{"node":"MsgInicial2","type":"main","index":0},{"node":"Extract from File","type":"main","index":0}]]},"Upload file1":{"main":[[{"node":"Convert File2","type":"main","index":0}]]},"Variables":{"main":[[{"node":"If2","type":"main","index":0},{"node":"Merge4","type":"main","index":1}]]},"Variables1":{"main":[[{"node":"Execute Workflow","type":"main","index":0},{"node":"Merge3","type":"main","index":1}]]},"Extract from File":{"main":[[{"node":"Merge8","type":"main","index":1}]]},"Convert to File":{"main":[[{"node":"If5","type":"main","index":0}]]},"Execute Workflow":{"main":[[{"node":"Merge3","type":"main","index":0}]]},"Merge3":{"main":[[{"node":"Convert to File","type":"main","index":0}]]},"Execute Workflow1":{"main":[[{"node":"Merge4","type":"main","index":0}]]},"Merge4":{"main":[[{"node":"HTTP Request","type":"main","index":0}]]},"Convert File2":{"main":[[{"node":"CxC","type":"main","index":0}],[{"node":"Response2","type":"main","index":0}]]},"Code1":{"main":[[{"node":"Code4","type":"main","index":0}]]},"Webhook":{"main":[[{"node":"Homologar_msg","type":"main","index":0}]]},"Switch":{"main":[[{"node":"MsgInicial","type":"main","index":0}],[{"node":"Response","type":"main","index":0}]]},"Homologar_msg":{"main":[[{"node":"Code1","type":"main","index":0}]]},"HTTP Request":{"main":[[{"node":"Convert to File1","type":"main","index":0}]]},"Convert File3":{"main":[[{"node":"CxC","type":"main","index":0}],[{"node":"Response1","type":"main","index":0}]]},"CxC":{"main":[[{"node":"AdOrgOB","type":"main","index":0},{"node":"InitCleaning","type":"main","index":0}]]},"MsgInicial":{"main":[[{"node":"Variables","type":"main","index":0}]]},"MsgInicial2":{"main":[[{"node":"Merge8","type":"main","index":0}]]},"Variables2":{"main":[[{"node":"If2","type":"main","index":0},{"node":"Merge4","type":"main","index":1}]]},"Switch1":{"main":[[{"node":"MsgInicial1","type":"main","index":0}],[{"node":"Response3","type":"main","index":0}]]},"MsgInicial1":{"main":[[{"node":"Variables2","type":"main","index":0}]]},"Code4":{"main":[[{"node":"Switch","type":"main","index":0}]]},"Confirmacion":{"main":[[{"node":"IfCxCErrGen","type":"main","index":0}]]},"CxCCarga":{"main":[[{"node":"InitCleaningCarga","type":"main","index":0}]]},"ADClient":{"main":[[{"node":"ADOrg","type":"main","index":0}]]},"InitCleaningCarga":{"main":[[{"node":"If8","type":"main","index":0}]]},"ADOrg":{"main":[[{"node":"If9","type":"main","index":0}]]},"InsertCabecera":{"main":[[{"node":"If","type":"main","index":0}]]},"CrearSQLCabecera":{"main":[[{"node":"InsertCabecera","type":"main","index":0}]]},"If":{"main":[[{"node":"BloqueoCxC1","type":"main","index":0}],[{"node":"If10","type":"main","index":0}]]},"CrearSQLLinea":{"main":[[{"node":"InsertLineas1","type":"main","index":0}]]},"When clicking ‚ÄòExecute workflow‚Äô":{"main":[[{"node":"ADClient","type":"main","index":0}]]},"BPLocationOB":{"main":[[{"node":"ValidaBPLocation","type":"main","index":0}]]},"IfCxCErrGen":{"main":[[{"node":"If7","type":"main","index":0}],[{"node":"BloqueoCxC/CXP","type":"main","index":0}]]},"NotificacionCargaCxC":{"main":[[{"node":"CargarCXC","type":"main","index":0}]]},"CxCCarga1":{"main":[[{"node":"InitCleaningCarga1","type":"main","index":0}]]},"CabecerasOK":{"main":[[{"node":"CxCCarga1","type":"main","index":0}]]},"InitCleaningCarga1":{"main":[[{"node":"CrearSQLLinea","type":"main","index":0}]]},"InsertLineas1":{"main":[[{"node":"If1","type":"main","index":0}]]},"If1":{"main":[[{"node":"BloqueoCxC2","type":"main","index":0}],[{"node":"If11","type":"main","index":0}]]},"ValidaTax":{"main":[[{"node":"CostCenterOB","type":"main","index":0},{"node":"Merge2","type":"main","index":0}]]},"ValidaCosCenter":{"main":[[{"node":"User1OB","type":"main","index":0},{"node":"Merge2","type":"main","index":1}]]},"ValidaUser1":{"main":[[{"node":"Merge2","type":"main","index":2},{"node":"BPLocationOB","type":"main","index":0}]]},"ValidaBPLocation":{"main":[[{"node":"Merge2","type":"main","index":5}]]},"If2":{"main":[[{"node":"Execute Workflow1","type":"main","index":0}],[{"node":"Execute Workflow4","type":"main","index":0}]]},"Execute Workflow4":{"main":[[{"node":"Merge4","type":"main","index":0}]]},"Upload file2":{"main":[[{"node":"Convert File3","type":"main","index":0}]]},"Response1":{"main":[[]]},"If4":{"main":[[{"node":"Upload file2","type":"main","index":0}],[{"node":"Upload file4","type":"main","index":0}]]},"Upload file4":{"main":[[{"node":"Convert File5","type":"main","index":0}]]},"Convert File5":{"main":[[{"node":"CxP","type":"main","index":0}],[{"node":"Response6","type":"main","index":0}]]},"CxP":{"main":[[{"node":"InitCleaning1","type":"main","index":0},{"node":"AdOrgOB","type":"main","index":0}]]},"Merge8":{"main":[[{"node":"If3","type":"main","index":0}]]},"If3":{"main":[[{"node":"Variables1","type":"main","index":0}],[{"node":"Variables3","type":"main","index":0}]]},"Variables3":{"main":[[{"node":"Merge3","type":"main","index":1},{"node":"Execute Workflow5","type":"main","index":0}]]},"Convert File1":{"main":[[{"node":"CxP","type":"main","index":0}],[{"node":"Response7","type":"main","index":0}]]},"If5":{"main":[[{"node":"Upload file1","type":"main","index":0}],[{"node":"Upload file5","type":"main","index":0}]]},"Execute Workflow5":{"main":[[{"node":"Merge3","type":"main","index":0}]]},"Upload file5":{"main":[[{"node":"Convert File1","type":"main","index":0}]]},"If6":{"main":[[{"node":"Confirmacion","type":"main","index":0}],[{"node":"ConfirmacionCXP","type":"main","index":0}]]},"InitCleaning1":{"main":[[{"node":"Merge","type":"main","index":0}]]},"If7":{"main":[[{"node":"NotificacionCargaCxC","type":"main","index":0}],[{"node":"NotificacionCargaCxP","type":"main","index":0}]]},"NotificacionCargaCxP":{"main":[[{"node":"CargarCXP","type":"main","index":0}]]},"ConfirmacionCXP":{"main":[[{"node":"IfCxCErrGen","type":"main","index":0}]]},"CargarCXC":{"main":[[{"node":"ADClient","type":"main","index":0}]]},"CargarCXP":{"main":[[{"node":"ADClient","type":"main","index":0}]]},"If9":{"main":[[{"node":"CxCCarga","type":"main","index":0}],[{"node":"CxCCarga2","type":"main","index":0}]]},"CxCCarga2":{"main":[[{"node":"InitCleaningCarga","type":"main","index":0}]]},"If10":{"main":[[{"node":"CabecerasOK","type":"main","index":0}],[{"node":"CabecerasOK2","type":"main","index":0}]]},"CxCCarga3":{"main":[[{"node":"InitCleaningCarga1","type":"main","index":0}]]},"CabecerasOK2":{"main":[[{"node":"CxCCarga3","type":"main","index":0}]]},"If11":{"main":[[{"node":"CabecerasOK1","type":"main","index":0}],[{"node":"CabecerasOK3","type":"main","index":0}]]},"If8":{"main":[[{"node":"CrearSQLCabecera","type":"main","index":0}],[{"node":"CrearSQLCabecera1","type":"main","index":0}]]},"CrearSQLCabecera1":{"main":[[{"node":"InsertCabecera","type":"main","index":0}]]},"Convert to File1":{"main":[[{"node":"If4","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","callerPolicy":"workflowsFromSameOwner","availableInMCP":false,"errorWorkflow":"wDIfVDMoYUvKr3Ho","timeSavedPerExecution":7},"staticData":{"node:Google Drive Trigger":{"lastTimeChecked":"2025-10-08T14:27:45Z"}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"3c69d816-15d7-4be7-9f32-75d1bf0ca732","triggerCount":2,"shared":[{"createdAt":"2025-10-15T16:06:50.994Z","updatedAt":"2025-10-15T16:06:50.994Z","role":"workflow:owner","workflowId":"wDIfVDMoYUvKr3Ho","projectId":"Bev2pwmvUzes1BM7"}],"tags":[]}