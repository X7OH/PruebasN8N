{
  "name": "Pruebas - PMOSaldoInicialCxC",
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "={{ $('Unificar Errores Productos').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5824,
        -112
      ],
      "id": "44d24f8e-d3cd-46c0-a9e3-9e4459ab36fd",
      "name": "Confirmacion",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'AdOrgOB';          // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Organizacion'];    // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // saltos/tabs -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim();                                  // SOLO recorta bordes (no colapsa interiores)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return { json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } };\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return { json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } };\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo trim en bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\n// En un Code node en modo \"Run Once\", devuelve UN SOLO objeto:\nreturn { json: { mensaje } };\n\n/** Si prefieres la salida detallada, usa esto (tambi√©n como objeto √∫nico):\nreturn {\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n};\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1712,
        592
      ],
      "id": "24c7179e-f2e0-4dd3-abf6-6481373eb2f5",
      "name": "Code3"
    },
    {
      "parameters": {
        "jsCode": "// Lee todo lo que llega del Merge y decide EXITO / ERROR\nfunction pickMsgs(items) {\n  return items.map(i => String(i.json?.mensaje ?? '').trim()).filter(Boolean);\n}\nfunction hasErr(s) { return /error/i.test(s); }\nfunction bullets(msg) {\n  const m = String(msg).match(/errores?\\s+encontrados:\\s*([\\s\\S]*)/i);\n  const body = (m ? m[1] : msg).replace(/\\r/g, '');\n  const set = new Set(body.split('\\n').map(x => x.trim()).filter(Boolean));\n  return Array.from(set).map(x => x.startsWith('-') ? x : `- ${x}`);\n}\n\nconst msgs = pickMsgs($items('Merge2'));\nconst errs = msgs.filter(hasErr);\n\nlet resultado, mensaje;\nif (errs.length === 0) {\n  resultado = 'EXITO';\n  mensaje = 'CXC - ‚úÖ Todo Correcto';\n} else {\n  const all = errs.flatMap(bullets);\n  resultado = 'ERROR';\n  mensaje = `CXC - üö´ Errores encontrados:\\n${all.join('\\n')}`;\n}\n\nreturn [{ json: { resultado, mensaje, totalMensajes: msgs.length, totalConError: errs.length } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5632,
        -112
      ],
      "id": "1e5f506d-2acc-4b6b-bd8b-4e7a1d861c3a",
      "name": "Unificar Errores Productos"
    },
    {
      "parameters": {
        "numberInputs": 10
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5136,
        -544
      ],
      "id": "6b03881d-478c-4efa-9301-7a27fee95799",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function Node\n\n// Columnas a verificar duplicados\nconst COLS_DUP = [\"No documento\", \"No referencia\"];\n\n// Columnas de fecha a validar \"aaaa-mm-dd\"\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"];\n\n// Columnas permitidas vac√≠as y columnas a ignorar en validaci√≥n\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);\nconst IGNORE_COLS = new Set([\"row_number\"]);\n\n// Regex de control/saltos de p√°gina y otros controles (excluimos \\n y \\r aqu√≠, los tratamos aparte)\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g; // incluye \\f (\\x0C) y otros controles\nconst PAGE_BREAK_REGEX = /\\f/g; // expl√≠cito\n// Saltos de l√≠nea/enter (incluye CRLF, CR, LF y separadores Unicode de l√≠nea/p√°rrafo)\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;\n\n// Permitidos por car√°cter (ya sin \\n/\\r porque los normalizamos a espacio)\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\n// Validaci√≥n de fecha aaaa-mm-dd + calendario real (bisiestos, etc.)\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\n// Helpers\nconst toRowNum = (row, idx) => {\n  if (row && row.row_number != null) return row.row_number;\n  return (idx + 2);\n};\n\n// SOLO trim al inicio/fin; NO colapsar espacios internos\nconst cleanText = (val) => {\n  if (typeof val !== \"string\") return val;\n  let cleaned = val;\n\n  // 1) Normalizar saltos de l√≠nea/enter -> espacio\n  cleaned = cleaned.replace(LINEBREAK_REGEX, \" \");\n\n  // 2) Normalizar saltos de p√°gina/control chars -> espacio\n  cleaned = cleaned.replace(PAGE_BREAK_REGEX, \" \");\n  cleaned = cleaned.replace(CONTROL_CHARS_REGEX, \" \");\n\n  // 3) Solo recortar bordes (no tocar espacios intermedios)\n  cleaned = cleaned.trim();\n\n  return cleaned;\n};\n\nconst findSpecials = (val) => {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n};\n\n// --- Proceso ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza + caracteres especiales + vac√≠os\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return; // omitir campos meta\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      // Limpieza\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      // Vac√≠o no permitido (excepto columnas permitidas)\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      // Detecci√≥n de caracteres especiales no permitidos post-limpieza\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // No-string: verificar nulos/indefinidos como vac√≠o (0 num√©rico es v√°lido)\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de formato y valor de fechas (aaaa-mm-dd)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim(); // solo bordes\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // tambi√©n aplica regla de \"no vac√≠o\" para fechas\n      if (!COLS_ALLOW_EMPTY.has(col)) {\n        errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  }\n\n  // Preparar detecci√≥n de duplicados (con valores ya limpios; recorte SOLO en bordes)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// (Opcional) Filas con error ya limpias, por si luego las quieres devolver\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Mensaje final requerido\nconst mensaje = errores.length\n  ? `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`\n  : 'CXC - ‚úÖ Todo Correcto';\n\nreturn [{\n  json: {\n    mensaje\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        48
      ],
      "id": "6c0ad0ba-ca2d-4d53-951c-85e570303491",
      "name": "InitCleaning",
      "alwaysOutputData": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from ad_org where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1696,
        336
      ],
      "id": "a48dbb6a-c980-4ba0-9749-230493e1d92e",
      "name": "AdOrgOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select documentno from c_invoice where issotrx='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1920,
        336
      ],
      "id": "adc8e0a9-28ff-4596-bfc9-ea3269d535ac",
      "name": "FacturasOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name  from c_doctype  where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2160,
        336
      ],
      "id": "9288ee60-1a70-4af7-a06a-ceccb712db70",
      "name": "DoctypeOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';              // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'FacturasOB';    // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'documentno';   // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['No documento','No referencia']; // columnas del Sheet a validar contra Postgres\n\nconst NORMALIZAR = true;   // true: sin tildes y MAY√öSCULAS (se preservan espacios internos)\nconst TRIM_EMPTY = true;   // true: ignora vac√≠os\n\n// === Normalizadores (NO colapsan espacios internos) ===\nconst cleanDisplay = (s) => {\n  let out = (s ?? '').toString();\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // forma can√≥nica\n  return out.trim();                               // SOLO bordes; NO tocar espacios internos\n};\n\nconst norm = (s) => {\n  let out = cleanDisplay(s);\n  if (TRIM_EMPTY && out === '') return '';\n  if (!NORMALIZAR) return out;\n  // quitar tildes + pasar a MAY√öSCULAS; preserva espacios intermedios\n  return out.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toUpperCase();\n};\n\n// === 1) Datasheet (Google Sheets) ===\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `PRODUCTOS - üö´ No hay datos desde el nodo Sheet \"${SHEET_NODE}\"`, totalErrores: 1 } }];\n}\nconst sheetRows = sheetItems.map((it, i) => {\n  const r = it.json || {};\n  const base = { rowNumber: r.row_number ?? (i + 2) }; // encabezado en fila 1\n  for (const col of COLS_VALIDAR) {\n    base[`${col}Raw`]  = cleanDisplay(r[col]);  // muestra (solo trim bordes)\n    base[`${col}Norm`] = norm(r[col]);          // clave de comparaci√≥n\n  }\n  return base;\n});\n\n// === 2) Postgres (UNA sola columna) ===\nconst obRows = ($items(POSTGRES_NODE) || []).map(it => it.json || {});\nconst obSet = new Set(\n  obRows.map(r => norm(r[POSTGRES_FIELD])).filter(v => v !== '')\n);\n\n// === 3) Acumular coincidencias (valores del sheet que YA existen en OB) ===\nconst dupPorColumna = {};\nfor (const col of COLS_VALIDAR) dupPorColumna[col] = new Map();\n\nfor (const r of sheetRows) {\n  for (const col of COLS_VALIDAR) {\n    const key = r[`${col}Norm`];\n    if (!key) continue;\n    if (obSet.has(key)) {\n      const entry = dupPorColumna[col].get(key) || { muestra: r[`${col}Raw`] || '(vac√≠o)', rows: [] };\n      entry.rows.push(r.rowNumber);\n      dupPorColumna[col].set(key, entry);\n    }\n  }\n}\n\n// === 4) Mensajes en el formato solicitado ===\nconst errores = [];\nconst sortByMuestra = (a, b) => a.muestra.localeCompare(b.muestra, 'es', { sensitivity: 'base' });\n\nfor (const col of COLS_VALIDAR) {\n  const valores = [...dupPorColumna[col].values()].sort(sortByMuestra);\n  valores.forEach(e => {\n    e.rows.sort((a, b) => a - b);\n    errores.push(`Duplicado en columna \"${col}\": valor \"${e.muestra}\" en filas ${e.rows.join(', ')}`);\n  });\n}\n\n// === 5) Salida ===\nconst mensaje = errores.length === 0\n  ? `CxC - ‚úÖ Todo Correcto`\n  : `CxC (existentes en OB) - üö´ Error Coincidencias encontradas:\\n- ${errores.join('\\n- ')}`;\n\nreturn [{\n  json: {\n    mensaje,\n    totalErrores: errores.length\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        592
      ],
      "id": "9f954c4a-0766-4264-9f79-1391c2814414",
      "name": "FactOB"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'DoctypeOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();    // respeta espacios tal cual\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        592
      ],
      "id": "ec1c65cc-cbc4-4f9f-8ec4-1d63424959a8",
      "name": "DtOB"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select taxid from c_bpartner where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2416,
        336
      ],
      "id": "9b9161b8-9323-4d13-b9af-2eec719336d8",
      "name": "PartnerOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'DoctypeOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2416,
        592
      ],
      "id": "05885773-a86b-4820-94fc-97aa6097d4f2",
      "name": "BPOB"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from m_pricelist where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2656,
        336
      ],
      "id": "86191383-831a-4694-a165-8a362398f525",
      "name": "PriceListOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PriceListOB';      // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Lista de precios']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia sin tocar espacios internos: reemplaza CR/LF/TAB por un espacio,\n// elimina NBSP/zero-width, normaliza unicode y SOLO trim de bordes.\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // CR/LF/TAB -> espacio\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim();                                  // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia exacta por nombre limpio) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) }; // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (conserva espacios internos)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2656,
        592
      ],
      "id": "2c2f63d6-2a5a-4982-8951-4b2ab81bb58c",
      "name": "ValidaPriceList"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select iso_code from c_currency where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2896,
        336
      ],
      "id": "ba800d6d-2740-4bd1-aa70-c7198ac99f66",
      "name": "MonedaOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'MonedaOB';         // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'iso_code';        // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Moneda'];          // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2896,
        592
      ],
      "id": "62fbd65f-7f62-4f7f-8b33-ab3c1e0fc72e",
      "name": "ValidaCurrency"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from fin_paymentmethod where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3136,
        336
      ],
      "id": "1fc02d07-f81d-41a1-8540-878bb0c065f4",
      "name": "PaymentMethodOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentMethodOB';  // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Forma de pago'];   // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia caracteres invisibles y saltos a espacios, y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3136,
        592
      ],
      "id": "38f2a32d-7514-46b1-b1ef-2677cc06ed4c",
      "name": "ValidaPaymentMethod"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from c_paymentterm where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3376,
        336
      ],
      "id": "d766c2b0-0338-4782-9e77-f845c85b3242",
      "name": "PaymentTermOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentTermOB';    // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Condiciones de pago']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos a espacios y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> un espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3376,
        592
      ],
      "id": "da290f5a-dd04-40f8-96dc-66b747fad268",
      "name": "ValidaPaymentTerm"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from m_product where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3600,
        336
      ],
      "id": "ddcf3415-2857-4400-8531-eca5bc0c176b",
      "name": "ProductOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'ProductOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Producto'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos a espacios y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> un espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        592
      ],
      "id": "2b04b1a6-f049-49b3-b60a-cc08a58623c6",
      "name": "ValidaProduct"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select uomsymbol from c_uom where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3824,
        336
      ],
      "id": "7f1eee94-a041-4bd4-baf3-35f0830bfe69",
      "name": "UnidadOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'UnidadOB';         // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'uomsymbol';       // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Unidad de la orden']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos y SOLO recorta bordes (no toca espacios internos normales)\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                 // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3824,
        592
      ],
      "id": "e88b9a4a-8844-497d-82fc-04b5ec7f21ed",
      "name": "ValidaUnidad"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from c_tax where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4064,
        336
      ],
      "id": "a231e5c4-69a5-4871-9883-1781dd8fae84",
      "name": "TaxOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from c_costcenter where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4304,
        336
      ],
      "id": "10d3b5ea-0bfc-459b-a90d-bf4e92605e4b",
      "name": "CostCenterOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from user1 where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4544,
        336
      ],
      "id": "b7dc924b-2311-4fae-aff9-a759753d77df",
      "name": "User1OB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 6
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5424,
        -176
      ],
      "id": "f7b5056a-d0f6-48c7-a926-2039376f22de",
      "name": "Merge2"
    },
    {
      "parameters": {
        "formTitle": "Saldos Iniciales CxC",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Plantilla",
              "fieldType": "file",
              "multipleFiles": false,
              "acceptFileTypes": ".xlsx",
              "requiredField": true
            },
            {
              "fieldLabel": "Telefono Celular",
              "requiredField": true
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -2256,
        -288
      ],
      "id": "dc16889d-1104-4994-b78e-dd47ce15eda3",
      "name": "CargarProductos",
      "webhookId": "b90fc8f4-f1f2-4a24-99a5-48b30649fc01"
    },
    {
      "parameters": {
        "inputDataFieldName": "=data",
        "name": "={{ $('Variables1').item.json.fileName }}",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ $('Variables1').item.json.uploadFilesDirectory }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -784,
        -304
      ],
      "id": "c649b6fc-c792-476f-9b08-50f93785a22d",
      "name": "Upload file1",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2D5m9UCVL0y0GKgC",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "49f12a44-11ae-4849-94b4-4c0b492c3641",
              "name": "uploadFilesDirectory",
              "value": "13IxZ60e9aoBpSIIxNBk01_zZxbkVPkow",
              "type": "string"
            },
            {
              "id": "ff554178-aa16-4be5-bfb3-9368f7a56607",
              "name": "convertedFilesDirectory",
              "value": "1Az-ZFrPX8NLT3-AOv8lUBOLu-wS2c34i",
              "type": "string"
            },
            {
              "id": "6fb746c8-33c8-48f2-8d85-b2ff886625d5",
              "name": "decryptApi",
              "value": "https://admchat.duckdns.org/wa-decrypt/decrypt-document",
              "type": "string"
            },
            {
              "id": "f197f9b9-0992-47b5-8faf-85fecda67503",
              "name": "fileName",
              "value": false,
              "type": "string"
            },
            {
              "id": "1071c733-64c4-46b4-9933-ad3c843c05fb",
              "name": "subworkflowID",
              "value": "gqt6yXfnufkwZYCz",
              "type": "string"
            },
            {
              "id": "343aeec5-aa95-461c-9272-d17dedf033ca",
              "name": "telefono",
              "value": "={{ $('Homologar_msg').item.json.telefono }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1120,
        224
      ],
      "id": "e57e04f4-2330-4ff2-9644-dde1d0996bb4",
      "name": "Variables"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "49f12a44-11ae-4849-94b4-4c0b492c3641",
              "name": "uploadFilesDirectory",
              "value": "13IxZ60e9aoBpSIIxNBk01_zZxbkVPkow",
              "type": "string"
            },
            {
              "id": "ff554178-aa16-4be5-bfb3-9368f7a56607",
              "name": "convertedFilesDirectory",
              "value": "1Az-ZFrPX8NLT3-AOv8lUBOLu-wS2c34i",
              "type": "string"
            },
            {
              "id": "6fb746c8-33c8-48f2-8d85-b2ff886625d5",
              "name": "decryptApi",
              "value": "https://admchat.duckdns.org/wa-decrypt/decrypt-document",
              "type": "string"
            },
            {
              "id": "e85da8f3-3311-4594-b365-55aadab8176e",
              "name": "fileName",
              "value": "CxC",
              "type": "string"
            },
            {
              "id": "00dbcc54-57ea-4710-9124-a6979416f3cd",
              "name": "subworkflowID",
              "value": "gqt6yXfnufkwZYCz",
              "type": "string"
            },
            {
              "id": "293163d2-3cb2-4103-a8de-90080923e03f",
              "name": "telefono",
              "value": "={{ $('CargarProductos').item.json['Telefono Celular'] }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "stripBinary": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1504,
        -288
      ],
      "id": "6c687a13-29e0-42c3-a8ca-947e60e589bc",
      "name": "Variables1"
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "binaryPropertyName": "Plantilla",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -2048,
        -288
      ],
      "id": "1fe6eeb1-9091-405f-8037-0718332a26a0",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "data",
        "binaryPropertyName": "={{ $('Extract from File').item.json.data }}",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -944,
        -304
      ],
      "id": "922f9104-91df-4712-87b8-04aa41eb9548",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ $('Variables1').item.json.subworkflowID }}",
          "mode": "id"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -1296,
        -416
      ],
      "id": "ba2dbe07-ebd6-4f9d-870b-b9d703bccf22",
      "name": "Execute Workflow",
      "alwaysOutputData": true,
      "notesInFlow": false,
      "executeOnce": false,
      "retryOnFail": false
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "useDataOfInput": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1088,
        -304
      ],
      "id": "c624647a-0ad9-4484-84a2-482559fb6177",
      "name": "Merge3"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ $('Variables').item.json.subworkflowID }}",
          "mode": "id",
          "cachedResultUrl": "/workflow/=%7B%7B%20$('Variables').item.json.subworkflowID%20%7D%7D"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -688,
        32
      ],
      "id": "95bb776d-6574-41a0-bf5b-68961e503c59",
      "name": "Execute Workflow1",
      "alwaysOutputData": true,
      "notesInFlow": false,
      "executeOnce": false,
      "retryOnFail": false
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "useDataOfInput": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -448,
        240
      ],
      "id": "fd00ed4a-a5f9-4402-8cf5-fccc98767cee",
      "name": "Merge4"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables1').item.json.convertedFilesDirectory }}\"]\n}",
        "options": {}
      },
      "id": "36d5f8f8-4e2d-442d-9fdf-760d1b72a995",
      "name": "Convert File2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -624,
        -304
      ],
      "credentials": {
        "googleOAuth2Api": {
          "id": "N3sd298xjJQFZGOz",
          "name": "Google account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Clasifica: 'texto' | 'imagen' | 'audio' | 'video' | 'documento'\n// Mantiene SIEMPRE el mismo formato de retorno:\n// { kind, text, media, raw, sender, timestamp }\n\nfunction unwrap(m) {\n  if (!m) return m;\n  if (m.ephemeralMessage?.message) return unwrap(m.ephemeralMessage.message);\n  if (m.viewOnceMessage?.message) return unwrap(m.viewOnceMessage.message);\n  if (m.viewOnceMessageV2?.message) return unwrap(m.viewOnceMessageV2.message);\n  return m;\n}\n\nfunction toNum(x) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction isImageMime(mt) {\n  return typeof mt === \"string\" && mt.toLowerCase().startsWith(\"image/\");\n}\n\nfunction isImageFilename(name) {\n  if (!name) return false;\n  return /\\.(jpe?g|png|webp|gif|bmp|tif?f)$/i.test(String(name));\n}\n\nfunction detectar(body) {\n  const msg = unwrap(body?.message || {});\n  if (!msg) return { kind: \"desconocido\", text: \"\", media: null, raw: body };\n\n  // === AUDIO ===\n  if (msg.audioMessage) {\n    const a = msg.audioMessage;\n    const url = a.url || \"\";\n    return {\n      kind: \"audio\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: a.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: a.mediaKey || null,\n        directPath: a.directPath || null,\n        seconds: typeof a.seconds === \"number\" ? a.seconds : toNum(a.seconds),\n        ptt: Boolean(a.ptt)\n      },\n      raw: body\n    };\n  }\n\n  // === VIDEO ===\n  if (msg.videoMessage) {\n    const v = msg.videoMessage;\n    const url = v.url || \"\";\n    return {\n      kind: \"video\",\n      text: v.caption || \"\",\n      media: {\n        url,\n        mimetype: v.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: v.mediaKey || null,\n        directPath: v.directPath || null,\n        seconds: typeof v.seconds === \"number\" ? v.seconds : toNum(v.seconds),\n        gifPlayback: Boolean(v.gifPlayback)\n      },\n      raw: body\n    };\n  }\n\n  // === STICKER (tratar como IMAGEN) ===\n  if (msg.stickerMessage) {\n    const s = msg.stickerMessage;\n    const url = s.url || \"\";\n    return {\n      kind: \"imagen\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: s.mimetype || \"image/webp\",\n        encrypted: url.includes(\".enc\"),\n        mediaKey: s.mediaKey || null,\n        directPath: s.directPath || null,\n        isSticker: true,\n        isAnimated: Boolean(s.isAnimated)\n      },\n      raw: body\n    };\n  }\n\n  // === IMAGEN ===\n  if (msg.imageMessage) {\n    const i = msg.imageMessage;\n    const url = i.url || \"\";\n    return {\n      kind: \"imagen\",\n      text: i.caption || \"\",\n      media: {\n        url,\n        mimetype: i.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: i.mediaKey || null,\n        directPath: i.directPath || null\n      },\n      raw: body\n    };\n  }\n\n  // === DOCUMENTO (si es imagen -> clasificar como IMAGEN; si no, DOCUMENTO) ===\n  if (msg.documentMessage) {\n    const d = msg.documentMessage;\n    const url = d.url || \"\";\n    const fileName = d.fileName || d.title || null;\n    const mime = d.mimetype || null;\n\n    if (isImageMime(mime) || isImageFilename(fileName)) {\n      // document enviado como imagen -> tratar como imagen\n      return {\n        kind: \"imagen\",\n        text: \"\",\n        media: {\n          url,\n          mimetype: mime || \"image/jpeg\",\n          encrypted: url.includes(\".enc\"),\n          mediaKey: d.mediaKey || null,\n          directPath: d.directPath || null,\n          fromDocument: true,\n          fileName,\n          fileLength: toNum(d.fileLength),\n          fileSha256: d.fileSha256 || null,\n          fileEncSha256: d.fileEncSha256 || null,\n          mediaKeyTimestamp: toNum(d.mediaKeyTimestamp)\n        },\n        raw: body\n      };\n    }\n\n    // documento \"normal\"\n    return {\n      kind: \"documento\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: mime,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: d.mediaKey || null,\n        directPath: d.directPath || null,\n        fileName,\n        fileLength: toNum(d.fileLength),\n        pageCount: toNum(d.pageCount),\n        fileSha256: d.fileSha256 || null,\n        fileEncSha256: d.fileEncSha256 || null,\n        mediaKeyTimestamp: toNum(d.mediaKeyTimestamp),\n        // miniatura (si existe)\n        thumbnail: {\n          jpegThumbnail: d.jpegThumbnail || null,\n          thumbnailDirectPath: d.thumbnailDirectPath || null,\n          thumbnailSha256: d.thumbnailSha256 || null,\n          thumbnailEncSha256: d.thumbnailEncSha256 || null,\n          width: toNum(d.thumbnailWidth),\n          height: toNum(d.thumbnailHeight)\n        }\n      },\n      raw: body\n    };\n  }\n\n  // === TEXTO ===\n  if (msg.conversation || msg.extendedTextMessage?.text) {\n    return {\n      kind: \"texto\",\n      text: msg.conversation || msg.extendedTextMessage?.text || \"\",\n      media: null,\n      raw: body\n    };\n  }\n\n  // Desconocido\n  return { kind: \"desconocido\", text: \"\", media: null, raw: body };\n}\n\nreturn items.map(it => {\n  const body = it.json?.body ?? it.json;\n  const out = detectar(body);\n  const ts = body?.messageTimestamp ? new Date(Number(body.messageTimestamp) * 1000).toISOString() : null;\n\n  return {\n    json: {\n      kind: out.kind,      // 'audio' | 'video' | 'imagen' | 'documento' | 'texto' | 'desconocido'\n      text: out.text,\n      media: out.media,\n      raw: out.raw,\n      sender: {\n        name: body?.pushName || \"\",\n        remoteJid: body?.key?.remoteJid || \"\",\n        fromMe: Boolean(body?.key?.fromMe),\n        id: body?.key?.id || null\n      },\n      timestamp: ts\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2560,
        240
      ],
      "id": "5bdfaf08-e0b8-4cc7-bd7d-364f30095701",
      "name": "Code1"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "d4a09f90-7c99-4ea0-886b-51a8321f90bb",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -2928,
        240
      ],
      "id": "338112bd-25eb-4926-b633-92bb6e6cfba2",
      "name": "Webhook",
      "webhookId": "d4a09f90-7c99-4ea0-886b-51a8321f90bb"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a3e61211-0ab1-47f7-89d7-4dcd56af7e7b",
                    "leftValue": "={{ $json.kind }}",
                    "rightValue": "documento",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Documento"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -1712,
        80
      ],
      "id": "84f071a1-69ef-4263-a965-daf2c892dc4f",
      "name": "Switch"
    },
    {
      "parameters": {
        "method": "POST",
        "url": " https://agileapichat.sidesoftcorp.com/api/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer linea1"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Homologar_msg').item.json.telefono }}"
            },
            {
              "name": "body",
              "value": "=Documento No Soportado"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1408,
        352
      ],
      "id": "57f0bb58-99d4-4343-a433-44d41f557f70",
      "name": "Response"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const body = item.json.body;\n  const msg = body.message || {};\n  const telefono = $input.first().json.body.key.remoteJid.split('@')[0];\n\n  let messageText = \"\";\n\n  // Caso 1: texto plano\n  if (msg.conversation) {\n    messageText = msg.conversation;\n  }\n\n  // Caso 2: texto extendido (con contexto)\n  else if (msg.extendedTextMessage?.text) {\n    messageText = msg.extendedTextMessage.text;\n  }\n\n  // Caso 3: imagen con caption\n  else if (msg.imageMessage?.caption) {\n    messageText = msg.imageMessage.caption;\n  }\n\n  // Caso 4: video con caption\n  else if (msg.videoMessage?.caption) {\n    messageText = msg.videoMessage.caption;\n  }\n\n  // Caso 5: audio/nota de voz (no trae texto, solo informamos)\n  else if (msg.audioMessage) {\n    messageText = \"[Audio recibido]\";\n  }\n\n  // Caso 6: bot√≥n presionado\n  else if (msg.buttonsResponseMessage?.selectedButtonId) {\n    messageText = msg.buttonsResponseMessage.selectedButtonId;\n  }\n\n  // Caso 7: lista seleccionada\n  else if (msg.listResponseMessage?.singleSelectReply?.selectedRowId) {\n    messageText = msg.listResponseMessage.singleSelectReply.selectedRowId;\n  }\n\n  // Caso 8: sticker\n  else if (msg.stickerMessage) {\n    messageText = \"[Sticker recibido]\";\n  }\n\n  // Caso 9: documento\n  else if (msg.documentMessage?.fileName) {\n    messageText = `[Documento: ${msg.documentMessage.fileName}]`;\n  }\n\n  // Si no hay nada reconocible\n  else {\n    messageText = \"[Mensaje no reconocido]\";\n  }\n\n  return {\n    json: {\n      ...item.json,\n      userMessage: messageText,   // üîπ campo unificado para usar en AI Agent\n      telefono\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2736,
        240
      ],
      "id": "ff55383c-e2c6-4f31-a91c-36aafb21c67b",
      "name": "Homologar_msg"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://admchat.duckdns.org/wa-decrypt/decrypt-document",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "mimetype",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.mimetype }}"
            },
            {
              "name": "mediaKey",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.mediaKey }}"
            },
            {
              "name": "fileEncSha256",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.fileEncSha256 }}"
            },
            {
              "name": "mediaKeyTimestamp",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.mediaKeyTimestamp }}"
            },
            {
              "name": "directPath",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.directPath }}"
            },
            {
              "name": "fileSha256",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.fileSha256 }}"
            },
            {
              "name": "filename",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.fileName }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -272,
        240
      ],
      "id": "4cf0371f-0f34-453b-ad3a-4bf455ef5a45",
      "name": "HTTP Request",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables').item.json.convertedFilesDirectory }}\"]\n}",
        "options": {}
      },
      "id": "05e234f5-eb18-4b7d-8233-2e9f107f73c3",
      "name": "Convert File3",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        64,
        240
      ],
      "credentials": {
        "googleOAuth2Api": {
          "id": "N3sd298xjJQFZGOz",
          "name": "Google account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "CxC",
          "mode": "name"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1024,
        48
      ],
      "id": "4e8a792b-f891-4739-b6ba-100eb385a5b6",
      "name": "CxC",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hXtG2Lkk5qYTHIdj",
          "name": "TestSidesoft"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Homologar_msg').item.json.telefono }}"
            },
            {
              "name": "body",
              "value": "=Error al Convertir Media Intente Nuevamente"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        192,
        304
      ],
      "id": "d39e4611-bcbe-4a7b-a5a6-232c4ed7a0e7",
      "name": "Response1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('CargarProductos').item.json['Telefono Celular'] }}"
            },
            {
              "name": "body",
              "value": "=Error al Convertir Media Intente Nuevamente"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -272,
        -128
      ],
      "id": "4dd92d8e-19ec-42e1-9db5-cb08620de8fe",
      "name": "Response2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Homologar_msg').item.json.telefono }}"
            },
            {
              "name": "body",
              "value": "=üëã Hola, inicio la revisi√≥n de la plantilla de CxC, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1392,
        64
      ],
      "id": "75728941-911e-455a-90d5-63fee5547d83",
      "name": "MsgInicial"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('CargarProductos').item.json['Telefono Celular'] }}"
            },
            {
              "name": "body",
              "value": "=üëã Hola, inicio la revisi√≥n de la plantilla de CxC, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1824,
        -288
      ],
      "id": "2334a376-cd8d-4093-a932-795dc0d2cc70",
      "name": "MsgInicial2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables2').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "={{ $('Unificar Errores Productos1').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6016,
        1520
      ],
      "id": "22a59ab9-e1ad-4f5e-94aa-d28979202d29",
      "name": "Confirmacion1",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'AdOrgOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Organizacion'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1904,
        2224
      ],
      "id": "e7b44e00-a434-4ed3-8ed4-82641f9d7c7c",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// Lee todo lo que llega del Merge y decide EXITO / ERROR\nfunction pickMsgs(items) {\n  return items.map(i => String(i.json?.mensaje ?? '').trim()).filter(Boolean);\n}\nfunction hasErr(s) { return /error/i.test(s); }\nfunction bullets(msg) {\n  const m = String(msg).match(/errores?\\s+encontrados:\\s*([\\s\\S]*)/i);\n  const body = (m ? m[1] : msg).replace(/\\r/g, '');\n  const set = new Set(body.split('\\n').map(x => x.trim()).filter(Boolean));\n  return Array.from(set).map(x => x.startsWith('-') ? x : `- ${x}`);\n}\n\nconst msgs = pickMsgs($items('Merge5'));\nconst errs = msgs.filter(hasErr);\n\nlet resultado, mensaje;\nif (errs.length === 0) {\n  resultado = 'EXITO';\n  mensaje = 'CXP - ‚úÖ Todo Correcto';\n} else {\n  const all = errs.flatMap(bullets);\n  resultado = 'ERROR';\n  mensaje = `CXP - üö´ Errores encontrados:\\n${all.join('\\n')}`;\n}\n\nreturn [{ json: { resultado, mensaje, totalMensajes: msgs.length, totalConError: errs.length } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5824,
        1520
      ],
      "id": "c00dec54-e427-41e6-aa42-a13f6e20a1af",
      "name": "Unificar Errores Productos1"
    },
    {
      "parameters": {
        "numberInputs": 10
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5328,
        1088
      ],
      "id": "fe0ed2a2-8cda-4bbc-bd89-ff2cf339c89d",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function Node\n\n// Columnas a verificar duplicados\nconst COLS_DUP = [\"No documento\", \"No referencia\"];\n\n// Columnas de fecha a validar \"aaaa-mm-dd\"\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"];\n\n// Columnas permitidas vac√≠as y columnas a ignorar en validaci√≥n\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);\nconst IGNORE_COLS = new Set([\"row_number\"]);\n\n// Regex de control/saltos de p√°gina y otros controles (excluimos \\n y \\r aqu√≠, los tratamos aparte)\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g; // incluye \\f (\\x0C) y otros controles\nconst PAGE_BREAK_REGEX = /\\f/g; // expl√≠cito\n// Saltos de l√≠nea/enter (incluye CRLF, CR, LF y separadores Unicode de l√≠nea/p√°rrafo)\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;\n\n// Permitidos por car√°cter (ya sin \\n/\\r porque los normalizamos a espacio)\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\n// Validaci√≥n de fecha aaaa-mm-dd + calendario real (bisiestos, etc.)\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\n// Helpers\nconst toRowNum = (row, idx) => {\n  if (row && row.row_number != null) return row.row_number;\n  return (idx + 2);\n};\n\nconst cleanText = (val) => {\n  if (typeof val !== \"string\") return val;\n  let cleaned = val;\n\n  // 1) Normalizar saltos de l√≠nea/enter -> espacio\n  cleaned = cleaned.replace(LINEBREAK_REGEX, \" \");\n\n  // 2) Normalizar saltos de p√°gina/control chars -> espacio\n  cleaned = cleaned.replace(PAGE_BREAK_REGEX, \" \");\n  cleaned = cleaned.replace(CONTROL_CHARS_REGEX, \" \");\n\n  // 3) Trim y colapsar espacios m√∫ltiples\n  cleaned = cleaned.trim().replace(/\\s{2,}/g, \" \");\n  return cleaned;\n};\n\nconst findSpecials = (val) => {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n};\n\n// --- Proceso ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza + caracteres especiales + vac√≠os\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return; // omitir campos meta\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      // Limpieza\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      // Vac√≠o no permitido (excepto columnas permitidas)\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      // Detecci√≥n de caracteres especiales no permitidos post-limpieza\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // No-string: verificar nulos/indefinidos como vac√≠o (0 num√©rico es v√°lido)\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de formato y valor de fechas (aaaa-mm-dd)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // tambi√©n aplica regla de \"no vac√≠o\" para fechas\n      if (!COLS_ALLOW_EMPTY.has(col)) {\n        errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  }\n\n  // Preparar detecci√≥n de duplicados (con valores ya limpios)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// (Opcional) Filas con error ya limpias, por si luego las quieres devolver\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Mensaje final requerido\nconst mensaje = errores.length\n  ? `CXP - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`\n  : 'CXP - ‚úÖ Todo Correcto';\n\nreturn [{\n  json: {\n    mensaje\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1872,
        1680
      ],
      "id": "83829fdf-7b0c-4d98-9722-ede9cf7bd942",
      "name": "InitCleaning1",
      "alwaysOutputData": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from ad_org where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1888,
        1968
      ],
      "id": "eac9b9e7-cfcc-4ea1-a4d1-69ee3550a369",
      "name": "AdOrgOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select documentno from c_invoice where issotrx='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2112,
        1968
      ],
      "id": "b794acef-5d24-4a97-81b4-bd3769b1b9aa",
      "name": "FacturasOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name  from c_doctype  where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2352,
        1968
      ],
      "id": "ce3d0e25-9aab-444d-b531-656a07f5cdde",
      "name": "DoctypeOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';              // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'FacturasOB1'; // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'documentno';               // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['No documento','No referencia'];             // ‚Üê columnas del Sheet a validar contra Postgres\n\nconst NORMALIZAR = true;   // true: sin tildes, MAY√öSCULAS y espacios colapsados\nconst TRIM_EMPTY = true;   // true: ignora vac√≠os\n\n// === Normalizadores ===\nconst cleanDisplay = (s) => {\n  let out = (s ?? '').toString();\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');            // CR/LF/TAB -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // forma can√≥nica\n  return out.trim().replace(/\\s+/g, ' ');\n};\nconst norm = (s) => {\n  let out = cleanDisplay(s);\n  if (TRIM_EMPTY && out === '') return '';\n  if (!NORMALIZAR) return out;\n  return out\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // quitar tildes\n    .toUpperCase();\n};\n\n// === 1) Datasheet (Google Sheets) ===\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `PRODUCTOS - üö´ No hay datos desde el nodo Sheet \"${SHEET_NODE}\"`, totalErrores: 1 } }];\n}\nconst sheetRows = sheetItems.map((it, i) => {\n  const r = it.json || {};\n  const base = { rowNumber: r.row_number ?? (i + 2) }; // encabezado en fila 1\n  for (const col of COLS_VALIDAR) {\n    base[`${col}Raw`]  = cleanDisplay(r[col]);\n    base[`${col}Norm`] = norm(r[col]);\n  }\n  return base;\n});\n\n// === 2) Postgres (UNA sola columna) ===\nconst obRows = ($items(POSTGRES_NODE) || []).map(it => it.json || {});\nconst obSet = new Set(\n  obRows.map(r => norm(r[POSTGRES_FIELD])).filter(v => v !== '')\n);\nif (!obSet.size) {\n  // Si Postgres no devolvi√≥ nada, avisamos (puede ser v√°lido si a√∫n no hay cat√°logo)\n  // pero seguimos retornando \"Todo Correcto\" para no frenar el flujo.\n}\n\n// === 3) Acumular coincidencias (valores del sheet que YA existen en OB) ===\n// Por cada columna del Sheet mantenemos un Map: claveNorm -> { muestra(raw), rows[] }\nconst dupPorColumna = {};\nfor (const col of COLS_VALIDAR) dupPorColumna[col] = new Map();\n\nfor (const r of sheetRows) {\n  for (const col of COLS_VALIDAR) {\n    const valNorm = r[`${col}Norm`];\n    if (!valNorm) continue;\n    if (obSet.has(valNorm)) {\n      const entry = dupPorColumna[col].get(valNorm) || { muestra: r[`${col}Raw`] || '(vac√≠o)', rows: [] };\n      entry.rows.push(r.rowNumber);\n      dupPorColumna[col].set(valNorm, entry);\n    }\n  }\n}\n\n// === 4) Mensajes en el formato solicitado ===\nconst errores = [];\nconst sortByMuestra = (a, b) => a.muestra.localeCompare(b.muestra, 'es', { sensitivity: 'base' });\n\nfor (const col of COLS_VALIDAR) {\n  const valores = [...dupPorColumna[col].values()].sort(sortByMuestra);\n  valores.forEach(e => {\n    e.rows.sort((a, b) => a - b);\n    errores.push(`Duplicado en columna \"${col}\": valor \"${e.muestra}\" en filas ${e.rows.join(', ')}`);\n  });\n}\n\n// === 5) Salida ===\nconst mensaje = errores.length === 0\n  ? `CxP - ‚úÖ Todo Correcto`\n  : `CxP (existentes en OB) - üö´ Error Coincidencias encontradas:\\n- ${errores.join('\\n- ')}`;\n\nreturn [{\n  json: {\n    mensaje,\n    totalErrores: errores.length\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2112,
        2224
      ],
      "id": "28888bbc-ed99-45a8-8ff6-ccc7f2dd984e",
      "name": "FactOB1"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'DoctypeOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2352,
        2224
      ],
      "id": "5ffe307f-76f6-4bb0-93db-f4fa4c65a30c",
      "name": "DtOB1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select taxid from c_bpartner where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2608,
        1968
      ],
      "id": "ea1a8348-0731-4818-8fc4-454ee2edaab6",
      "name": "PartnerOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PartnerOB1';       // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'taxid';      // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Tercero']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// === Sin√≥nimos de columnas a detectar autom√°ticamente en el Sheet ===\nconst SYNONYMS = {\n  'No documento': [\n    /^no\\.?\\s*doc(umento)?$/i,\n    /^n[¬∞¬∫]?\\s*doc(umento)?$/i,\n    /^nro\\.?\\s*doc(umento)?$/i,\n    /^n(u|√∫)mero\\s*de\\s*doc(umento)?$/i,\n    /^documento\\s*n[¬∞¬∫]?$/i,\n    /^doc(umento)?\\s*n[¬∞¬∫]?$/i,\n    /^no\\.?\\s*documento$/i,\n    /^n[¬∞¬∫]?\\s*documento$/i,\n  ],\n  'No referencia': [\n    /^no\\.?\\s*ref(erencia)?$/i,\n    /^n[¬∞¬∫]?\\s*ref(erencia)?$/i,\n    /^nro\\.?\\s*ref(erencia)?$/i,\n    /^n(u|√∫)mero\\s*de\\s*ref(erencia)?$/i,\n    /^referencia\\s*n[¬∞¬∫]?$/i,\n    /^ref\\s*n[¬∞¬∫]?$/i,\n    /^no\\.?\\s*referencia$/i,\n    /^n[¬∞¬∫]?\\s*referencia$/i,\n  ],\n};\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (incluye sin√≥nimos detectados) ---\nfunction resolveSheetCols(allKeys, baseCols, synonymsMap) {\n  const result = new Set();\n\n  // 1) Agregar columnas que coinciden exactamente (case-insensitive)\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    if (keyMap.has(upper)) result.add(keyMap.get(upper));\n  }\n\n  // 2) Buscar sin√≥nimos en las keys\n  for (const target of baseCols) {\n    const regs = synonymsMap[target] || [];\n    for (const k of allKeys) {\n      if (result.has(k)) continue;\n      const header = clean(k);\n      if (regs.some(rx => rx.test(header))) {\n        result.add(k);\n      }\n    }\n  }\n\n  return [...result];\n}\n\n// 1) HOJA: columnas del Sheet (din√°micas con sin√≥nimos) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetCols(allKeys, COLS_VALIDAR, SYNONYMS);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje como pediste)\nreturn [{ json: { mensaje } }];\n\n/** Si quieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2608,
        2224
      ],
      "id": "37701b97-a8cd-484f-ad92-1c0d137fcefd",
      "name": "BPOB1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from m_pricelist where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2848,
        1968
      ],
      "id": "b8baab43-23a1-44aa-862c-8bd58ab12a1f",
      "name": "PriceListOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PriceListOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Lista de precios'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2848,
        2224
      ],
      "id": "955578b5-1154-4ce7-b611-66872cf7ed9e",
      "name": "ValidaPriceList1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select iso_code from c_currency where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3088,
        1968
      ],
      "id": "ad21ee24-8974-4417-9cc6-105b71c6a626",
      "name": "MonedaOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'MonedaOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'iso_code';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Moneda'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3088,
        2224
      ],
      "id": "551834f3-3f6d-4635-8b92-5171b5a9e764",
      "name": "ValidaCurrency1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from fin_paymentmethod where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3328,
        1968
      ],
      "id": "e12dec02-6d30-4ed2-bb29-ae875549d4d5",
      "name": "PaymentMethodOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentMethodOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Forma de pago'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3328,
        2224
      ],
      "id": "86721fe8-a094-49d9-89b1-3bdd97607983",
      "name": "ValidaPaymentMethod1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from c_paymentterm where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3568,
        1968
      ],
      "id": "12628141-5e5c-4667-8afd-dd972f451b53",
      "name": "PaymentTermOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentTermOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Condiciones de pago'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3568,
        2224
      ],
      "id": "bcdacb1f-6de2-47e0-a427-d6a270ec378d",
      "name": "ValidaPaymentTerm1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from m_product where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3792,
        1968
      ],
      "id": "65b8264f-a085-4f96-9f22-4facb604175e",
      "name": "ProductOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'ProductOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Producto'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3792,
        2224
      ],
      "id": "1d5ba9a1-f19e-4bb1-aece-c7394f625d88",
      "name": "ValidaProduct1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select uomsymbol from c_uom where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4016,
        1968
      ],
      "id": "3af55794-3157-4a0f-822b-750c63a75dc5",
      "name": "UnidadOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'UnidadOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'uomsymbol';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Unidad de la orden'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4016,
        2224
      ],
      "id": "1833d744-6d0d-48d3-a199-f225b555403f",
      "name": "ValidaUnidad4"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'TaxOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Impuesto'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4256,
        2224
      ],
      "id": "7d97b080-1e68-43a7-a13b-37c4df010817",
      "name": "ValidaUnidad5"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from c_tax where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4256,
        1968
      ],
      "id": "2d19d22a-5478-4b6d-a0c1-717099bf33f0",
      "name": "TaxOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'CostCenterOB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Centro de costo'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4496,
        2224
      ],
      "id": "49ccbe29-a710-4ad4-820e-db2be76b9e5e",
      "name": "ValidaUnidad6"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxP';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'User1OB1';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Usuario1'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxP - Todo Correcto'\n  : 'CxP - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4736,
        2224
      ],
      "id": "19f4dbfe-c4c9-4ec7-ade5-983355952950",
      "name": "ValidaUnidad7"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from c_costcenter where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4496,
        1968
      ],
      "id": "2d859c00-f097-416a-9a5a-ca040921a037",
      "name": "CostCenterOB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select name from user1 where isactive='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4736,
        1968
      ],
      "id": "d6d246a1-9ab0-4764-a07c-5a9859dffd4c",
      "name": "User1OB1",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "yuQbEbYhio1ra0Ss",
          "name": "GasoManta-CafeMar"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5616,
        1472
      ],
      "id": "a7534c37-fc9c-4306-80d1-78c973608af4",
      "name": "Merge5"
    },
    {
      "parameters": {
        "formTitle": "Saldos Iniciales CxP",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Plantilla",
              "fieldType": "file",
              "multipleFiles": false,
              "acceptFileTypes": ".xlsx",
              "requiredField": true
            },
            {
              "fieldLabel": "Telefono Celular",
              "requiredField": true
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -2272,
        1344
      ],
      "id": "9a2d609b-3974-417a-8cb9-b2e7a2109a1c",
      "name": "CargarProductos1",
      "webhookId": "b219ad9d-8cc9-4982-bbe3-d0d7d178bec5"
    },
    {
      "parameters": {
        "inputDataFieldName": "=data",
        "name": "={{ $('Variables3').item.json.fileName }}",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ $('Variables3').item.json.uploadFilesDirectory }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -800,
        1328
      ],
      "id": "7e37f11e-afab-414b-8490-d78e17d87541",
      "name": "Upload file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2D5m9UCVL0y0GKgC",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "49f12a44-11ae-4849-94b4-4c0b492c3641",
              "name": "uploadFilesDirectory",
              "value": "1hhic6Um17LbZv1B3fCQr27X-SASoagsH",
              "type": "string"
            },
            {
              "id": "ff554178-aa16-4be5-bfb3-9368f7a56607",
              "name": "convertedFilesDirectory",
              "value": "1Ujakb61OzHsUIEXRQtT2oz7LutRh-THi",
              "type": "string"
            },
            {
              "id": "6fb746c8-33c8-48f2-8d85-b2ff886625d5",
              "name": "decryptApi",
              "value": "https://admchat.duckdns.org/wa-decrypt/decrypt-document",
              "type": "string"
            },
            {
              "id": "f197f9b9-0992-47b5-8faf-85fecda67503",
              "name": "fileName",
              "value": "CxP",
              "type": "string"
            },
            {
              "id": "1071c733-64c4-46b4-9933-ad3c843c05fb",
              "name": "subworkflowID",
              "value": "gqt6yXfnufkwZYCz",
              "type": "string"
            },
            {
              "id": "343aeec5-aa95-461c-9272-d17dedf033ca",
              "name": "telefono",
              "value": "={{ $('Homologar_msg').item.json.telefono }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1120,
        656
      ],
      "id": "e752b744-b68e-4c5b-97de-4172bf6b6d62",
      "name": "Variables2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "49f12a44-11ae-4849-94b4-4c0b492c3641",
              "name": "uploadFilesDirectory",
              "value": "1hhic6Um17LbZv1B3fCQr27X-SASoagsH",
              "type": "string"
            },
            {
              "id": "ff554178-aa16-4be5-bfb3-9368f7a56607",
              "name": "convertedFilesDirectory",
              "value": "1Ujakb61OzHsUIEXRQtT2oz7LutRh-THi",
              "type": "string"
            },
            {
              "id": "6fb746c8-33c8-48f2-8d85-b2ff886625d5",
              "name": "decryptApi",
              "value": "https://admchat.duckdns.org/wa-decrypt/decrypt-document",
              "type": "string"
            },
            {
              "id": "e85da8f3-3311-4594-b365-55aadab8176e",
              "name": "fileName",
              "value": "CxP",
              "type": "string"
            },
            {
              "id": "00dbcc54-57ea-4710-9124-a6979416f3cd",
              "name": "subworkflowID",
              "value": "gqt6yXfnufkwZYCz",
              "type": "string"
            },
            {
              "id": "293163d2-3cb2-4103-a8de-90080923e03f",
              "name": "telefono",
              "value": "={{ $('CargarProductos1').item.json['Telefono Celular'] }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "stripBinary": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1520,
        1344
      ],
      "id": "a1843f63-b050-4983-b02a-a3025e5a4f0b",
      "name": "Variables3"
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "binaryPropertyName": "Plantilla",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -2064,
        1344
      ],
      "id": "e0381771-51ce-466f-aa22-0e108c6bb495",
      "name": "Extract from File1"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -960,
        1328
      ],
      "id": "dd79ec63-4dc0-4f4b-8d44-ad4e9b2b50f7",
      "name": "Convert to File1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ $('Variables3').item.json.subworkflowID }}",
          "mode": "id"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -1312,
        1216
      ],
      "id": "03941afd-3394-4156-ba5f-f2bddeb84bf2",
      "name": "Execute Workflow2",
      "alwaysOutputData": true,
      "notesInFlow": false,
      "executeOnce": false,
      "retryOnFail": false
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "useDataOfInput": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1104,
        1328
      ],
      "id": "2401f445-1456-4887-9c30-c036cf26eb7c",
      "name": "Merge6"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ $('Variables2').item.json.subworkflowID }}",
          "mode": "id"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -1008,
        1760
      ],
      "id": "832a20db-644e-46c2-b46f-4bf36ded099a",
      "name": "Execute Workflow3",
      "alwaysOutputData": true,
      "notesInFlow": false,
      "executeOnce": false,
      "retryOnFail": false
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "useDataOfInput": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -800,
        1856
      ],
      "id": "bd3d89e1-8004-4a68-a607-46fa8fd83d6b",
      "name": "Merge7"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables3').item.json.convertedFilesDirectory }}\"]\n}",
        "options": {}
      },
      "id": "0bb8d6ba-fdc7-4533-a13b-be7b9a95a2ee",
      "name": "Convert File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -640,
        1328
      ],
      "credentials": {
        "googleOAuth2Api": {
          "id": "N3sd298xjJQFZGOz",
          "name": "Google account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a3e61211-0ab1-47f7-89d7-4dcd56af7e7b",
                    "leftValue": "={{ $json.kind }}",
                    "rightValue": "documento",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Documento"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -1680,
        672
      ],
      "id": "ff273635-f611-48d3-a417-3ad89fe08802",
      "name": "Switch1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": " https://agileapichat.sidesoftcorp.com/api/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer linea1"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Homologar_msg').item.json.telefono }}"
            },
            {
              "name": "body",
              "value": "=Documento No Soportado"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        864
      ],
      "id": "664cf12c-21eb-41ab-8fe8-2a0dab9f8058",
      "name": "Response3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://admchat.duckdns.org/wa-decrypt/decrypt-document",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "mimetype",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.mimetype }}"
            },
            {
              "name": "mediaKey",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.mediaKey }}"
            },
            {
              "name": "fileEncSha256",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.fileEncSha256 }}"
            },
            {
              "name": "mediaKeyTimestamp",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.mediaKeyTimestamp }}"
            },
            {
              "name": "directPath",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.directPath }}"
            },
            {
              "name": "fileSha256",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.fileSha256 }}"
            },
            {
              "name": "filename",
              "value": "={{ $('Code1').item.json.raw.message.documentMessage.fileName }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -624,
        1856
      ],
      "id": "d904f58f-a391-4aa8-97ba-e197dc936aad",
      "name": "HTTP Request1"
    },
    {
      "parameters": {
        "name": "={{ $('Variables2').item.json.fileName }}",
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ $('Variables2').item.json.uploadFilesDirectory }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -448,
        1856
      ],
      "id": "aa5bad5e-f6cd-4cfc-8a69-db9e4a1d2208",
      "name": "Upload file3",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2D5m9UCVL0y0GKgC",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables2').item.json.convertedFilesDirectory }}\"]\n}",
        "options": {}
      },
      "id": "d0bfcfe9-0be7-4d68-9da8-b8f3b6ac1db2",
      "name": "Convert File4",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -288,
        1856
      ],
      "credentials": {
        "googleOAuth2Api": {
          "id": "N3sd298xjJQFZGOz",
          "name": "Google account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Homologar_msg').item.json.telefono }}"
            },
            {
              "name": "body",
              "value": "=Error al Convertir Media Intente Nuevamente"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        384,
        1936
      ],
      "id": "a4a1c74e-fff5-4dea-a81e-2c504ede2559",
      "name": "Response4"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('CargarProductos1').item.json['Telefono Celular'] }}"
            },
            {
              "name": "body",
              "value": "=Error al Convertir Media Intente Nuevamente"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -288,
        1504
      ],
      "id": "912c3e70-8e9b-48ed-a98f-a18830b80367",
      "name": "Response5"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Homologar_msg').item.json.telefono }}"
            },
            {
              "name": "body",
              "value": "=üëã Hola, inicio la revisi√≥n de la plantilla de CxP, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1360,
        656
      ],
      "id": "4ea138df-4ec3-4706-8e64-560e1aeaed19",
      "name": "MsgInicial1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('CargarProductos1').item.json['Telefono Celular'] }}"
            },
            {
              "name": "body",
              "value": "=üëã Hola, inicio la revisi√≥n de la plantilla de CxP, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1840,
        1344
      ],
      "id": "7b181c86-97f1-4dc0-bc99-5f3e8f53cbb5",
      "name": "MsgInicial3"
    },
    {
      "parameters": {
        "jsCode": "// Usa el fileName que viene del mensaje de WhatsApp\nconst fileName = String(\n  $json.raw?.message?.documentMessage?.fileName || ''\n);\nconst ext = (fileName.split('.').pop() || '').toLowerCase();\nconst mime = String($json.raw?.message?.documentMessage?.mimetype || '');\n\nlet tipo = '';\nif (/cxp/i.test(fileName)) tipo = 'CXP';\nelse if (/cxc/i.test(fileName)) tipo = 'CXC';\nelse if (ext === 'xlsx') tipo = 'XLSX';\nelse if (ext === 'csv') tipo = 'CSV';\nelse tipo = 'OTRO';\n\nreturn [{\n  json: {\n    ...$json,\n    archivo_nombre: fileName,\n    archivo_ext: ext,\n    archivo_mime: mime,\n    tipo_archivo: tipo\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2384,
        240
      ],
      "id": "92723878-144b-44ef-874c-66c8797d9560",
      "name": "Code4"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.tipo_archivo }}",
                    "rightValue": "CXC",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "6e25b731-2119-4768-809c-4bb015a029ad"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CXC"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ebc92a7b-9b91-415d-bcab-25f281a9850d",
                    "leftValue": "={{ $json.tipo_archivo }}",
                    "rightValue": "CXP",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CXP"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -2176,
        240
      ],
      "id": "a999f053-2fce-4ab9-abbb-289517556c0f",
      "name": "Switch2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0ff4cbdf-2dbe-4a3d-953e-bed14de88ccc",
              "name": "carga",
              "value": "N",
              "type": "string"
            },
            {
              "id": "840c1449-634a-4076-802a-71440699945f",
              "name": "issotxx",
              "value": "N",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6544,
        -176
      ],
      "id": "12e53688-e839-4624-8ae5-129f3debbc73",
      "name": "Cargar?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0598b900-622b-439c-acfa-ffb199e6cc09",
              "leftValue": "={{ $('Cargar?').item.json.carga }}",
              "rightValue": "Y",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6752,
        -176
      ],
      "id": "fc2a096f-6efb-43dd-9e4e-ce6a6fc67b4f",
      "name": "IfCargarCxC"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{$('Convert File3').first().json.id}}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "CxC",
          "mode": "name"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        7328,
        -320
      ],
      "id": "9a9fec9a-5879-4d04-94ca-e3c29b8aa2d8",
      "name": "CxCCarga",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hXtG2Lkk5qYTHIdj",
          "name": "TestSidesoft"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Function Node\n\n// --- Par√°metros de validaci√≥n ---\nconst COLS_DUP = [\"No documento\", \"No referencia\"];           // columnas a chequear duplicados\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"]; // fechas YMD requeridas\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);            // columnas que s√≠ pueden venir vac√≠as\nconst IGNORE_COLS = new Set([\"row_number\"]);                  // columnas que se ignoran en validaci√≥n y/o se eliminan al salir\n\n// --- Expresiones utilitarias ---\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g;  // controles (excepto \\n/\\r)\nconst PAGE_BREAK_REGEX = /\\f/g;                                    // salto de p√°gina\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;               // saltos de l√≠nea\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\nconst toRowNum = (row, idx) => row?.row_number != null ? row.row_number : (idx + 2);\n\n// Solo recorta bordes; NO colapsa espacios internos\nfunction cleanText(val) {\n  if (typeof val !== \"string\") return val;\n  return val\n    .replace(LINEBREAK_REGEX, \" \")    // saltos de l√≠nea -> espacio\n    .replace(PAGE_BREAK_REGEX, \" \")   // salto de p√°gina -> espacio\n    .replace(CONTROL_CHARS_REGEX, \" \")// otros controles -> espacio\n    .trim();                          // recorta SOLO al inicio/fin\n}\n\nfunction findSpecials(val) {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n}\n\n// --- Proceso principal ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza/normalizaci√≥n campo a campo\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return;\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de fechas YMD (permitimos espacios en bordes)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else if (!COLS_ALLOW_EMPTY.has(col)) {\n      errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n      rowsWithIssues.add(rowNum);\n    }\n  }\n\n  // Duplicados (solo recorte de bordes en la clave)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// Filas con error (ya limpias)\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Salida con errores\nif (errores.length > 0) {\n  const mensaje = `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`;\n  return [{\n    json: {\n      ok: false,\n      mensaje,\n      errores,\n      filasConError\n    }\n  }];\n}\n\n// Salida correcta: items limpios (sin IGNORE_COLS)\nconst salidaLimpia = cleanedItems.map(ci => {\n  const out = { ...ci.row };\n  for (const k of IGNORE_COLS) {\n    if (k in out) delete out[k];\n  }\n  return { json: out };\n});\n\nif (salidaLimpia.length === 0) {\n  return [{ json: { ok: true, mensaje: 'CXC - ‚úÖ Todo Correcto (sin filas)', rows: 0 } }];\n}\n\nreturn salidaLimpia;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7520,
        -320
      ],
      "id": "98d8f509-d901-472b-a59e-066e067be587",
      "name": "InitCleaningCarga",
      "alwaysOutputData": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select ad_client_id from ad_client where ad_client_id not in ('0') ",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        6960,
        -320
      ],
      "id": "e2e8eb9b-2579-4b47-b60f-0d04dd2765e4",
      "name": "ADClient",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select ad_org_id from ad_org where ad_org_id='0'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        7136,
        -320
      ],
      "id": "0f955ee9-6553-4bae-ac4b-a1fab2ccc28a",
      "name": "ADOrg",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{$json.sql_cabecera}}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        7888,
        -320
      ],
      "id": "78c16f85-8b54-46a1-ac8b-5480cae1d3fa",
      "name": "InsertCabecera",
      "retryOnFail": false,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "nPk4aB6nOLV1cRfH",
          "name": "Postgres account 4"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        6960,
        -80
      ],
      "id": "5eb526ac-a410-4ef7-a18b-0cc17ac10c1b",
      "name": "No Operation, do nothing1"
    },
    {
      "parameters": {
        "content": "##**Cargamos la Data?** \n**Cargar** \n**Isso TRX** ",
        "height": 624
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        6480,
        -416
      ],
      "id": "4d963820-3f16-4e3c-8f18-5fee5de039da",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node: CrearSQLCabecera\n// Mode: Run Once for Each Item\n\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Datos de soporte desde ADClient (un √∫nico registro) ===\nconst adClient = $items(\"ADClient\", 0, 0)[0]?.json;\nconst adClientId = adClient?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n\n// === Fila actual (ya limpia) ===\nconst row = $json;\n\n// Si no tienes row_number de Sheets, usa √≠ndice + 2 (cabecera = fila 1)\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Metadatos √∫tiles para logs\nconst _doc = row['No documento'];\nconst _ref = row['No referencia'];\n\n// === Construir SQL de CABECERA (multi-l√≠nea) ===\nlet sql = `\nINSERT INTO c_invoice(\n  c_invoice_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  issotrx, documentno, docstatus, docaction, processing, processed, posted,\n  c_doctype_id, c_doctypetarget_id, c_order_id, description, isprinted, salesrep_id,\n  dateinvoiced, dateprinted, dateacct, c_bpartner_id, c_bpartner_location_id,\n  poreference, isdiscountprinted, dateordered, c_currency_id, paymentrule, c_paymentterm_id,\n  c_charge_id, chargeamt, m_pricelist_id, istaxincluded, c_campaign_id, c_project_id,\n  c_activity_id, createfrom, generateto, ad_user_id, copyfrom, isselfservice, ad_orgtrx_id,\n  user2_id, withholdingamount, taxdate, c_withholding_id, fin_paymentmethod_id, c_costcenter_id,\n  user1_id\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(), '100', now(), '100',\n  'Y',\n  ${sqlSafe(row['No documento'])},\n  'DR','CO','N','N','N',\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  NULL,\n  ${sqlSafe(row['Descripcion'])},\n  'N',\n  NULL,\n  to_date(${sqlSafe(row['Fecha de la factura'])}, 'yyyy-mm-dd'),\n  NULL,\n  to_date(${sqlSafe(row['Fecha contable'])}, 'yyyy-mm-dd'),\n  (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])}),\n  (SELECT c_bpartner_location_id\n     FROM c_bpartner_location\n    WHERE c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND isbillto = 'Y'\n    LIMIT 1),\n  ${sqlSafe(row['No referencia'])},\n  'Y',\n  NULL,\n  (select c_currency_id from c_currency where iso_code = ${sqlSafe(row['Moneda'])}),\n  '2',\n  (select c_paymentterm_id from c_paymentterm where name = ${sqlSafe(row['Condiciones de pago'])}),\n  NULL,\n  NULL,\n  (select m_pricelist_id from m_pricelist where name = ${sqlSafe(row['Lista de precios'])}),\n  'N',\n  NULL, NULL, NULL,\n  'N','N',\n  NULL,\n  'N','N',\n  NULL,\n  NULL,\n  0,\n  to_date(${sqlSafe(row['Fecha impuesto'])}, 'yyyy-mm-dd'),\n  NULL,\n  (SELECT fin_paymentmethod_id FROM fin_paymentmethod WHERE name = ${sqlSafe(row['Forma de pago'])}),\n  (SELECT c_costcenter_id FROM c_costcenter WHERE name = ${sqlSafe(row['Centro de costo'])}),\n  (SELECT user1_id FROM user1 WHERE name = ${sqlSafe(row['Usuario1'])})\n);\n`.trim();\n\n// === Normalizaci√≥n m√≠nima ===\n// Quitar saltos de l√≠nea y tabs para que el Postgres node reciba una sola l√≠nea,\n// pero SIN colapsar espacios internos.\nsql = sql\n  .replace(/\\r?\\n|\\r/g, ' ')\n  .replace(/\\t/g, ' ')\n  .trim();\n\n// >>> DEVOLVER UN SOLO OBJETO (no array) <<<\nreturn {\n  json: {\n    ...row,\n    _rowNum,\n    _doc,\n    _ref,\n    sql_cabecera: sql\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7712,
        -320
      ],
      "id": "16c0c8a8-f58a-4d36-a826-89a34a1a3d58",
      "name": "CrearSQLCabecera"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "45850144-ae70-437c-bf45-523fa1499141",
              "leftValue": "={{ !!$json.error }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        8080,
        -320
      ],
      "id": "86002052-6174-4d29-b5c8-da37d63e6016",
      "name": "If"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code: BuildSQLLinea  (NO colapsa espacios internos)\n\n// Escapa solo comillas simples; NO hace trim ni colapsa espacios del valor\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Meta com√∫n tomada de otros nodos ===\n// ADClient ‚Üí toma el id del nodo Postgres \"ADClient\"\nconst adClientItems = $items(\"ADClient\", 0, 0);\nconst adClientId = adClientItems[0]?.json?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n\n// === Meta de la l√≠nea actual ===\nconst row = $json;\n\n// Si tu Function previo no preserva row_number de Sheets,\n// usa √≠ndice + 2 (para contar encabezado):\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Guarda metadatos √∫tiles para depuraci√≥n:\n$json._rowNum = _rowNum;\n$json._doc    = row['No documento'];   // para relacionar con cabecera\n$json._line   = row['Linea'];          // nro de l√≠nea (si existe)\n$json._prod   = row['Producto'];       // id/nombre producto (si existe)\n\n// === Construye el SQL de la l√≠nea ===\n// (Dejamos el SQL con saltos de l√≠nea para legibilidad; no colapsamos espacios)\nconst sql = `\nINSERT INTO c_invoiceline(\n  c_invoiceline_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  c_invoice_id, c_orderline_id, m_inoutline_id, line, description, m_product_id,\n  qtyinvoiced, pricelist, priceactual, pricelimit, linenetamt,\n  c_charge_id, chargeamt, c_uom_id, c_tax_id, s_resourceassignment_id, taxamt,\n  m_attributesetinstance_id, isdescription, quantityorder, m_product_uom_id,\n  c_invoice_discount_id, c_projectline_id, m_offer_id, pricestd, excludeforwithholding\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(),'100', now(),'100',\n  (SELECT c_invoice_id\n     FROM c_invoice\n    WHERE documentno = ${sqlSafe(row['No documento'])}\n      AND c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND issotrx = 'Y'),\n  NULL, NULL,\n  ${row['Linea'] ? sqlSafe(row['Linea']) : '10'},\n  ${sqlSafe(row['Descripcion'])},\n  sswh_m_product_get(${sqlSafe(row['Producto'])}),\n  ${sqlSafe(row['Cnt.'])},\n  0,\n  to_number(${sqlSafe(row['Precio unitario'])}),\n  0,\n  to_number(${sqlSafe(row['Total'])}),\n  NULL, 0,\n  (SELECT c_uom_id FROM c_uom WHERE uomsymbol = ${sqlSafe(row['Unidad de la orden'])}),\n  (SELECT c_tax_id FROM c_tax WHERE name = ${sqlSafe(row['Impuesto'])}),\n  NULL, NULL, NULL,\n  'N', NULL, NULL, NULL, NULL, NULL,\n  to_number(${sqlSafe(row['Precio unitario'])}),\n  'Y'\n);\n`;\n// Nota: NO usamos .trim() ni reemplazos que cambien espacios internos de los valores\n\n$json.sql_linea = sql;\n\n// En modo \"Run Once for Each Item\" devuelve UN SOLO objeto\nreturn { json: $json };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8832,
        -192
      ],
      "id": "9748832a-d978-4a39-b3de-afa333b23209",
      "name": "CrearSQLLinea"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        6720,
        -576
      ],
      "id": "558f8a14-7548-4a52-88f2-750403765a75",
      "name": "When clicking ‚ÄòExecute workflow‚Äô"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select cb.taxid, cbpl.c_bpartner_location_id\nfrom c_bpartner_location cbpl \njoin c_bpartner cb on cb.c_bpartner_id=cbpl.c_bpartner_id and cbpl.isbillto='Y'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        4800,
        336
      ],
      "id": "b3bcd6ca-1c0c-4e7e-8b61-41b5d08fff27",
      "name": "BPLocationOB",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "c44052ed-6bb8-4a85-ac54-fbf2ecc20b40",
              "leftValue": "={{ $('Unificar Errores Productos').item.json.resultado }}",
              "rightValue": "EXITO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6032,
        -112
      ],
      "id": "95e6b365-9a19-434d-ac09-59a17204c5d1",
      "name": "IfCxCErrGen"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "=üö´ No se puede proceder con la carga de los Saldos Iniciales"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6240,
        16
      ],
      "id": "28ce2bd9-749f-4296-b914-94d6fa7f79bc",
      "name": "BloqueoCxC",
      "executeOnce": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "=üë©‚Äçüíª Iniciando la carga de CxC"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6240,
        -176
      ],
      "id": "baed2baa-4794-4841-849e-bf46f55a0e1e",
      "name": "NotificacionCargaCxC",
      "executeOnce": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "=‚úÖ Cabeceras Cargadas exitosamente"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        8320,
        -192
      ],
      "id": "79f33400-e63c-4987-8564-84ef667f54ab",
      "name": "CabecerasOK",
      "executeOnce": false
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{$('Convert File3').first().json.id}}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "CxC",
          "mode": "name"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        8496,
        -192
      ],
      "id": "cae4c0e6-d581-44a3-9b4c-41638d96daee",
      "name": "CxCCarga1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hXtG2Lkk5qYTHIdj",
          "name": "TestSidesoft"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Function Node\n\n// --- Par√°metros de validaci√≥n ---\nconst COLS_DUP = [\"No documento\", \"No referencia\"];           // columnas a chequear duplicados\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"]; // fechas YMD requeridas\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);            // columnas que s√≠ pueden venir vac√≠as\nconst IGNORE_COLS = new Set([\"row_number\"]);                  // columnas que se ignoran en validaci√≥n y/o se eliminan al salir\n\n// --- Expresiones utilitarias ---\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g;  // controles (excepto \\n/\\r)\nconst PAGE_BREAK_REGEX = /\\f/g;                                    // salto de p√°gina\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;               // saltos de l√≠nea\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\nconst toRowNum = (row, idx) => row?.row_number != null ? row.row_number : (idx + 2);\n\n// Solo recorta bordes; NO colapsa espacios internos\nfunction cleanText(val) {\n  if (typeof val !== \"string\") return val;\n  return val\n    .replace(LINEBREAK_REGEX, \" \")    // saltos de l√≠nea -> espacio\n    .replace(PAGE_BREAK_REGEX, \" \")   // salto de p√°gina -> espacio\n    .replace(CONTROL_CHARS_REGEX, \" \")// otros controles -> espacio\n    .trim();                          // recorta SOLO al inicio/fin\n}\n\nfunction findSpecials(val) {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n}\n\n// --- Proceso principal ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza/normalizaci√≥n campo a campo\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return;\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de fechas YMD (permitimos espacios en bordes)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else if (!COLS_ALLOW_EMPTY.has(col)) {\n      errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n      rowsWithIssues.add(rowNum);\n    }\n  }\n\n  // Duplicados (solo recorte de bordes en la clave)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// Filas con error (ya limpias)\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Salida con errores\nif (errores.length > 0) {\n  const mensaje = `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`;\n  return [{\n    json: {\n      ok: false,\n      mensaje,\n      errores,\n      filasConError\n    }\n  }];\n}\n\n// Salida correcta: items limpios (sin IGNORE_COLS)\nconst salidaLimpia = cleanedItems.map(ci => {\n  const out = { ...ci.row };\n  for (const k of IGNORE_COLS) {\n    if (k in out) delete out[k];\n  }\n  return { json: out };\n});\n\nif (salidaLimpia.length === 0) {\n  return [{ json: { ok: true, mensaje: 'CXC - ‚úÖ Todo Correcto (sin filas)', rows: 0 } }];\n}\n\nreturn salidaLimpia;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8672,
        -192
      ],
      "id": "f691c959-2b18-4a33-955c-0667b37b8cf7",
      "name": "InitCleaningCarga1",
      "alwaysOutputData": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "45850144-ae70-437c-bf45-523fa1499141",
              "leftValue": "={{ !!$json.error }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        9168,
        -192
      ],
      "id": "d2b14dd6-255e-4650-9e0e-4e20f20f570b",
      "name": "If1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{$json.sql_linea}}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        9008,
        -192
      ],
      "id": "0cb05e95-f194-4124-8859-89bd510f3ef8",
      "name": "InsertLineas1",
      "retryOnFail": false,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zeZbTZ9HenPQQGlt",
          "name": "PMOMaestrosOB"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "=‚úÖ Lineas Cargadas exitosamente"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9424,
        -96
      ],
      "id": "968d57c3-33e3-41ff-9f90-f5ef7ef8b8e2",
      "name": "CabecerasOK1",
      "executeOnce": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "=üö´ Cabeceras Registro no se completo, revise los logs"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        8320,
        -384
      ],
      "id": "88c94660-3d84-4e65-a2a4-6ec37bcfd6d7",
      "name": "BloqueoCxC1",
      "executeOnce": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://agileapichat.sidesoftcorp.com/api/messages/send",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer pmo"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Variables').first().json.telefono }}"
            },
            {
              "name": "body",
              "value": "=üö´ Lineas Registro no se completo, revise los logs"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9424,
        -304
      ],
      "id": "454e7ded-3add-4fe2-9888-e2ab717633cc",
      "name": "BloqueoCxC2",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'TaxOB';            // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Impuesto'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4064,
        592
      ],
      "id": "311fe592-dcbc-4a89-b5de-47d2cc18685a",
      "name": "ValidaTax"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'CostCenterOB';     // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Centro de costo']; // Columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4304,
        592
      ],
      "id": "a3ed6823-202e-41be-8cf2-c37851f3511f",
      "name": "ValidaCosCenter"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'User1OB';          // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Usuario1'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4544,
        592
      ],
      "id": "9489cf5d-744a-42ba-bc14-ac406c58292b",
      "name": "ValidaUser1"
    },
    {
      "parameters": {
        "jsCode": "// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'BPLocationOB';     // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'taxid';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Tercero'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos y SOLO recorta bordes (no toca espacios intermedios)\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* Tercero sin Direccion`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4800,
        592
      ],
      "id": "4273d929-5356-4b22-bcf3-5681bb0fb9ac",
      "name": "ValidaBPLocation"
    },
    {
      "parameters": {
        "content": "## Validacion que no Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)",
        "height": 576,
        "width": 224
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1856,
        208
      ],
      "id": "6fc0c6b9-de21-4ccb-b040-a0ffaac632fd",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "## Validacion que si Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)",
        "height": 576,
        "width": 208,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1648,
        208
      ],
      "id": "095ec304-f989-41bd-911d-14b66b8fb28a",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "## Validacion que si Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)",
        "height": 576,
        "width": 2880,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2080,
        208
      ],
      "id": "1e31dbf0-702e-43e0-9772-0e5082806f07",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d2942958-a1dd-445c-a182-c7ac9bbc9630",
              "leftValue": "={{ $('Code1').item.json.raw.message.documentMessage.title }}",
              "rightValue": "CxC.xlsx",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -912,
        48
      ],
      "id": "4060e7e9-9c36-4c62-b538-6362b4dafb34",
      "name": "If2"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ $('Variables2').item.json.subworkflowID }}",
          "mode": "id",
          "cachedResultUrl": "/workflow/=%7B%7B%20$('Variables2').item.json.subworkflowID%20%7D%7D"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -784,
        624
      ],
      "id": "a5a23d71-deae-4c5e-97cd-dbc1bd31d763",
      "name": "Execute Workflow4",
      "alwaysOutputData": true,
      "notesInFlow": false,
      "executeOnce": false,
      "retryOnFail": false
    },
    {
      "parameters": {
        "name": "={{ $('Variables').item.json.fileName }}",
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ \n  ($(\"Variables\").isExecuted && $(\"Variables\").item.json.uploadFilesDirectory && $(\"Variables\").item.json.uploadFilesDirectory !== \"\")\n    ? $(\"Variables\").item.json.uploadFilesDirectory \n    : $(\"Variables2\").item.json.uploadFilesDirectory\n}}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -112,
        240
      ],
      "id": "05ff5655-4cc2-4030-ace2-cff4262291b1",
      "name": "Upload file2",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2D5m9UCVL0y0GKgC",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "896bb862-4991-4de3-8964-c0f3cda61ac9",
              "leftValue": "={{ $('Code1').item.json.raw.message.documentMessage.title }}",
              "rightValue": "CxC.xlsx",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        416,
        144
      ],
      "id": "1791b258-a0e2-4d8b-bdcd-14d7c557d67a",
      "name": "If3"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "CxP",
          "mode": "name"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1216,
        1680
      ],
      "id": "1b783d11-a7b8-493d-8305-1122e9a3f0f6",
      "name": "CxPback",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hXtG2Lkk5qYTHIdj",
          "name": "TestSidesoft"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "CxP",
          "mode": "name"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        816,
        432
      ],
      "id": "7b801d31-9cd3-42bf-8a7e-3d1a9a8bea6b",
      "name": "CxP",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hXtG2Lkk5qYTHIdj",
          "name": "TestSidesoft"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Code3": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "FacturasOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unificar Errores Productos": {
      "main": [
        [
          {
            "node": "Confirmacion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "InitCleaning": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AdOrgOB": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FacturasOB": {
      "main": [
        [
          {
            "node": "FactOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DoctypeOB": {
      "main": [
        [
          {
            "node": "DtOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FactOB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          },
          {
            "node": "DoctypeOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DtOB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          },
          {
            "node": "PartnerOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PartnerOB": {
      "main": [
        [
          {
            "node": "BPOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BPOB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          },
          {
            "node": "PriceListOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PriceListOB": {
      "main": [
        [
          {
            "node": "ValidaPriceList",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaPriceList": {
      "main": [
        [
          {
            "node": "MonedaOB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "MonedaOB": {
      "main": [
        [
          {
            "node": "ValidaCurrency",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PaymentMethodOB": {
      "main": [
        [
          {
            "node": "ValidaPaymentMethod",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaPaymentMethod": {
      "main": [
        [
          {
            "node": "PaymentTermOB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "PaymentTermOB": {
      "main": [
        [
          {
            "node": "ValidaPaymentTerm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaCurrency": {
      "main": [
        [
          {
            "node": "PaymentMethodOB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "ValidaPaymentTerm": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 7
          },
          {
            "node": "ProductOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ProductOB": {
      "main": [
        [
          {
            "node": "ValidaProduct",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaProduct": {
      "main": [
        [
          {
            "node": "UnidadOB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 8
          }
        ]
      ]
    },
    "UnidadOB": {
      "main": [
        [
          {
            "node": "ValidaUnidad",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaUnidad": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 9
          },
          {
            "node": "TaxOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TaxOB": {
      "main": [
        [
          {
            "node": "ValidaTax",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CostCenterOB": {
      "main": [
        [
          {
            "node": "ValidaCosCenter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "User1OB": {
      "main": [
        [
          {
            "node": "ValidaUser1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Unificar Errores Productos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CargarProductos": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file1": {
      "main": [
        [
          {
            "node": "Convert File2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Variables": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Variables1": {
      "main": [
        [
          {
            "node": "Execute Workflow",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "MsgInicial2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "Upload file1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow1": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert File2": {
      "main": [
        [
          {
            "node": "CxC",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Homologar_msg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "MsgInicial",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Homologar_msg": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Upload file2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert File3": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CxC": {
      "main": [
        [
          {
            "node": "InitCleaning",
            "type": "main",
            "index": 0
          },
          {
            "node": "AdOrgOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MsgInicial": {
      "main": [
        [
          {
            "node": "Variables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MsgInicial2": {
      "main": [
        [
          {
            "node": "Variables1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          },
          {
            "node": "FacturasOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unificar Errores Productos1": {
      "main": [
        [
          {
            "node": "Confirmacion1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "InitCleaning1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AdOrgOB1": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FacturasOB1": {
      "main": [
        [
          {
            "node": "FactOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DoctypeOB1": {
      "main": [
        [
          {
            "node": "DtOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FactOB1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 2
          },
          {
            "node": "DoctypeOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DtOB1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 3
          },
          {
            "node": "PartnerOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PartnerOB1": {
      "main": [
        [
          {
            "node": "BPOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BPOB1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 4
          },
          {
            "node": "PriceListOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PriceListOB1": {
      "main": [
        [
          {
            "node": "ValidaPriceList1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaPriceList1": {
      "main": [
        [
          {
            "node": "MonedaOB1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "MonedaOB1": {
      "main": [
        [
          {
            "node": "ValidaCurrency1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaCurrency1": {
      "main": [
        [
          {
            "node": "PaymentMethodOB1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "PaymentMethodOB1": {
      "main": [
        [
          {
            "node": "ValidaPaymentMethod1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaPaymentMethod1": {
      "main": [
        [
          {
            "node": "PaymentTermOB1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "PaymentTermOB1": {
      "main": [
        [
          {
            "node": "ValidaPaymentTerm1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaPaymentTerm1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 7
          },
          {
            "node": "ProductOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ProductOB1": {
      "main": [
        [
          {
            "node": "ValidaProduct1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaProduct1": {
      "main": [
        [
          {
            "node": "UnidadOB1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 8
          }
        ]
      ]
    },
    "UnidadOB1": {
      "main": [
        [
          {
            "node": "ValidaUnidad4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaUnidad4": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 9
          },
          {
            "node": "TaxOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaUnidad5": {
      "main": [
        [
          {
            "node": "CostCenterOB1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TaxOB1": {
      "main": [
        [
          {
            "node": "ValidaUnidad5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaUnidad6": {
      "main": [
        [
          {
            "node": "User1OB1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "ValidaUnidad7": {
      "main": [
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "CostCenterOB1": {
      "main": [
        [
          {
            "node": "ValidaUnidad6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "User1OB1": {
      "main": [
        [
          {
            "node": "ValidaUnidad7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge5": {
      "main": [
        [
          {
            "node": "Unificar Errores Productos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CargarProductos1": {
      "main": [
        [
          {
            "node": "Extract from File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file": {
      "main": [
        [
          {
            "node": "Convert File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Variables2": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Variables3": {
      "main": [
        [
          {
            "node": "Execute Workflow2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge6",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Extract from File1": {
      "main": [
        [
          {
            "node": "MsgInicial3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File1": {
      "main": [
        [
          {
            "node": "Upload file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow2": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge6": {
      "main": [
        [
          {
            "node": "Convert to File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow3": {
      "main": [
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge7": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert File": {
      "main": [
        [
          {
            "node": "CxPback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "MsgInicial1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Upload file3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file3": {
      "main": [
        [
          {
            "node": "Convert File4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert File4": {
      "main": [
        [
          {
            "node": "CxPback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MsgInicial1": {
      "main": [
        [
          {
            "node": "Variables2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MsgInicial3": {
      "main": [
        [
          {
            "node": "Variables3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Confirmacion": {
      "main": [
        [
          {
            "node": "IfCxCErrGen",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cargar?": {
      "main": [
        [
          {
            "node": "IfCargarCxC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IfCargarCxC": {
      "main": [
        [
          {
            "node": "ADClient",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation, do nothing1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CxCCarga": {
      "main": [
        [
          {
            "node": "InitCleaningCarga",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ADClient": {
      "main": [
        [
          {
            "node": "ADOrg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InitCleaningCarga": {
      "main": [
        [
          {
            "node": "CrearSQLCabecera",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ADOrg": {
      "main": [
        [
          {
            "node": "CxCCarga",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InsertCabecera": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CrearSQLCabecera": {
      "main": [
        [
          {
            "node": "InsertCabecera",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "BloqueoCxC1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "CabecerasOK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CrearSQLLinea": {
      "main": [
        [
          {
            "node": "InsertLineas1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‚ÄòExecute workflow‚Äô": {
      "main": [
        [
          {
            "node": "ADClient",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BPLocationOB": {
      "main": [
        [
          {
            "node": "ValidaBPLocation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IfCxCErrGen": {
      "main": [
        [
          {
            "node": "NotificacionCargaCxC",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "BloqueoCxC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NotificacionCargaCxC": {
      "main": [
        []
      ]
    },
    "CxCCarga1": {
      "main": [
        [
          {
            "node": "InitCleaningCarga1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CabecerasOK": {
      "main": [
        [
          {
            "node": "CxCCarga1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InitCleaningCarga1": {
      "main": [
        [
          {
            "node": "CrearSQLLinea",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InsertLineas1": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "BloqueoCxC2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "CabecerasOK1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaTax": {
      "main": [
        [
          {
            "node": "CostCenterOB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaCosCenter": {
      "main": [
        [
          {
            "node": "User1OB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "ValidaUser1": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 2
          },
          {
            "node": "BPLocationOB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidaBPLocation": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Execute Workflow1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute Workflow4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow4": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file2": {
      "main": [
        [
          {
            "node": "Convert File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response1": {
      "main": [
        []
      ]
    },
    "CxPback": {
      "main": [
        [
          {
            "node": "InitCleaning1",
            "type": "main",
            "index": 0
          },
          {
            "node": "AdOrgOB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [],
        [
          {
            "node": "CxP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "executionTimeout": -1,
    "availableInMCP": false,
    "errorWorkflow": "wDIfVDMoYUvKr3Ho",
    "timeSavedPerExecution": 7
  },
  "versionId": "cde96118-cde6-410a-bd69-fadf1675d791",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "e92fa3d4418b801b44279868bd8c598710ddc19a0c03b7af42e8819317ec8acc"
  },
  "id": "wDIfVDMoYUvKr3Ho",
  "tags": []
}