{"createdAt":"2025-09-30T15:09:43.511Z","updatedAt":"2025-10-08T20:41:11.000Z","id":"wVlmKsUhHo2xrjG4","name":"MaestrosTerceros","active":false,"isArchived":false,"nodes":[{"parameters":{"documentId":{"__rl":true,"value":"1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE","mode":"list","cachedResultName":"MaestroTerceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit?usp=drivesdk"},"sheetName":{"__rl":true,"value":781572916,"mode":"list","cachedResultName":"Terceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit#gid=781572916"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[816,192],"id":"04a99ded-b817-4402-9a88-521fde2231b1","name":"Terceros","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"/**\n * n8n Code Node - √önica salida\n * - Sin errores: devuelve items normalizados (uno por fila)\n * - Con errores: devuelve un solo item con { reporte: \"TERCEROS- üö´ Errores encontrados:\\n- Fila ...\" }\n * - Duplicados: incluye las filas donde aparece cada valor repetido\n */\n\nconst items = $input.all();\n\nconst mapCols = {\n  \"row_number\": \"row_number\",\n  \"IDENTIFICADOR\": \"identificador\",\n  \"NOMBRE DEL CLIENTE\": \"nombre_cliente\",\n  \"NOMBRE COMERCIAL\": \"nombre_comercial\",\n  \"DESCRIPCION\": \"descripcion\",\n  \"Grupo de Terceros\": \"grupo_terceros\",\n  \"Tipo Doc\": \"tipo_doc\",\n  \"Tipo Doc Numero\": \"tipo_doc_numero\",\n  \"Tipo Contribuyente\": \"tipo_contribuyente\",\n  \"ES EXTRANJERO\": \"es_extranjero\",\n  \"IDIOMA\": \"idioma\",\n  \"Es Cliente\": \"es_cliente\",\n  \"Cliente Metodo de Pago\": \"cliente_metodo_pago\",\n  \"Cliente Condicion de Pago\": \"cliente_condicion_pago\",\n  \"Cliente Lista de Precios\": \"cliente_lista_precios\",\n  \"Facturacion Inmediata\": \"facturacion_inmediata\",\n  \"Zona de Venta\": \"zona_venta\",\n  \"Empleado \": \"es_empleado\",\n  \"Empleado Es Vendedor (Y/N)\": \"empleado_es_vendedor\",\n  \"Empleado Es Operario (Y/N)\": \"empleado_es_operario\",\n  \"Es armador (Y/N)\": \"es_armador\",\n  \"Es charteador (Y/N)\": \"es_charteador\",\n  \"Es Proveedor\": \"es_proveedor\",\n  \"Proveedor Metodo de Pago\": \"proveedor_metodo_pago\",\n  \"Proveedor Condicion de Pago\": \"proveedor_condicion_pago\",\n  \"Provedor Lista de Precios\": \"proveedor_lista_precios\",\n  \"Contacto N/O\": \"contacto_no\",\n  \"Telefono contacto N/O\": \"telefono_contacto_no\",\n  \"Direccion contactoN/O\": \"direccion_contacto_no\",\n  \"Correo Electronico contacto N/O\": \"correo_contacto_no\",\n  \"Direcci√≥n Principal del Cliente o Proveedor\": \"direccion_principal\",\n  \"Distrito: Ciudad\": \"distrito_ciudad\",\n  \"Dep.: Provincia\": \"provincia\",\n  \"Pais (obligatorio): Ecuador\": \"pais\",\n  \"Telefono\": \"telefono\",\n  \"Telefono 2\": \"telefono_2\",\n  \"Direccion es de envio (Y/N)\": \"direccion_es_envio\",\n  \"Direccion es de factura (Y/N)\": \"direccion_es_factura\",\n  \"Facturacion Electronica\": \"facturacion_electronica\",\n  \"Limite de cr√©dedito\": \"limite_credito\",\n  \"Email del cliente\": \"email_cliente\",\n};\n\nconst hasControlChars = (s) => /[\\u0000-\\u001F\\u007F]/.test(s || \"\");\n\n// Si quieres una lista expl√≠cita de permitidos para nombres/direcciones, usa la siguiente y comenta la de ‚Äútodo unicode‚Äù\n// const allowedChars = /^[\\p{L}\\p{N}\\p{Zs}\\.\\,\\-\\/\\#\\&]*$/u;\n\n// Permitir letras/n√∫meros/puntuaci√≥n/s√≠mbolos/espacios (excluye controles)\nconst allowedChars = /^[\\p{L}\\p{N}\\p{P}\\p{S}\\p{Zs}]*$/u;\n\nfunction normalizeValue(v) {\n  if (v === null || v === undefined) return \"\";\n  return String(v).trim();\n}\n\nfunction preview(val, max = 80) {\n  const s = (val ?? \"\").toString();\n  return s.length <= max ? s : s.slice(0, max) + \"‚Ä¶\";\n}\n\nconst maxLen = (val, n) => (val || \"\").length <= n;\n\n// Email simple y robusto (case-insensitive)\nfunction isValidEmail(v) {\n  const s = (v || \"\").trim();\n  if (!s) return true; // vac√≠o NO es error\n  // Patr√≥n razonable para emails comunes\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]{2,}$/i.test(s);\n}\n\n// Solo R,D,P (si viene valor)\nfunction isValidTipoDoc(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return [\"R\", \"D\", \"P\"].includes(s);\n}\n\n// Solo Y/N (si viene valor)\nfunction isYN(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return s === \"Y\" || s === \"N\";\n}\n\n// Reglas del identificador seg√∫n tipo_doc (aplica a IDENTIFICADOR)\nfunction validateIdentificadorByTipoDoc(tipo_doc_numero, tipoDocRaw) {\n  const id = (tipo_doc_numero || \"\").trim();\n  const tipo = (tipoDocRaw || \"\").toUpperCase();\n  if (!tipo || !id) return { ok: true }; // si falta uno, no marcar error por tu regla de blancos\n  if (tipo === \"R\" && id.length !== 13)\n    return { ok: false, msg: \"debe tener exactamente 13 caracteres para tipo_doc = 'R'\" };\n  if (tipo === \"D\" && id.length !== 10)\n    return { ok: false, msg: \"debe tener exactamente 10 caracteres para tipo_doc = 'D'\" };\n  if (tipo === \"P\" && (id.length < 1 || id.length > 32))\n    return { ok: false, msg: \"debe tener entre 1 y 32 caracteres para tipo_doc = 'P'\" };\n  return { ok: true };\n}\n\nconst rows = [];               // { displayRow, sanitized, errs[] }\nconst idIndex = new Map();     // valor -> [idxs]\nconst docNumIndex = new Map(); // valor -> [idxs]\n\n// Campos tipo Y/N que debemos validar (si vienen)\nconst YN_FIELDS = [\n  \"es_extranjero\",\n  \"es_cliente\",\n  \"es_empleado\",\n  \"empleado_es_vendedor\",\n  \"empleado_es_operario\",\n  \"es_armador\",\n  \"es_charteador\",\n  \"es_proveedor\",\n  \"direccion_es_envio\",\n  \"direccion_es_factura\",\n  \"facturacion_electronica\",\n];\n\nitems.forEach((it, idx) => {\n  const src = it.json || it;\n  const sanitized = {};\n  for (const [srcKey, destKey] of Object.entries(mapCols)) {\n    sanitized[destKey] = normalizeValue(src[srcKey]);\n  }\n\n  // Fila visible: usas rn directo (tu snippet actual ya no suma 1)\n  let rn = parseInt(sanitized.row_number || src[\"row_number\"] || \"\");\n  if (!Number.isFinite(rn)) rn = idx;\n  const displayRow = rn;\n\n  const errs = [];\n\n  // --- 1) Validaci√≥n de caracteres (solo si no est√° vac√≠o) ---\n  for (const [srcKey, value] of Object.entries(src)) {\n    const raw = normalizeValue(value);\n    if (!raw) continue; // blancos no generan error\n    if (hasControlChars(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n    if (!allowedChars.test(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n  }\n\n  // --- 2) Longitudes espec√≠ficas ---\n  if (sanitized.nombre_cliente && !maxLen(sanitized.nombre_cliente, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre\" valor ${preview(sanitized.nombre_cliente)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.nombre_comercial && !maxLen(sanitized.nombre_comercial, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre Comercial\" valor ${preview(sanitized.nombre_comercial)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.descripcion && !maxLen(sanitized.descripcion, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Descripcion\" valor ${preview(sanitized.descripcion)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_contacto_no && !maxLen(sanitized.direccion_contacto_no, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion contacto N/O\" valor ${preview(sanitized.direccion_contacto_no)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_principal && !maxLen(sanitized.direccion_principal, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion Principal\" valor ${preview(sanitized.direccion_principal)} supera el tama√±o maximo de 255 caracteres`);\n\n  // --- 3) Reglas de dominio ---\n  // 3.1 Tipo Doc ‚àà {R,D,P}\n  if (sanitized.tipo_doc && !isValidTipoDoc(sanitized.tipo_doc)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc\" valor ${preview(sanitized.tipo_doc)} debe ser R, D o P`);\n  }\n\n  // 3.2 Campos Y/N (si vienen)\n  YN_FIELDS.forEach(k => {\n    const val = sanitized[k];\n    if (val && !isYN(val)) {\n      // obtener etiqueta de columna original (si quieres, puedes mapear a etiquetas ‚Äúbonitas‚Äù)\n      const label = {\n        es_extranjero: 'ES EXTRANJERO',\n        es_cliente: 'Es Cliente',\n        es_empleado: 'Empleado',\n        empleado_es_vendedor: 'Empleado Es Vendedor (Y/N)',\n        empleado_es_operario: 'Empleado Es Operario (Y/N)',\n        es_armador: 'Es armador (Y/N)',\n        es_charteador: 'Es charteador (Y/N)',\n        es_proveedor: 'Es Proveedor',\n        direccion_es_envio: 'Direccion es de envio (Y/N)',\n        direccion_es_factura: 'Direccion es de factura (Y/N)',\n        facturacion_electronica: 'Facturacion Electronica',\n      }[k] || k;\n      errs.push(`- Fila ${displayRow} - Columna \"${label}\" valor ${preview(val)} debe ser Y o N`);\n    }\n  });\n\n  // 3.3 Emails v√°lidos (si vienen)\n  if (sanitized.email_cliente && !isValidEmail(sanitized.email_cliente)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Email del cliente\" valor ${preview(sanitized.email_cliente)} no es un email valido`);\n  }\n  if (sanitized.correo_contacto_no && !isValidEmail(sanitized.correo_contacto_no)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Correo Electronico contacto N/O\" valor ${preview(sanitized.correo_contacto_no)} no es un email valido`);\n  }\n\n  // 3.4 Identificador vs Tipo Doc (longitud segun tipo)\n  const idRule = validateIdentificadorByTipoDoc(sanitized.tipo_doc_numero, sanitized.tipo_doc);\n  if (!idRule.ok) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc Numero\" valor ${preview(sanitized.tipo_doc_numero)} ${idRule.msg}`);\n  }\n\n  // --- 4) Numerificaci√≥n limite_credito (si viene) ---\n  if (sanitized.limite_credito) {\n    const n = Number(sanitized.limite_credito);\n    if (Number.isNaN(n)) {\n      errs.push(`- Fila ${displayRow} - Columna \"Limite de credito\" valor ${preview(sanitized.limite_credito)} no es numerico`);\n    } else {\n      sanitized.limite_credito = String(n);\n    }\n  }\n\n  // --- 5) Recolectar para duplicados (ignora vac√≠os) ---\n \n   if (sanitized.identificador) {\n    const arr = idIndex.get(sanitized.identificador) || [];\n    arr.push(idx);\n    idIndex.set(sanitized.identificador, arr);\n  }\n  if (sanitized.tipo_doc_numero) {\n    const arr = docNumIndex.get(sanitized.tipo_doc_numero) || [];\n    arr.push(idx);\n    docNumIndex.set(sanitized.tipo_doc_numero, arr);\n  }\n\n  rows.push({ displayRow, sanitized, errs });\n});\n\n// --- Duplicados: indicar TODAS las filas donde aparece el valor ---\nfunction annotateDuplicates(indexMap, columnLabel) {\n  for (const [val, idxs] of indexMap.entries()) {\n    if (idxs.length > 1) {\n      const filas = idxs.map(i => rows[i].displayRow).sort((a, b) => a - b);\n      const lista = filas.join(\", \");\n      idxs.forEach(i => {\n        rows[i].errs.push(\n          `- Fila ${rows[i].displayRow} - Columna \"${columnLabel}\" valor ${preview(val)} se encuentra duplicado en las filas ${lista}`\n        );\n      });\n    }\n  }\n}\nannotateDuplicates(idIndex, \"Identificador\");\nannotateDuplicates(docNumIndex, \"Tipo Doc Numero\");\n\n// --- Salida √∫nica ---\nconst anyErrors = rows.some(r => r.errs.length > 0);\nif (anyErrors) {\n  const header = \"TERCEROS- üö´ Errores encontrados:\";\n  const lines = [];\n  rows.forEach(r => { if (r.errs.length) lines.push(...r.errs); });\n  const mensaje = [header, ...lines].join(\"\\n\");\n  return [{ json: { mensaje } }];\n} else {\n  return rows.map(r => ({ json: r.sanitized }));\n}\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1024,192],"id":"0a0db892-90ca-4424-9c25-a7cfa91b7707","name":"Tratamiento Inicial"},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[4384,-368],"id":"efe3e698-a549-4ab4-b30d-58af08f556d9","name":"When clicking ‚ÄòExecute workflow‚Äô"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"53109533-b343-4f92-9c70-4c016d17650f","leftValue":"={{ $json.mensaje }}","rightValue":"","operator":{"type":"string","operation":"exists","singleValue":true}},{"id":"7411d7c2-a59a-4c08-9420-1b81338d573b","leftValue":"","rightValue":"","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[1312,64],"id":"cc74607e-8382-463a-ac2f-8505f8d371de","name":"If"},{"parameters":{"operation":"executeQuery","query":"select name from sswh_taxpayer where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1312,352],"id":"fdafaa73-8d97-4c48-ba4d-a3ea371de378","name":"TaxPayerOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Tipo Contribuyente',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = false;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('TaxPayerOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1328,640],"id":"165cd9bd-50c0-44ca-af8d-cb9f03fc059f","name":"ValidaTaxPayer"},{"parameters":{"operation":"executeQuery","query":"select name from c_bp_group where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1584,352],"id":"054489d7-8694-435c-bf0c-5522817fce12","name":"PartnerGroupOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Grupo de Terceros',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = false;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('PartnerGroupOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1584,640],"id":"7382705f-09be-4743-9aba-e2c7c8472aea","name":"ValidaPartnerGroup"},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'IDIOMA',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = false;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('LanguageOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1856,640],"id":"a4c34637-b9a5-4764-864c-d21eaabee2a7","name":"ValidaLanguage"},{"parameters":{"operation":"executeQuery","query":"select name  from ad_language where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1856,352],"id":"f6cf51b4-e11e-4d50-8886-dea977d16b7a","name":"LanguageOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select name from fin_paymentmethod where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2144,352],"id":"bcf4a58f-116b-401b-8eb3-c216264a10c9","name":"PaymentMethodOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Cliente  Metodo de Pago',\n  'Proveedor Metodo de Pago',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = false;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('PaymentMethodOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2144,640],"id":"626ae8b9-a78d-401f-8537-0d626dbdd230","name":"ValidaPaymentMethod"},{"parameters":{"operation":"executeQuery","query":"select name from c_paymentterm where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2432,352],"id":"dbbe2592-1c5e-4a3f-8855-780ed90f34e4","name":"PaymentTermOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Cliente  Condicion de Pago',\n  'Proveedor  Condicion de Pago',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = false;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('PaymentTermOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2432,640],"id":"91c6ae32-2fc5-4694-b400-474635510c53","name":"ValidaPaymentTerm"},{"parameters":{"operation":"executeQuery","query":"select name from m_pricelist where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2704,352],"id":"19c84a20-09f3-4068-994c-3722173e4740","name":"PriceListOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Cliente Lista de Precios',\n  'Provedor Lista de Precios',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = false;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('PriceListOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2704,640],"id":"adcaf4d7-345f-4246-9e5a-ed9aaad42370","name":"ValidaPriceList"},{"parameters":{"operation":"executeQuery","query":"select name from c_city where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2976,352],"id":"54700354-9731-4aa7-8dce-ca4dbb7e12d4","name":"CityOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Distrito: Ciudad',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = true;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('CityOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2976,640],"id":"d19cf434-dcf7-4ad0-b397-3b400f562da2","name":"ValidaCity"},{"parameters":{"operation":"executeQuery","query":"select name from c_region where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3248,352],"id":"713bb538-de82-42d0-92a0-b4b8200e2161","name":"RegionOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Dep.: Provincia',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = true;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('RegionOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3248,640],"id":"d6a139bc-e456-4c22-9b38-b6f2d96d0653","name":"ValidaRegion"},{"parameters":{"operation":"executeQuery","query":"select name from c_country where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3504,352],"id":"ccd09008-56f8-4e5f-a210-aa80837e34f0","name":"CountryOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// --- Config ---\nconst COLS = [\n  'Pais (obligatorio): Ecuador',\n];\n\n// ¬øDeseas considerar vac√≠o como error?\nconst TREAT_EMPTY_AS_ERROR = false;\n\n// ¬øComparaci√≥n sin may/min√∫sculas?\nconst UPPERCASE_MATCH = true;\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // quita saltos/tabs\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim().replace(/\\s+/g, ' ');             // colapsa espacios\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// 1) HOJA: solo 4 columnas (strings limpios) + _row\nconst hoja = ($items('Terceros') || []).map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna value), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items('CountryOB') || [])\n  .map(it => it?.json?.name ?? it?.json?.name ?? it?.json?.name)\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of COLS) {\n    const val = r[col]; // ya limpio\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue;\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Correcto'\n  : 'TERCEROS - üö´ Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\nreturn [{ json: { mensaje } }];\n\n// 5) Salida √∫nica\n/**\n return [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de cuentas v√°lidas\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n \n}];\n*/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3504,640],"id":"5038ce12-8765-4174-9f79-4dd4dadd8417","name":"ValidaCountry"},{"parameters":{"numberInputs":10},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[4064,-224],"id":"14791449-f420-4c4d-b4a2-48d031c52f48","name":"Merge1"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"=0987525109"},{"name":"body","value":"={{ $('Unificar Errores Terceros').item.json.mensaje }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[4560,144],"id":"2c75f616-6d71-44a1-8f64-8c8f16a6a591","name":"Confirmacion1","executeOnce":false},{"parameters":{"jsCode":"// Lee todo lo que llega del Merge y decide EXITO / ERROR\nfunction pickMsgs(items) {\n  return items.map(i => String(i.json?.mensaje ?? '').trim()).filter(Boolean);\n}\nfunction hasErr(s) { return /error/i.test(s); }\nfunction bullets(msg) {\n  const m = String(msg).match(/errores?\\s+encontrados:\\s*([\\s\\S]*)/i);\n  const body = (m ? m[1] : msg).replace(/\\r/g, '');\n  const set = new Set(body.split('\\n').map(x => x.trim()).filter(Boolean));\n  return Array.from(set).map(x => x.startsWith('-') ? x : `- ${x}`);\n}\n\nconst msgs = pickMsgs($items('Merge1'));\nconst errs = msgs.filter(hasErr);\n\nlet resultado, mensaje;\nif (errs.length === 0) {\n  resultado = 'EXITO';\n  mensaje = 'TERCEROS - ‚úÖ Todo Correcto';\n} else {\n  const all = errs.flatMap(bullets);\n  resultado = 'ERROR';\n  mensaje = `TERCEROS - üö´ Errores encontrados:\\n${all.join('\\n')}`;\n}\n\nreturn [{ json: { resultado, mensaje, totalMensajes: msgs.length, totalConError: errs.length } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4288,-96],"id":"33610197-dd87-4979-a83c-67b085f7c899","name":"Unificar Errores Terceros"},{"parameters":{"operation":"executeQuery","query":"select value,taxid from c_bpartner","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3808,352],"id":"382754d7-4fd0-48c2-a528-e0ad30aa72be","name":"Catalogo de Terceros OB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst NORMALIZAR = true;   // true: sin tildes, MAY√öSCULAS y espacios colapsados\nconst TRIM_EMPTY = true;   // true: ignora vac√≠os\n\n// ‚ö†Ô∏è NOMBRES DE NODOS (ajusta si difieren en tu flujo)\nconst NODO_SHEET = 'Terceros';       // Google Sheets: debe tener columnas 'IDENTIFICADOR' y 'Tipo Doc Numero'\nconst NODO_DB    = 'Catalogo de Terceros OB';    // Postgres: debe devolver columnas 'value' (-> Tipo Doc Numero) y 'taxid' (-> Identificador)\n\n// === Normalizadores ===\nconst cleanDisplay = (s) => {\n  let out = (s ?? '').toString();\n  // espacios no separables / BOM / zero-width\n  out = out.replace(/\\u00A0/g, ' ');\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');\n  // saltos de l√≠nea y tabs a espacio\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');\n  if (out.normalize) out = out.normalize('NFKC');\n  return out.trim().replace(/\\s+/g, ' ');\n};\nconst norm = (s) => {\n  let out = cleanDisplay(s);\n  if (TRIM_EMPTY && out === '') return '';\n  if (!NORMALIZAR) return out;\n  return out\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // sin tildes\n    .toUpperCase();\n};\n\n// === 1) Datos de la Sheet (Google Sheets: nodo 'Terceros') ===\n// Debe traer columnas 'IDENTIFICADOR' y 'Tipo Doc Numero'\nconst sheetRows = ($items(NODO_SHEET) || []).map((it, i) => {\n  const r = it.json || {};\n  const rowNumber = r.row_number ?? (i + 2); // encabezado en fila 1 => datos empiezan en 2\n  const IdentificadorRaw = cleanDisplay(r['IDENTIFICADOR']);\n  const IdentificadorNorm = norm(r['IDENTIFICADOR']);\n  const TipoDocNumeroRaw = cleanDisplay(r['Tipo Doc Numero']);\n  const TipoDocNumeroNorm = norm(r['Tipo Doc Numero']);\n  return {\n    rowNumber,\n    IdentificadorRaw,\n    IdentificadorNorm,\n    TipoDocNumeroRaw,\n    TipoDocNumeroNorm,\n  };\n});\n\n// === 2) Datos existentes en OB (Postgres: nodo 'Terceros OB') ===\n// Query debe traer: SELECT value, taxid FROM <tu_tabla_terceros>;\nconst obRows = ($items(NODO_DB) || []).map(it => it.json || {});\n// En OB: value ‚âà Tipo Doc Numero ; taxid ‚âà Identificador\nconst obValue = new Set(obRows.map(r => norm(r.value)).filter(v => v !== ''));\nconst obTaxId = new Set(obRows.map(r => norm(r.taxid)).filter(v => v !== ''));\n\n// === 3) Detectar coincidencias Sheet vs OB ===\n// Agrupamos por valor normalizado para reportar una sola l√≠nea por valor con todas sus filas\nconst dupIdentificador = new Map(); // key -> { muestra, rows[] }\nconst dupTipoDocNumero = new Map();\n\nfor (const r of sheetRows) {\n  // Identificador ya existe en OB (taxid)\n  if (r.IdentificadorNorm && obTaxId.has(r.IdentificadorNorm)) {\n    const e = dupIdentificador.get(r.IdentificadorNorm) || { muestra: r.IdentificadorRaw || '(vac√≠o)', rows: [] };\n    e.rows.push(r.rowNumber);\n    dupIdentificador.set(r.IdentificadorNorm, e);\n  }\n  // Tipo Doc Numero ya existe en OB (value)\n  if (r.TipoDocNumeroNorm && obValue.has(r.TipoDocNumeroNorm)) {\n    const e = dupTipoDocNumero.get(r.TipoDocNumeroNorm) || { muestra: r.TipoDocNumeroRaw || '(vac√≠o)', rows: [] };\n    e.rows.push(r.rowNumber);\n    dupTipoDocNumero.set(r.TipoDocNumeroNorm, e);\n  }\n}\n\n// === 4) Construir mensajes ===\n// Formato requerido (agrupado):\n// - Duplicado en columna \"Identificador\": valor \"XYZ\" en filas 3, 7 (existe en OB)\nconst errores = [];\nconst sortByMuestra = (a, b) => a.muestra.localeCompare(b.muestra, 'es');\n\n// Identificador\n[...dupIdentificador.values()].sort(sortByMuestra).forEach(e => {\n  e.rows.sort((a, b) => a - b);\n  errores.push(`Duplicado en columna \"Identificador\": valor \"${e.muestra}\" en filas ${e.rows.join(', ')} (existe en OB)`);\n});\n// Tipo Doc Numero\n[...dupTipoDocNumero.values()].sort(sortByMuestra).forEach(e => {\n  e.rows.sort((a, b) => a - b);\n  errores.push(`Duplicado en columna \"Tipo Doc Numero\": valor \"${e.muestra}\" en filas ${e.rows.join(', ')} (existe en OB)`);\n});\n\n// === 5) Salida ===\nconst mensaje = errores.length === 0\n  ? 'TERCEROS - ‚úÖ Todo Corecto'\n  : 'TERCEROS - üö´ Error Ya existe en OB:\\n- ' + errores.join('\\n- ');\n\nreturn [{\n  json: {\n    mensaje,\n    totalErrores: errores.length\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3808,640],"id":"5c2424c1-86dc-4c73-967f-27f98e7f6eae","name":"ValidaYaCreadosOB"},{"parameters":{"operation":"executeQuery","query":"select ad_client_id from ad_client where ad_client_id not in ('0') ","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4688,-96],"id":"47584c11-0f10-4e5a-aad2-1032eec0d330","name":"ADClient","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select ad_org_id from ad_org where ad_org_id='0'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4864,-96],"id":"a2c8b772-1dbd-4554-94e1-bf02080a0caa","name":"ADOrg","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"insert into c_bpartner(c_bpartner_id,ad_client_id, ad_org_id,created, createdby,updated,updatedby,value,name,name2,em_sswh_taxidtype,taxid,em_sswh_taxpayer_id,c_bp_group_id,description,isactive,em_ssfi_foreign,ad_language,   SO_CreditLimit, EM_EEI_Eeioice, EM_EEI_Email,  isemployee , issalesrep ) values(get_uuid(),$1,'{{ $('ADOrg').item.json.ad_org_id }}',now(),'100',now(),'100','{{ $json.identificador }}','{{ $json.nombre_cliente }}','{{ $json.nombre_comercial }}','{{ $json.tipo_doc }}','{{ $json.tipo_doc_numero }}',(select sswh_taxpayer_id from sswh_taxpayer where name='{{ $json.tipo_contribuyente }}'),(select c_bp_group_id from c_bp_group where name ='{{ $json.grupo_terceros }}'),'{{ $json.descripcion }}','Y','{{ $json.es_extranjero }}',(select ad_language from ad_language where name='{{ $json.idioma }}') , {{ $json.limite_credito }} , coalesce(to_char('{{ $json.facturacion_electronica }}'),to_char('N')), '{{ $json.email_cliente }}' , coalesce(to_char('{{ $json.es_empleado }}'),to_char('N')),coalesce(to_char('{{ $json.empleado_es_vendedor }}'),to_char('N')));","options":{"queryReplacement":"={{ $('ADClient').item.json.ad_client_id }}"}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[5504,-96],"id":"4405c190-36d9-4b34-9140-21a3d4e5eb27","name":"InsertPartner","credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"documentId":{"__rl":true,"value":"1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE","mode":"list","cachedResultName":"MaestroTerceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit?usp=drivesdk"},"sheetName":{"__rl":true,"value":781572916,"mode":"list","cachedResultName":"Terceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit#gid=781572916"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[5072,-96],"id":"cc869cc3-48f2-4cf9-a414-cea9fdc5dea7","name":"Terceros1","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"/**\n * n8n Code Node - √önica salida\n * - Sin errores: devuelve items normalizados (uno por fila)\n * - Con errores: devuelve un solo item con { reporte: \"TERCEROS- üö´ Errores encontrados:\\n- Fila ...\" }\n * - Duplicados: incluye las filas donde aparece cada valor repetido\n */\n\nconst items = $input.all();\n\nconst mapCols = {\n  \"row_number\": \"row_number\",\n  \"IDENTIFICADOR\": \"identificador\",\n  \"NOMBRE DEL CLIENTE\": \"nombre_cliente\",\n  \"NOMBRE COMERCIAL\": \"nombre_comercial\",\n  \"DESCRIPCION\": \"descripcion\",\n  \"Grupo de Terceros\": \"grupo_terceros\",\n  \"Tipo Doc\": \"tipo_doc\",\n  \"Tipo Doc Numero\": \"tipo_doc_numero\",\n  \"Tipo Contribuyente\": \"tipo_contribuyente\",\n  \"ES EXTRANJERO\": \"es_extranjero\",\n  \"IDIOMA\": \"idioma\",\n  \"Es Cliente\": \"es_cliente\",\n  \"Cliente Metodo de Pago\": \"cliente_metodo_pago\",\n  \"Cliente Condicion de Pago\": \"cliente_condicion_pago\",\n  \"Cliente Lista de Precios\": \"cliente_lista_precios\",\n  \"Facturacion Inmediata\": \"facturacion_inmediata\",\n  \"Zona de Venta\": \"zona_venta\",\n  \"Empleado \": \"es_empleado\",\n  \"Empleado Es Vendedor (Y/N)\": \"empleado_es_vendedor\",\n  \"Empleado Es Operario (Y/N)\": \"empleado_es_operario\",\n  \"Es armador (Y/N)\": \"es_armador\",\n  \"Es charteador (Y/N)\": \"es_charteador\",\n  \"Es Proveedor\": \"es_proveedor\",\n  \"Proveedor Metodo de Pago\": \"proveedor_metodo_pago\",\n  \"Proveedor Condicion de Pago\": \"proveedor_condicion_pago\",\n  \"Provedor Lista de Precios\": \"proveedor_lista_precios\",\n  \"Contacto N/O\": \"contacto_no\",\n  \"Telefono contacto N/O\": \"telefono_contacto_no\",\n  \"Direccion contactoN/O\": \"direccion_contacto_no\",\n  \"Correo Electronico contacto N/O\": \"correo_contacto_no\",\n  \"Direcci√≥n Principal del Cliente o Proveedor\": \"direccion_principal\",\n  \"Distrito: Ciudad\": \"distrito_ciudad\",\n  \"Dep.: Provincia\": \"provincia\",\n  \"Pais (obligatorio): Ecuador\": \"pais\",\n  \"Telefono\": \"telefono\",\n  \"Telefono 2\": \"telefono_2\",\n  \"Direccion es de envio (Y/N)\": \"direccion_es_envio\",\n  \"Direccion es de factura (Y/N)\": \"direccion_es_factura\",\n  \"Facturacion Electronica\": \"facturacion_electronica\",\n  \"Limite de cr√©dedito\": \"limite_credito\",\n  \"Email del cliente\": \"email_cliente\",\n};\n\nconst hasControlChars = (s) => /[\\u0000-\\u001F\\u007F]/.test(s || \"\");\n\n// Si quieres una lista expl√≠cita de permitidos para nombres/direcciones, usa la siguiente y comenta la de ‚Äútodo unicode‚Äù\n// const allowedChars = /^[\\p{L}\\p{N}\\p{Zs}\\.\\,\\-\\/\\#\\&]*$/u;\n\n// Permitir letras/n√∫meros/puntuaci√≥n/s√≠mbolos/espacios (excluye controles)\nconst allowedChars = /^[\\p{L}\\p{N}\\p{P}\\p{S}\\p{Zs}]*$/u;\n\nfunction normalizeValue(v) {\n  if (v === null || v === undefined) return \"\";\n  return String(v).trim();\n}\n\nfunction preview(val, max = 80) {\n  const s = (val ?? \"\").toString();\n  return s.length <= max ? s : s.slice(0, max) + \"‚Ä¶\";\n}\n\nconst maxLen = (val, n) => (val || \"\").length <= n;\n\n// Email simple y robusto (case-insensitive)\nfunction isValidEmail(v) {\n  const s = (v || \"\").trim();\n  if (!s) return true; // vac√≠o NO es error\n  // Patr√≥n razonable para emails comunes\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]{2,}$/i.test(s);\n}\n\n// Solo R,D,P (si viene valor)\nfunction isValidTipoDoc(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return [\"R\", \"D\", \"P\"].includes(s);\n}\n\n// Solo Y/N (si viene valor)\nfunction isYN(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return s === \"Y\" || s === \"N\";\n}\n\n// Reglas del identificador seg√∫n tipo_doc (aplica a IDENTIFICADOR)\nfunction validateIdentificadorByTipoDoc(tipo_doc_numero, tipoDocRaw) {\n  const id = (tipo_doc_numero || \"\").trim();\n  const tipo = (tipoDocRaw || \"\").toUpperCase();\n  if (!tipo || !id) return { ok: true }; // si falta uno, no marcar error por tu regla de blancos\n  if (tipo === \"R\" && id.length !== 13)\n    return { ok: false, msg: \"debe tener exactamente 13 caracteres para tipo_doc = 'R'\" };\n  if (tipo === \"D\" && id.length !== 10)\n    return { ok: false, msg: \"debe tener exactamente 10 caracteres para tipo_doc = 'D'\" };\n  if (tipo === \"P\" && (id.length < 1 || id.length > 32))\n    return { ok: false, msg: \"debe tener entre 1 y 32 caracteres para tipo_doc = 'P'\" };\n  return { ok: true };\n}\n\nconst rows = [];               // { displayRow, sanitized, errs[] }\nconst idIndex = new Map();     // valor -> [idxs]\nconst docNumIndex = new Map(); // valor -> [idxs]\n\n// Campos tipo Y/N que debemos validar (si vienen)\nconst YN_FIELDS = [\n  \"es_extranjero\",\n  \"es_cliente\",\n  \"es_empleado\",\n  \"empleado_es_vendedor\",\n  \"empleado_es_operario\",\n  \"es_armador\",\n  \"es_charteador\",\n  \"es_proveedor\",\n  \"direccion_es_envio\",\n  \"direccion_es_factura\",\n  \"facturacion_electronica\",\n];\n\nitems.forEach((it, idx) => {\n  const src = it.json || it;\n  const sanitized = {};\n  for (const [srcKey, destKey] of Object.entries(mapCols)) {\n    sanitized[destKey] = normalizeValue(src[srcKey]);\n  }\n\n  // Fila visible: usas rn directo (tu snippet actual ya no suma 1)\n  let rn = parseInt(sanitized.row_number || src[\"row_number\"] || \"\");\n  if (!Number.isFinite(rn)) rn = idx;\n  const displayRow = rn;\n\n  const errs = [];\n\n  // --- 1) Validaci√≥n de caracteres (solo si no est√° vac√≠o) ---\n  for (const [srcKey, value] of Object.entries(src)) {\n    const raw = normalizeValue(value);\n    if (!raw) continue; // blancos no generan error\n    if (hasControlChars(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n    if (!allowedChars.test(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n  }\n\n  // --- 2) Longitudes espec√≠ficas ---\n  if (sanitized.nombre_cliente && !maxLen(sanitized.nombre_cliente, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre\" valor ${preview(sanitized.nombre_cliente)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.nombre_comercial && !maxLen(sanitized.nombre_comercial, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre Comercial\" valor ${preview(sanitized.nombre_comercial)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.descripcion && !maxLen(sanitized.descripcion, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Descripcion\" valor ${preview(sanitized.descripcion)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_contacto_no && !maxLen(sanitized.direccion_contacto_no, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion contacto N/O\" valor ${preview(sanitized.direccion_contacto_no)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_principal && !maxLen(sanitized.direccion_principal, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion Principal\" valor ${preview(sanitized.direccion_principal)} supera el tama√±o maximo de 255 caracteres`);\n\n  // --- 3) Reglas de dominio ---\n  // 3.1 Tipo Doc ‚àà {R,D,P}\n  if (sanitized.tipo_doc && !isValidTipoDoc(sanitized.tipo_doc)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc\" valor ${preview(sanitized.tipo_doc)} debe ser R, D o P`);\n  }\n\n  // 3.2 Campos Y/N (si vienen)\n  YN_FIELDS.forEach(k => {\n    const val = sanitized[k];\n    if (val && !isYN(val)) {\n      // obtener etiqueta de columna original (si quieres, puedes mapear a etiquetas ‚Äúbonitas‚Äù)\n      const label = {\n        es_extranjero: 'ES EXTRANJERO',\n        es_cliente: 'Es Cliente',\n        es_empleado: 'Empleado',\n        empleado_es_vendedor: 'Empleado Es Vendedor (Y/N)',\n        empleado_es_operario: 'Empleado Es Operario (Y/N)',\n        es_armador: 'Es armador (Y/N)',\n        es_charteador: 'Es charteador (Y/N)',\n        es_proveedor: 'Es Proveedor',\n        direccion_es_envio: 'Direccion es de envio (Y/N)',\n        direccion_es_factura: 'Direccion es de factura (Y/N)',\n        facturacion_electronica: 'Facturacion Electronica',\n      }[k] || k;\n      errs.push(`- Fila ${displayRow} - Columna \"${label}\" valor ${preview(val)} debe ser Y o N`);\n    }\n  });\n\n  // 3.3 Emails v√°lidos (si vienen)\n  if (sanitized.email_cliente && !isValidEmail(sanitized.email_cliente)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Email del cliente\" valor ${preview(sanitized.email_cliente)} no es un email valido`);\n  }\n  if (sanitized.correo_contacto_no && !isValidEmail(sanitized.correo_contacto_no)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Correo Electronico contacto N/O\" valor ${preview(sanitized.correo_contacto_no)} no es un email valido`);\n  }\n\n  // 3.4 Identificador vs Tipo Doc (longitud segun tipo)\n  const idRule = validateIdentificadorByTipoDoc(sanitized.tipo_doc_numero, sanitized.tipo_doc);\n  if (!idRule.ok) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc Numero\" valor ${preview(sanitized.tipo_doc_numero)} ${idRule.msg}`);\n  }\n\n  // --- 4) Numerificaci√≥n limite_credito (si viene) ---\n  if (sanitized.limite_credito) {\n    const n = Number(sanitized.limite_credito);\n    if (Number.isNaN(n)) {\n      errs.push(`- Fila ${displayRow} - Columna \"Limite de credito\" valor ${preview(sanitized.limite_credito)} no es numerico`);\n    } else {\n      sanitized.limite_credito = String(n);\n    }\n  }\n\n  // --- 5) Recolectar para duplicados (ignora vac√≠os) ---\n \n   if (sanitized.identificador) {\n    const arr = idIndex.get(sanitized.identificador) || [];\n    arr.push(idx);\n    idIndex.set(sanitized.identificador, arr);\n  }\n  if (sanitized.tipo_doc_numero) {\n    const arr = docNumIndex.get(sanitized.tipo_doc_numero) || [];\n    arr.push(idx);\n    docNumIndex.set(sanitized.tipo_doc_numero, arr);\n  }\n\n  rows.push({ displayRow, sanitized, errs });\n});\n\n// --- Duplicados: indicar TODAS las filas donde aparece el valor ---\nfunction annotateDuplicates(indexMap, columnLabel) {\n  for (const [val, idxs] of indexMap.entries()) {\n    if (idxs.length > 1) {\n      const filas = idxs.map(i => rows[i].displayRow).sort((a, b) => a - b);\n      const lista = filas.join(\", \");\n      idxs.forEach(i => {\n        rows[i].errs.push(\n          `- Fila ${rows[i].displayRow} - Columna \"${columnLabel}\" valor ${preview(val)} se encuentra duplicado en las filas ${lista}`\n        );\n      });\n    }\n  }\n}\nannotateDuplicates(idIndex, \"Identificador\");\nannotateDuplicates(docNumIndex, \"Tipo Doc Numero\");\n\n// --- Salida √∫nica ---\nconst anyErrors = rows.some(r => r.errs.length > 0);\nif (anyErrors) {\n  const header = \"TERCEROS- üö´ Errores encontrados:\";\n  const lines = [];\n  rows.forEach(r => { if (r.errs.length) lines.push(...r.errs); });\n  const mensaje = [header, ...lines].join(\"\\n\");\n  return [{ json: { mensaje } }];\n} else {\n  return rows.map(r => ({ json: r.sanitized }));\n}\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5280,-96],"id":"07058151-1cbe-4800-93fc-d251a568763c","name":"Tratamiento Final","executeOnce":false},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"463485c4-69c9-47a6-aa87-ac51cf48bb60","leftValue":"={{ $('Tratamiento Final1').item.json.es_proveedor }}","rightValue":"Y","operator":{"type":"string","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.2,"position":[6208,-208],"id":"72c86d9a-d0c8-4d10-aa0f-60a906102b77","name":"Proveedores"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"463485c4-69c9-47a6-aa87-ac51cf48bb60","leftValue":"={{ $json.es_cliente }}","rightValue":"Y","operator":{"type":"string","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.2,"position":[6208,32],"id":"ef8e2190-d92c-4a9c-b176-c8ae78af22db","name":"Clientes"},{"parameters":{"documentId":{"__rl":true,"value":"1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE","mode":"list","cachedResultName":"MaestroTerceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit?usp=drivesdk"},"sheetName":{"__rl":true,"value":781572916,"mode":"list","cachedResultName":"Terceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit#gid=781572916"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[5696,-96],"id":"551a708f-48f3-482c-b898-f015711d2930","name":"Terceros2","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"/**\n * n8n Code Node - √önica salida\n * - Sin errores: devuelve items normalizados (uno por fila)\n * - Con errores: devuelve un solo item con { reporte: \"TERCEROS- üö´ Errores encontrados:\\n- Fila ...\" }\n * - Duplicados: incluye las filas donde aparece cada valor repetido\n */\n\nconst items = $input.all();\n\nconst mapCols = {\n  \"row_number\": \"row_number\",\n  \"IDENTIFICADOR\": \"identificador\",\n  \"NOMBRE DEL CLIENTE\": \"nombre_cliente\",\n  \"NOMBRE COMERCIAL\": \"nombre_comercial\",\n  \"DESCRIPCION\": \"descripcion\",\n  \"Grupo de Terceros\": \"grupo_terceros\",\n  \"Tipo Doc\": \"tipo_doc\",\n  \"Tipo Doc Numero\": \"tipo_doc_numero\",\n  \"Tipo Contribuyente\": \"tipo_contribuyente\",\n  \"ES EXTRANJERO\": \"es_extranjero\",\n  \"IDIOMA\": \"idioma\",\n  \"Es Cliente\": \"es_cliente\",\n  \"Cliente Metodo de Pago\": \"cliente_metodo_pago\",\n  \"Cliente Condicion de Pago\": \"cliente_condicion_pago\",\n  \"Cliente Lista de Precios\": \"cliente_lista_precios\",\n  \"Facturacion Inmediata\": \"facturacion_inmediata\",\n  \"Zona de Venta\": \"zona_venta\",\n  \"Empleado \": \"es_empleado\",\n  \"Empleado Es Vendedor (Y/N)\": \"empleado_es_vendedor\",\n  \"Empleado Es Operario (Y/N)\": \"empleado_es_operario\",\n  \"Es armador (Y/N)\": \"es_armador\",\n  \"Es charteador (Y/N)\": \"es_charteador\",\n  \"Es Proveedor\": \"es_proveedor\",\n  \"Proveedor Metodo de Pago\": \"proveedor_metodo_pago\",\n  \"Proveedor Condicion de Pago\": \"proveedor_condicion_pago\",\n  \"Provedor Lista de Precios\": \"proveedor_lista_precios\",\n  \"Contacto N/O\": \"contacto_no\",\n  \"Telefono contacto N/O\": \"telefono_contacto_no\",\n  \"Direccion contactoN/O\": \"direccion_contacto_no\",\n  \"Correo Electronico contacto N/O\": \"correo_contacto_no\",\n  \"Direcci√≥n Principal del Cliente o Proveedor\": \"direccion_principal\",\n  \"Distrito: Ciudad\": \"distrito_ciudad\",\n  \"Dep.: Provincia\": \"provincia\",\n  \"Pais (obligatorio): Ecuador\": \"pais\",\n  \"Telefono\": \"telefono\",\n  \"Telefono 2\": \"telefono_2\",\n  \"Direccion es de envio (Y/N)\": \"direccion_es_envio\",\n  \"Direccion es de factura (Y/N)\": \"direccion_es_factura\",\n  \"Facturacion Electronica\": \"facturacion_electronica\",\n  \"Limite de cr√©dedito\": \"limite_credito\",\n  \"Email del cliente\": \"email_cliente\",\n};\n\nconst hasControlChars = (s) => /[\\u0000-\\u001F\\u007F]/.test(s || \"\");\n\n// Si quieres una lista expl√≠cita de permitidos para nombres/direcciones, usa la siguiente y comenta la de ‚Äútodo unicode‚Äù\n// const allowedChars = /^[\\p{L}\\p{N}\\p{Zs}\\.\\,\\-\\/\\#\\&]*$/u;\n\n// Permitir letras/n√∫meros/puntuaci√≥n/s√≠mbolos/espacios (excluye controles)\nconst allowedChars = /^[\\p{L}\\p{N}\\p{P}\\p{S}\\p{Zs}]*$/u;\n\nfunction normalizeValue(v) {\n  if (v === null || v === undefined) return \"\";\n  return String(v).trim();\n}\n\nfunction preview(val, max = 80) {\n  const s = (val ?? \"\").toString();\n  return s.length <= max ? s : s.slice(0, max) + \"‚Ä¶\";\n}\n\nconst maxLen = (val, n) => (val || \"\").length <= n;\n\n// Email simple y robusto (case-insensitive)\nfunction isValidEmail(v) {\n  const s = (v || \"\").trim();\n  if (!s) return true; // vac√≠o NO es error\n  // Patr√≥n razonable para emails comunes\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]{2,}$/i.test(s);\n}\n\n// Solo R,D,P (si viene valor)\nfunction isValidTipoDoc(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return [\"R\", \"D\", \"P\"].includes(s);\n}\n\n// Solo Y/N (si viene valor)\nfunction isYN(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return s === \"Y\" || s === \"N\";\n}\n\n// Reglas del identificador seg√∫n tipo_doc (aplica a IDENTIFICADOR)\nfunction validateIdentificadorByTipoDoc(tipo_doc_numero, tipoDocRaw) {\n  const id = (tipo_doc_numero || \"\").trim();\n  const tipo = (tipoDocRaw || \"\").toUpperCase();\n  if (!tipo || !id) return { ok: true }; // si falta uno, no marcar error por tu regla de blancos\n  if (tipo === \"R\" && id.length !== 13)\n    return { ok: false, msg: \"debe tener exactamente 13 caracteres para tipo_doc = 'R'\" };\n  if (tipo === \"D\" && id.length !== 10)\n    return { ok: false, msg: \"debe tener exactamente 10 caracteres para tipo_doc = 'D'\" };\n  if (tipo === \"P\" && (id.length < 1 || id.length > 32))\n    return { ok: false, msg: \"debe tener entre 1 y 32 caracteres para tipo_doc = 'P'\" };\n  return { ok: true };\n}\n\nconst rows = [];               // { displayRow, sanitized, errs[] }\nconst idIndex = new Map();     // valor -> [idxs]\nconst docNumIndex = new Map(); // valor -> [idxs]\n\n// Campos tipo Y/N que debemos validar (si vienen)\nconst YN_FIELDS = [\n  \"es_extranjero\",\n  \"es_cliente\",\n  \"es_empleado\",\n  \"empleado_es_vendedor\",\n  \"empleado_es_operario\",\n  \"es_armador\",\n  \"es_charteador\",\n  \"es_proveedor\",\n  \"direccion_es_envio\",\n  \"direccion_es_factura\",\n  \"facturacion_electronica\",\n];\n\nitems.forEach((it, idx) => {\n  const src = it.json || it;\n  const sanitized = {};\n  for (const [srcKey, destKey] of Object.entries(mapCols)) {\n    sanitized[destKey] = normalizeValue(src[srcKey]);\n  }\n\n  // Fila visible: usas rn directo (tu snippet actual ya no suma 1)\n  let rn = parseInt(sanitized.row_number || src[\"row_number\"] || \"\");\n  if (!Number.isFinite(rn)) rn = idx;\n  const displayRow = rn;\n\n  const errs = [];\n\n  // --- 1) Validaci√≥n de caracteres (solo si no est√° vac√≠o) ---\n  for (const [srcKey, value] of Object.entries(src)) {\n    const raw = normalizeValue(value);\n    if (!raw) continue; // blancos no generan error\n    if (hasControlChars(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n    if (!allowedChars.test(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n  }\n\n  // --- 2) Longitudes espec√≠ficas ---\n  if (sanitized.nombre_cliente && !maxLen(sanitized.nombre_cliente, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre\" valor ${preview(sanitized.nombre_cliente)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.nombre_comercial && !maxLen(sanitized.nombre_comercial, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre Comercial\" valor ${preview(sanitized.nombre_comercial)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.descripcion && !maxLen(sanitized.descripcion, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Descripcion\" valor ${preview(sanitized.descripcion)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_contacto_no && !maxLen(sanitized.direccion_contacto_no, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion contacto N/O\" valor ${preview(sanitized.direccion_contacto_no)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_principal && !maxLen(sanitized.direccion_principal, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion Principal\" valor ${preview(sanitized.direccion_principal)} supera el tama√±o maximo de 255 caracteres`);\n\n  // --- 3) Reglas de dominio ---\n  // 3.1 Tipo Doc ‚àà {R,D,P}\n  if (sanitized.tipo_doc && !isValidTipoDoc(sanitized.tipo_doc)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc\" valor ${preview(sanitized.tipo_doc)} debe ser R, D o P`);\n  }\n\n  // 3.2 Campos Y/N (si vienen)\n  YN_FIELDS.forEach(k => {\n    const val = sanitized[k];\n    if (val && !isYN(val)) {\n      // obtener etiqueta de columna original (si quieres, puedes mapear a etiquetas ‚Äúbonitas‚Äù)\n      const label = {\n        es_extranjero: 'ES EXTRANJERO',\n        es_cliente: 'Es Cliente',\n        es_empleado: 'Empleado',\n        empleado_es_vendedor: 'Empleado Es Vendedor (Y/N)',\n        empleado_es_operario: 'Empleado Es Operario (Y/N)',\n        es_armador: 'Es armador (Y/N)',\n        es_charteador: 'Es charteador (Y/N)',\n        es_proveedor: 'Es Proveedor',\n        direccion_es_envio: 'Direccion es de envio (Y/N)',\n        direccion_es_factura: 'Direccion es de factura (Y/N)',\n        facturacion_electronica: 'Facturacion Electronica',\n      }[k] || k;\n      errs.push(`- Fila ${displayRow} - Columna \"${label}\" valor ${preview(val)} debe ser Y o N`);\n    }\n  });\n\n  // 3.3 Emails v√°lidos (si vienen)\n  if (sanitized.email_cliente && !isValidEmail(sanitized.email_cliente)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Email del cliente\" valor ${preview(sanitized.email_cliente)} no es un email valido`);\n  }\n  if (sanitized.correo_contacto_no && !isValidEmail(sanitized.correo_contacto_no)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Correo Electronico contacto N/O\" valor ${preview(sanitized.correo_contacto_no)} no es un email valido`);\n  }\n\n  // 3.4 Identificador vs Tipo Doc (longitud segun tipo)\n  const idRule = validateIdentificadorByTipoDoc(sanitized.tipo_doc_numero, sanitized.tipo_doc);\n  if (!idRule.ok) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc Numero\" valor ${preview(sanitized.tipo_doc_numero)} ${idRule.msg}`);\n  }\n\n  // --- 4) Numerificaci√≥n limite_credito (si viene) ---\n  if (sanitized.limite_credito) {\n    const n = Number(sanitized.limite_credito);\n    if (Number.isNaN(n)) {\n      errs.push(`- Fila ${displayRow} - Columna \"Limite de credito\" valor ${preview(sanitized.limite_credito)} no es numerico`);\n    } else {\n      sanitized.limite_credito = String(n);\n    }\n  }\n\n  // --- 5) Recolectar para duplicados (ignora vac√≠os) ---\n \n   if (sanitized.identificador) {\n    const arr = idIndex.get(sanitized.identificador) || [];\n    arr.push(idx);\n    idIndex.set(sanitized.identificador, arr);\n  }\n  if (sanitized.tipo_doc_numero) {\n    const arr = docNumIndex.get(sanitized.tipo_doc_numero) || [];\n    arr.push(idx);\n    docNumIndex.set(sanitized.tipo_doc_numero, arr);\n  }\n\n  rows.push({ displayRow, sanitized, errs });\n});\n\n// --- Duplicados: indicar TODAS las filas donde aparece el valor ---\nfunction annotateDuplicates(indexMap, columnLabel) {\n  for (const [val, idxs] of indexMap.entries()) {\n    if (idxs.length > 1) {\n      const filas = idxs.map(i => rows[i].displayRow).sort((a, b) => a - b);\n      const lista = filas.join(\", \");\n      idxs.forEach(i => {\n        rows[i].errs.push(\n          `- Fila ${rows[i].displayRow} - Columna \"${columnLabel}\" valor ${preview(val)} se encuentra duplicado en las filas ${lista}`\n        );\n      });\n    }\n  }\n}\nannotateDuplicates(idIndex, \"Identificador\");\nannotateDuplicates(docNumIndex, \"Tipo Doc Numero\");\n\n// --- Salida √∫nica ---\nconst anyErrors = rows.some(r => r.errs.length > 0);\nif (anyErrors) {\n  const header = \"TERCEROS- üö´ Errores encontrados:\";\n  const lines = [];\n  rows.forEach(r => { if (r.errs.length) lines.push(...r.errs); });\n  const mensaje = [header, ...lines].join(\"\\n\");\n  return [{ json: { mensaje } }];\n} else {\n  return rows.map(r => ({ json: r.sanitized }));\n}\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5904,-96],"id":"409f8b01-98c2-4989-8cb8-30f1ba5f4a65","name":"Tratamiento Final1"},{"parameters":{"operation":"executeQuery","query":"update c_bpartner set  m_pricelist_id = COALESCE((select m_pricelist_id from m_pricelist where name ='{{ $('Tratamiento Final1').item.json.cliente_lista_precios }}'),NULL),fin_paymentmethod_id =coalesce((select fin_paymentmethod_id from fin_paymentmethod where name ='{{ $('Tratamiento Final1').item.json.cliente_metodo_pago }}' ),NULL),c_paymentterm_id =COALESCE((select c_paymentterm_id from c_paymentterm where name ='{{ $json.cliente_condicion_pago }}'),NULL),invoicerule = '{{ $json.facturacion_inmediata }}', customer_blocking = 'N' where taxid = '{{ $json.tipo_doc_numero }}';","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[6416,32],"id":"e40d6bef-349b-4e00-a380-cb5312d99eba","name":"UpdateClientes","credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"update c_bpartner set isvendor='{{ $json.es_proveedor }}',po_pricelist_id =COALESCE((select m_pricelist_id from m_pricelist where name ='{{ $json.proveedor_lista_precios }}'),NULL), po_paymentmethod_id = coalesce((select fin_paymentmethod_id from fin_paymentmethod where name ='{{ $json.proveedor_metodo_pago }}' ),NULL)\n,PO_PaymentTerm_ID = COALESCE((select c_paymentterm_id from c_paymentterm where name ='{{ $json.proveedor_condicion_pago }}'),NULL)  where taxid ='{{ $json.tipo_doc_numero }}';\n","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[6416,-208],"id":"4e5709d3-2435-4ffc-9e26-ca94b33c740d","name":"UpdateVendor","credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"insert into c_location(c_location_id,ad_client_id,ad_org_id,isactive,created,createdby,updated,updatedby,address1,address2,city,c_country_id,c_region_id, c_city_id) values(get_uuid(),'{{ $('ADClient').item.json.ad_client_id }}','{{ $('ADOrg').item.json.ad_org_id }}','Y',now(),'100',now(),'100','{{ $json.direccion_principal }}','{{ $json.direccion_contacto_no }}','{{ $json.distrito_ciudad }}',sswh_c_country_get('{{ $json.pais }}'),sswh_c_region_get('{{ $json.provincia }}'),COALESCE((select c_city_id from c_city where name='{{ $json.distrito_ciudad }}'),NULL));\n","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[6208,272],"id":"aea98261-16b9-46d3-adfe-2bcfbcfa5f34","name":"InsertCocation","credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"insert into c_bpartner_location(c_bpartner_location_id,ad_client_id,ad_org_id,created,createdby,updated,updatedby,name,phone,phone2,c_bpartner_id,c_location_id,isshipto, isbillto) values (get_uuid(),'{{ $('ADClient').item.json.ad_client_id }}','{{ $('ADOrg').item.json.ad_org_id }}',now(),'100',now(),'100','{{ $json.direccion_principal }}','{{ $json.telefono }}','{{ $json.telefono_2 }}',(select c_bpartner_id from c_bpartner where taxid='{{ $json.tipo_doc_numero }}'),sswh_c_location_get((SELECT left('{{ $json.direccion_principal }}', 60)),'{{ $json.distrito_ciudad }}',sswh_c_region_get('{{ $json.provincia }}'),initcap('{{ $json.pais }}')),'{{ $json.direccion_es_envio }}','{{ $json.direccion_es_factura }}');\n","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[6832,272],"id":"f344c997-6dba-400a-b5db-4b19a54a3454","name":"InsertCbpLocation","credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"documentId":{"__rl":true,"value":"1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE","mode":"list","cachedResultName":"MaestroTerceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit?usp=drivesdk"},"sheetName":{"__rl":true,"value":781572916,"mode":"list","cachedResultName":"Terceros","cachedResultUrl":"https://docs.google.com/spreadsheets/d/1NMbX2WwNXW3mZWhUtV37SPQeiwBWdO8lxEQOD1dGlLE/edit#gid=781572916"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6400,272],"id":"a80d866c-652d-45ca-b3fe-f223f7de0f08","name":"Terceros3","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"/**\n * n8n Code Node - √önica salida\n * - Sin errores: devuelve items normalizados (uno por fila)\n * - Con errores: devuelve un solo item con { reporte: \"TERCEROS- üö´ Errores encontrados:\\n- Fila ...\" }\n * - Duplicados: incluye las filas donde aparece cada valor repetido\n */\n\nconst items = $input.all();\n\nconst mapCols = {\n  \"row_number\": \"row_number\",\n  \"IDENTIFICADOR\": \"identificador\",\n  \"NOMBRE DEL CLIENTE\": \"nombre_cliente\",\n  \"NOMBRE COMERCIAL\": \"nombre_comercial\",\n  \"DESCRIPCION\": \"descripcion\",\n  \"Grupo de Terceros\": \"grupo_terceros\",\n  \"Tipo Doc\": \"tipo_doc\",\n  \"Tipo Doc Numero\": \"tipo_doc_numero\",\n  \"Tipo Contribuyente\": \"tipo_contribuyente\",\n  \"ES EXTRANJERO\": \"es_extranjero\",\n  \"IDIOMA\": \"idioma\",\n  \"Es Cliente\": \"es_cliente\",\n  \"Cliente Metodo de Pago\": \"cliente_metodo_pago\",\n  \"Cliente Condicion de Pago\": \"cliente_condicion_pago\",\n  \"Cliente Lista de Precios\": \"cliente_lista_precios\",\n  \"Facturacion Inmediata\": \"facturacion_inmediata\",\n  \"Zona de Venta\": \"zona_venta\",\n  \"Empleado \": \"es_empleado\",\n  \"Empleado Es Vendedor (Y/N)\": \"empleado_es_vendedor\",\n  \"Empleado Es Operario (Y/N)\": \"empleado_es_operario\",\n  \"Es armador (Y/N)\": \"es_armador\",\n  \"Es charteador (Y/N)\": \"es_charteador\",\n  \"Es Proveedor\": \"es_proveedor\",\n  \"Proveedor Metodo de Pago\": \"proveedor_metodo_pago\",\n  \"Proveedor Condicion de Pago\": \"proveedor_condicion_pago\",\n  \"Provedor Lista de Precios\": \"proveedor_lista_precios\",\n  \"Contacto N/O\": \"contacto_no\",\n  \"Telefono contacto N/O\": \"telefono_contacto_no\",\n  \"Direccion contactoN/O\": \"direccion_contacto_no\",\n  \"Correo Electronico contacto N/O\": \"correo_contacto_no\",\n  \"Direcci√≥n Principal del Cliente o Proveedor\": \"direccion_principal\",\n  \"Distrito: Ciudad\": \"distrito_ciudad\",\n  \"Dep.: Provincia\": \"provincia\",\n  \"Pais (obligatorio): Ecuador\": \"pais\",\n  \"Telefono\": \"telefono\",\n  \"Telefono 2\": \"telefono_2\",\n  \"Direccion es de envio (Y/N)\": \"direccion_es_envio\",\n  \"Direccion es de factura (Y/N)\": \"direccion_es_factura\",\n  \"Facturacion Electronica\": \"facturacion_electronica\",\n  \"Limite de cr√©dedito\": \"limite_credito\",\n  \"Email del cliente\": \"email_cliente\",\n};\n\nconst hasControlChars = (s) => /[\\u0000-\\u001F\\u007F]/.test(s || \"\");\n\n// Si quieres una lista expl√≠cita de permitidos para nombres/direcciones, usa la siguiente y comenta la de ‚Äútodo unicode‚Äù\n// const allowedChars = /^[\\p{L}\\p{N}\\p{Zs}\\.\\,\\-\\/\\#\\&]*$/u;\n\n// Permitir letras/n√∫meros/puntuaci√≥n/s√≠mbolos/espacios (excluye controles)\nconst allowedChars = /^[\\p{L}\\p{N}\\p{P}\\p{S}\\p{Zs}]*$/u;\n\nfunction normalizeValue(v) {\n  if (v === null || v === undefined) return \"\";\n  return String(v).trim();\n}\n\nfunction preview(val, max = 80) {\n  const s = (val ?? \"\").toString();\n  return s.length <= max ? s : s.slice(0, max) + \"‚Ä¶\";\n}\n\nconst maxLen = (val, n) => (val || \"\").length <= n;\n\n// Email simple y robusto (case-insensitive)\nfunction isValidEmail(v) {\n  const s = (v || \"\").trim();\n  if (!s) return true; // vac√≠o NO es error\n  // Patr√≥n razonable para emails comunes\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]{2,}$/i.test(s);\n}\n\n// Solo R,D,P (si viene valor)\nfunction isValidTipoDoc(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return [\"R\", \"D\", \"P\"].includes(s);\n}\n\n// Solo Y/N (si viene valor)\nfunction isYN(v) {\n  const s = (v || \"\").trim().toUpperCase();\n  if (!s) return true; // vac√≠o NO es error\n  return s === \"Y\" || s === \"N\";\n}\n\n// Reglas del identificador seg√∫n tipo_doc (aplica a IDENTIFICADOR)\nfunction validateIdentificadorByTipoDoc(tipo_doc_numero, tipoDocRaw) {\n  const id = (tipo_doc_numero || \"\").trim();\n  const tipo = (tipoDocRaw || \"\").toUpperCase();\n  if (!tipo || !id) return { ok: true }; // si falta uno, no marcar error por tu regla de blancos\n  if (tipo === \"R\" && id.length !== 13)\n    return { ok: false, msg: \"debe tener exactamente 13 caracteres para tipo_doc = 'R'\" };\n  if (tipo === \"D\" && id.length !== 10)\n    return { ok: false, msg: \"debe tener exactamente 10 caracteres para tipo_doc = 'D'\" };\n  if (tipo === \"P\" && (id.length < 1 || id.length > 32))\n    return { ok: false, msg: \"debe tener entre 1 y 32 caracteres para tipo_doc = 'P'\" };\n  return { ok: true };\n}\n\nconst rows = [];               // { displayRow, sanitized, errs[] }\nconst idIndex = new Map();     // valor -> [idxs]\nconst docNumIndex = new Map(); // valor -> [idxs]\n\n// Campos tipo Y/N que debemos validar (si vienen)\nconst YN_FIELDS = [\n  \"es_extranjero\",\n  \"es_cliente\",\n  \"es_empleado\",\n  \"empleado_es_vendedor\",\n  \"empleado_es_operario\",\n  \"es_armador\",\n  \"es_charteador\",\n  \"es_proveedor\",\n  \"direccion_es_envio\",\n  \"direccion_es_factura\",\n  \"facturacion_electronica\",\n];\n\nitems.forEach((it, idx) => {\n  const src = it.json || it;\n  const sanitized = {};\n  for (const [srcKey, destKey] of Object.entries(mapCols)) {\n    sanitized[destKey] = normalizeValue(src[srcKey]);\n  }\n\n  // Fila visible: usas rn directo (tu snippet actual ya no suma 1)\n  let rn = parseInt(sanitized.row_number || src[\"row_number\"] || \"\");\n  if (!Number.isFinite(rn)) rn = idx;\n  const displayRow = rn;\n\n  const errs = [];\n\n  // --- 1) Validaci√≥n de caracteres (solo si no est√° vac√≠o) ---\n  for (const [srcKey, value] of Object.entries(src)) {\n    const raw = normalizeValue(value);\n    if (!raw) continue; // blancos no generan error\n    if (hasControlChars(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n    if (!allowedChars.test(raw)) {\n      errs.push(`- Fila ${displayRow} - Columna \"${srcKey}\" valor ${preview(raw)} contiene caracteres no permitidos`);\n    }\n  }\n\n  // --- 2) Longitudes espec√≠ficas ---\n  if (sanitized.nombre_cliente && !maxLen(sanitized.nombre_cliente, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre\" valor ${preview(sanitized.nombre_cliente)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.nombre_comercial && !maxLen(sanitized.nombre_comercial, 60))\n    errs.push(`- Fila ${displayRow} - Columna \"Nombre Comercial\" valor ${preview(sanitized.nombre_comercial)} supera el tama√±o maximo de 60 caracteres`);\n  if (sanitized.descripcion && !maxLen(sanitized.descripcion, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Descripcion\" valor ${preview(sanitized.descripcion)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_contacto_no && !maxLen(sanitized.direccion_contacto_no, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion contacto N/O\" valor ${preview(sanitized.direccion_contacto_no)} supera el tama√±o maximo de 255 caracteres`);\n  if (sanitized.direccion_principal && !maxLen(sanitized.direccion_principal, 255))\n    errs.push(`- Fila ${displayRow} - Columna \"Direccion Principal\" valor ${preview(sanitized.direccion_principal)} supera el tama√±o maximo de 255 caracteres`);\n\n  // --- 3) Reglas de dominio ---\n  // 3.1 Tipo Doc ‚àà {R,D,P}\n  if (sanitized.tipo_doc && !isValidTipoDoc(sanitized.tipo_doc)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc\" valor ${preview(sanitized.tipo_doc)} debe ser R, D o P`);\n  }\n\n  // 3.2 Campos Y/N (si vienen)\n  YN_FIELDS.forEach(k => {\n    const val = sanitized[k];\n    if (val && !isYN(val)) {\n      // obtener etiqueta de columna original (si quieres, puedes mapear a etiquetas ‚Äúbonitas‚Äù)\n      const label = {\n        es_extranjero: 'ES EXTRANJERO',\n        es_cliente: 'Es Cliente',\n        es_empleado: 'Empleado',\n        empleado_es_vendedor: 'Empleado Es Vendedor (Y/N)',\n        empleado_es_operario: 'Empleado Es Operario (Y/N)',\n        es_armador: 'Es armador (Y/N)',\n        es_charteador: 'Es charteador (Y/N)',\n        es_proveedor: 'Es Proveedor',\n        direccion_es_envio: 'Direccion es de envio (Y/N)',\n        direccion_es_factura: 'Direccion es de factura (Y/N)',\n        facturacion_electronica: 'Facturacion Electronica',\n      }[k] || k;\n      errs.push(`- Fila ${displayRow} - Columna \"${label}\" valor ${preview(val)} debe ser Y o N`);\n    }\n  });\n\n  // 3.3 Emails v√°lidos (si vienen)\n  if (sanitized.email_cliente && !isValidEmail(sanitized.email_cliente)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Email del cliente\" valor ${preview(sanitized.email_cliente)} no es un email valido`);\n  }\n  if (sanitized.correo_contacto_no && !isValidEmail(sanitized.correo_contacto_no)) {\n    errs.push(`- Fila ${displayRow} - Columna \"Correo Electronico contacto N/O\" valor ${preview(sanitized.correo_contacto_no)} no es un email valido`);\n  }\n\n  // 3.4 Identificador vs Tipo Doc (longitud segun tipo)\n  const idRule = validateIdentificadorByTipoDoc(sanitized.tipo_doc_numero, sanitized.tipo_doc);\n  if (!idRule.ok) {\n    errs.push(`- Fila ${displayRow} - Columna \"Tipo Doc Numero\" valor ${preview(sanitized.tipo_doc_numero)} ${idRule.msg}`);\n  }\n\n  // --- 4) Numerificaci√≥n limite_credito (si viene) ---\n  if (sanitized.limite_credito) {\n    const n = Number(sanitized.limite_credito);\n    if (Number.isNaN(n)) {\n      errs.push(`- Fila ${displayRow} - Columna \"Limite de credito\" valor ${preview(sanitized.limite_credito)} no es numerico`);\n    } else {\n      sanitized.limite_credito = String(n);\n    }\n  }\n\n  // --- 5) Recolectar para duplicados (ignora vac√≠os) ---\n \n   if (sanitized.identificador) {\n    const arr = idIndex.get(sanitized.identificador) || [];\n    arr.push(idx);\n    idIndex.set(sanitized.identificador, arr);\n  }\n  if (sanitized.tipo_doc_numero) {\n    const arr = docNumIndex.get(sanitized.tipo_doc_numero) || [];\n    arr.push(idx);\n    docNumIndex.set(sanitized.tipo_doc_numero, arr);\n  }\n\n  rows.push({ displayRow, sanitized, errs });\n});\n\n// --- Duplicados: indicar TODAS las filas donde aparece el valor ---\nfunction annotateDuplicates(indexMap, columnLabel) {\n  for (const [val, idxs] of indexMap.entries()) {\n    if (idxs.length > 1) {\n      const filas = idxs.map(i => rows[i].displayRow).sort((a, b) => a - b);\n      const lista = filas.join(\", \");\n      idxs.forEach(i => {\n        rows[i].errs.push(\n          `- Fila ${rows[i].displayRow} - Columna \"${columnLabel}\" valor ${preview(val)} se encuentra duplicado en las filas ${lista}`\n        );\n      });\n    }\n  }\n}\nannotateDuplicates(idIndex, \"Identificador\");\nannotateDuplicates(docNumIndex, \"Tipo Doc Numero\");\n\n// --- Salida √∫nica ---\nconst anyErrors = rows.some(r => r.errs.length > 0);\nif (anyErrors) {\n  const header = \"TERCEROS- üö´ Errores encontrados:\";\n  const lines = [];\n  rows.forEach(r => { if (r.errs.length) lines.push(...r.errs); });\n  const mensaje = [header, ...lines].join(\"\\n\");\n  return [{ json: { mensaje } }];\n} else {\n  return rows.map(r => ({ json: r.sanitized }));\n}\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6608,272],"id":"4d65e7c9-08bb-49c6-beb1-c7656e258897","name":"Tratamiento Final2"},{"parameters":{"operation":"executeQuery","query":"insert into c_bpartner (\n  c_bpartner_id,\n  ad_client_id,\n  ad_org_id,\n  created, createdby,\n  updated, updatedby,\n  value,\n  name,\n  name2,\n  em_sswh_taxidtype,\n  taxid,\n  em_sswh_taxpayer_id,\n  c_bp_group_id,\n  description,\n  isactive,\n  em_ssfi_foreign,\n  ad_language,\n  SO_CreditLimit,\n  EM_EEI_Eeioice,\n  EM_EEI_Email,\n  isemployee,\n  issalesrep\n) values (\n  get_uuid(),\n  $1::numeric,\n  $2::numeric,\n  now(), $3::numeric,\n  now(), $3::numeric,\n  $4,\n  $5,\n  $6,\n  $7,\n  $8,\n  (select sswh_taxpayer_id from sswh_taxpayer where name = $9 limit 1),\n  (select c_bp_group_id  from c_bp_group    where name = $10 limit 1),\n  nullif($11, ''),\n  'Y',\n  case when coalesce($12,'N') ilike 'Y' then 'Y' else 'N' end,\n  (select ad_language from ad_language where name = $13 limit 1),\n  coalesce(nullif($14,'')::numeric, 0),\n  case when coalesce($15,'N') ilike 'Y' then 'Y' else 'N' end,\n  nullif($16, ''),\n  case when coalesce($17,'N') ilike 'Y' then 'Y' else 'N' end,\n  case when coalesce($18,'N') ilike 'Y' then 'Y' else 'N' end\n);","options":{"queryReplacement":"=\"={{$node[\\\"ADClient\\\"].json[\\\"ad_client_id\\\"]}}\",\n            \"={{$node[\\\"ADOrg\\\"].json[\\\"ad_org_id\\\"]}}\",\n            \"={{100}}\",\n            \"={{$json.identificador}}\",\n            \"={{$json.nombre_cliente}}\",\n            \"={{$json.nombre_comercial}}\",\n            \"={{$json.tipo_doc}}\",\n            \"={{$json.tipo_doc_numero}}\",\n            \"={{$json.tipo_contribuyente}}\",\n            \"={{$json.grupo_terceros}}\",\n            \"={{$json.descripcion}}\",\n            \"={{$json.es_extranjero}}\",\n            \"={{$json.idioma}}\",\n            \"={{$node[\\\"Tratamiento Final\\\"].json[\\\"limite_credito\\\"]}}\",\n            \"={{$node[\\\"Tratamiento Final\\\"].json[\\\"facturacion_electronica\\\"]}}\",\n            \"={{$node[\\\"Tratamiento Final\\\"].json[\\\"email_cliente\\\"]}}\",\n            \"={{$node[\\\"Tratamiento Final\\\"].json[\\\"es_empleado\\\"]}}\",\n            \"={{$node[\\\"Tratamiento Final\\\"].json[\\\"empleado_es_vendedor\\\"]}}\""}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[5232,368],"id":"0839eb37-2b9c-484a-8ae0-14fd38fef0d5","name":"InsertPartner1","credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}}],"connections":{"Terceros":{"main":[[{"node":"Tratamiento Inicial","type":"main","index":0}]]},"When clicking ‚ÄòExecute workflow‚Äô":{"main":[[{"node":"ADClient","type":"main","index":0}]]},"Tratamiento Inicial":{"main":[[{"node":"TaxPayerOB","type":"main","index":0},{"node":"If","type":"main","index":0}]]},"If":{"main":[[{"node":"Merge1","type":"main","index":9}],[]]},"TaxPayerOB":{"main":[[{"node":"ValidaTaxPayer","type":"main","index":0}]]},"ValidaTaxPayer":{"main":[[{"node":"PartnerGroupOB","type":"main","index":0},{"node":"Merge1","type":"main","index":0}]]},"PartnerGroupOB":{"main":[[{"node":"ValidaPartnerGroup","type":"main","index":0}]]},"ValidaPartnerGroup":{"main":[[{"node":"LanguageOB","type":"main","index":0},{"node":"Merge1","type":"main","index":1}]]},"LanguageOB":{"main":[[{"node":"ValidaLanguage","type":"main","index":0}]]},"PaymentMethodOB":{"main":[[{"node":"ValidaPaymentMethod","type":"main","index":0}]]},"ValidaLanguage":{"main":[[{"node":"PaymentMethodOB","type":"main","index":0},{"node":"Merge1","type":"main","index":2}]]},"ValidaPaymentMethod":{"main":[[{"node":"PaymentTermOB","type":"main","index":0},{"node":"Merge1","type":"main","index":3}]]},"PaymentTermOB":{"main":[[{"node":"ValidaPaymentTerm","type":"main","index":0}]]},"ValidaPaymentTerm":{"main":[[{"node":"PriceListOB","type":"main","index":0},{"node":"Merge1","type":"main","index":4}]]},"PriceListOB":{"main":[[{"node":"ValidaPriceList","type":"main","index":0}]]},"ValidaPriceList":{"main":[[{"node":"CityOB","type":"main","index":0},{"node":"Merge1","type":"main","index":5}]]},"CityOB":{"main":[[{"node":"ValidaCity","type":"main","index":0}]]},"ValidaCity":{"main":[[{"node":"RegionOB","type":"main","index":0},{"node":"Merge1","type":"main","index":6}]]},"RegionOB":{"main":[[{"node":"ValidaRegion","type":"main","index":0}]]},"ValidaRegion":{"main":[[{"node":"CountryOB","type":"main","index":0},{"node":"Merge1","type":"main","index":7}]]},"CountryOB":{"main":[[{"node":"ValidaCountry","type":"main","index":0}]]},"Merge1":{"main":[[{"node":"Unificar Errores Terceros","type":"main","index":0}]]},"ValidaCountry":{"main":[[{"node":"Merge1","type":"main","index":8}]]},"Unificar Errores Terceros":{"main":[[{"node":"Confirmacion1","type":"main","index":0}]]},"Catalogo de Terceros OB":{"main":[[{"node":"ValidaYaCreadosOB","type":"main","index":0}]]},"ADClient":{"main":[[{"node":"ADOrg","type":"main","index":0}]]},"Confirmacion1":{"main":[[]]},"ADOrg":{"main":[[{"node":"Terceros1","type":"main","index":0}]]},"Terceros1":{"main":[[{"node":"Tratamiento Final","type":"main","index":0}]]},"Tratamiento Final":{"main":[[{"node":"InsertPartner","type":"main","index":0}]]},"Proveedores":{"main":[[{"node":"UpdateVendor","type":"main","index":0}]]},"Clientes":{"main":[[{"node":"UpdateClientes","type":"main","index":0}]]},"InsertPartner":{"main":[[]]},"Terceros2":{"main":[[{"node":"Tratamiento Final1","type":"main","index":0}]]},"Tratamiento Final1":{"main":[[{"node":"Proveedores","type":"main","index":0},{"node":"Clientes","type":"main","index":0},{"node":"InsertCocation","type":"main","index":0}]]},"InsertCocation":{"main":[[{"node":"Terceros3","type":"main","index":0}]]},"Terceros3":{"main":[[{"node":"Tratamiento Final2","type":"main","index":0}]]},"Tratamiento Final2":{"main":[[{"node":"InsertCbpLocation","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"5f00ec96-064b-4f7f-bd35-f8197e93ec6a","triggerCount":0,"shared":[{"createdAt":"2025-09-30T15:09:43.522Z","updatedAt":"2025-09-30T15:09:43.522Z","role":"workflow:owner","workflowId":"wVlmKsUhHo2xrjG4","projectId":"Bev2pwmvUzes1BM7"}],"tags":[]}