{"createdAt":"2025-10-08T17:07:11.754Z","updatedAt":"2025-10-16T23:55:27.000Z","id":"C7EDvLI28JCxQyp3","name":"PMOSaldoInicialCxC","active":true,"isArchived":false,"nodes":[{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"={{ $('Unificar Errores Productos').item.json.mensaje }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[5824,-112],"id":"fee985a3-23d7-4536-9c75-b06a55b009a5","name":"Confirmacion","executeOnce":false},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'AdOrgOB';          // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Organizacion'];    // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // saltos/tabs -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim();                                  // SOLO recorta bordes (no colapsa interiores)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return { json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } };\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return { json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } };\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo trim en bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n// Tomar tipo_archivo desde el primer item de Merge8\nconst m8First = $items('Merge8', 0, 0)[0]?.json || {};\nconst tipo_archivo = m8First.tipo_archivo ?? 'N/D';\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\n// En un Code node en modo \"Run Once\", devuelve UN SOLO objeto:\nreturn { json: { mensaje } };\n\n/** Si prefieres la salida detallada, usa esto (tambi√©n como objeto √∫nico):\nreturn {\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n};\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1712,592],"id":"54b25147-3fd8-4377-ac14-fd9c915e938c","name":"Code3"},{"parameters":{"jsCode":"// Lee todo lo que llega del Merge y decide EXITO / ERROR\nfunction pickMsgs(items) {\n  return items.map(i => String(i.json?.mensaje ?? '').trim()).filter(Boolean);\n}\nfunction hasErr(s) { return /error/i.test(s); }\nfunction bullets(msg) {\n  const m = String(msg).match(/errores?\\s+encontrados:\\s*([\\s\\S]*)/i);\n  const body = (m ? m[1] : msg).replace(/\\r/g, '');\n  const set = new Set(body.split('\\n').map(x => x.trim()).filter(Boolean));\n  return Array.from(set).map(x => x.startsWith('-') ? x : `- ${x}`);\n}\n\nconst msgs = pickMsgs($items('Merge2'));\nconst errs = msgs.filter(hasErr);\n\nlet resultado, mensaje;\nif (errs.length === 0) {\n  resultado = 'EXITO';\n  mensaje = 'CXC - ‚úÖ Todo Correcto';\n} else {\n  const all = errs.flatMap(bullets);\n  resultado = 'ERROR';\n  mensaje = `CXC - üö´ Errores encontrados:\\n${all.join('\\n')}`;\n}\n\nreturn [{ json: { resultado, mensaje, totalMensajes: msgs.length, totalConError: errs.length,tipo:$('Merge8').first().json.tipo_archivo  } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5632,-112],"id":"832ff220-7142-4114-ae63-ced360713cfd","name":"Unificar Errores Productos"},{"parameters":{"numberInputs":10},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5136,-544],"id":"76f9ba87-6afe-4d0c-9727-cdc269734154","name":"Merge"},{"parameters":{"jsCode":"// n8n Function Node\n\n// Columnas a verificar duplicados\nconst COLS_DUP = [\"No documento\", \"No referencia\"];\n\n// Columnas de fecha a validar \"aaaa-mm-dd\"\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"];\n\n// Columnas permitidas vac√≠as y columnas a ignorar en validaci√≥n\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);\nconst IGNORE_COLS = new Set([\"row_number\"]);\n\n// Regex de control/saltos de p√°gina y otros controles (excluimos \\n y \\r aqu√≠, los tratamos aparte)\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g; // incluye \\f (\\x0C) y otros controles\nconst PAGE_BREAK_REGEX = /\\f/g; // expl√≠cito\n// Saltos de l√≠nea/enter (incluye CRLF, CR, LF y separadores Unicode de l√≠nea/p√°rrafo)\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;\n\n// Permitidos por car√°cter (ya sin \\n/\\r porque los normalizamos a espacio)\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\n// Validaci√≥n de fecha aaaa-mm-dd + calendario real (bisiestos, etc.)\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\n// Helpers\nconst toRowNum = (row, idx) => {\n  if (row && row.row_number != null) return row.row_number;\n  return (idx + 2);\n};\n\n// SOLO trim al inicio/fin; NO colapsar espacios internos\nconst cleanText = (val) => {\n  if (typeof val !== \"string\") return val;\n  let cleaned = val;\n\n  // 1) Normalizar saltos de l√≠nea/enter -> espacio\n  cleaned = cleaned.replace(LINEBREAK_REGEX, \" \");\n\n  // 2) Normalizar saltos de p√°gina/control chars -> espacio\n  cleaned = cleaned.replace(PAGE_BREAK_REGEX, \" \");\n  cleaned = cleaned.replace(CONTROL_CHARS_REGEX, \" \");\n\n  // 3) Solo recortar bordes (no tocar espacios intermedios)\n  cleaned = cleaned.trim();\n\n  return cleaned;\n};\n\nconst findSpecials = (val) => {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n};\n\n// --- Proceso ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza + caracteres especiales + vac√≠os\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return; // omitir campos meta\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      // Limpieza\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      // Vac√≠o no permitido (excepto columnas permitidas)\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      // Detecci√≥n de caracteres especiales no permitidos post-limpieza\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // No-string: verificar nulos/indefinidos como vac√≠o (0 num√©rico es v√°lido)\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de formato y valor de fechas (aaaa-mm-dd)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim(); // solo bordes\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      // tambi√©n aplica regla de \"no vac√≠o\" para fechas\n      if (!COLS_ALLOW_EMPTY.has(col)) {\n        errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  }\n\n  // Preparar detecci√≥n de duplicados (con valores ya limpios; recorte SOLO en bordes)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// (Opcional) Filas con error ya limpias, por si luego las quieres devolver\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Mensaje final requerido\nconst mensaje = errores.length\n  ? `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`\n  : 'CXC - ‚úÖ Todo Correcto';\n\nreturn [{\n  json: {\n    mensaje\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1680,48],"id":"77dd8127-a5e4-457b-aa02-9a278fea4ef3","name":"InitCleaning","alwaysOutputData":false,"executeOnce":false},{"parameters":{"operation":"executeQuery","query":"select name from ad_org where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1696,336],"id":"2c1e2e83-5a39-436d-92b1-69774ca40c06","name":"AdOrgOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select documentno from c_invoice where issotrx='{{$item(0).$node[\"Merge8\"].json[\"issotrx\"]}}'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1920,336],"id":"38f91460-3037-49c9-84c4-a3c57db864e2","name":"FacturasOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select name  from c_doctype  where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2160,336],"id":"7a23d4fa-ce94-4cc1-ac31-1d86a5e2c92b","name":"DoctypeOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';              // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'FacturasOB';    // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'documentno';   // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['No documento','No referencia']; // columnas del Sheet a validar contra Postgres\n\nconst NORMALIZAR = true;   // true: sin tildes y MAY√öSCULAS (se preservan espacios internos)\nconst TRIM_EMPTY = true;   // true: ignora vac√≠os\n\n// === Normalizadores (NO colapsan espacios internos) ===\nconst cleanDisplay = (s) => {\n  let out = (s ?? '').toString();\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // forma can√≥nica\n  return out.trim();                               // SOLO bordes; NO tocar espacios internos\n};\n\nconst norm = (s) => {\n  let out = cleanDisplay(s);\n  if (TRIM_EMPTY && out === '') return '';\n  if (!NORMALIZAR) return out;\n  // quitar tildes + pasar a MAY√öSCULAS; preserva espacios intermedios\n  return out.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toUpperCase();\n};\n\n// === 1) Datasheet (Google Sheets) ===\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `PRODUCTOS - üö´ No hay datos desde el nodo Sheet \"${SHEET_NODE}\"`, totalErrores: 1 } }];\n}\nconst sheetRows = sheetItems.map((it, i) => {\n  const r = it.json || {};\n  const base = { rowNumber: r.row_number ?? (i + 2) }; // encabezado en fila 1\n  for (const col of COLS_VALIDAR) {\n    base[`${col}Raw`]  = cleanDisplay(r[col]);  // muestra (solo trim bordes)\n    base[`${col}Norm`] = norm(r[col]);          // clave de comparaci√≥n\n  }\n  return base;\n});\n\n// === 2) Postgres (UNA sola columna) ===\nconst obRows = ($items(POSTGRES_NODE) || []).map(it => it.json || {});\nconst obSet = new Set(\n  obRows.map(r => norm(r[POSTGRES_FIELD])).filter(v => v !== '')\n);\n\n// === 3) Acumular coincidencias (valores del sheet que YA existen en OB) ===\nconst dupPorColumna = {};\nfor (const col of COLS_VALIDAR) dupPorColumna[col] = new Map();\n\nfor (const r of sheetRows) {\n  for (const col of COLS_VALIDAR) {\n    const key = r[`${col}Norm`];\n    if (!key) continue;\n    if (obSet.has(key)) {\n      const entry = dupPorColumna[col].get(key) || { muestra: r[`${col}Raw`] || '(vac√≠o)', rows: [] };\n      entry.rows.push(r.rowNumber);\n      dupPorColumna[col].set(key, entry);\n    }\n  }\n}\n\n// === 4) Mensajes en el formato solicitado ===\nconst errores = [];\nconst sortByMuestra = (a, b) => a.muestra.localeCompare(b.muestra, 'es', { sensitivity: 'base' });\n\nfor (const col of COLS_VALIDAR) {\n  const valores = [...dupPorColumna[col].values()].sort(sortByMuestra);\n  valores.forEach(e => {\n    e.rows.sort((a, b) => a - b);\n    errores.push(`Duplicado en columna \"${col}\": valor \"${e.muestra}\" en filas ${e.rows.join(', ')}`);\n  });\n}\n\n// Tomar tipo_archivo desde el primer item de Merge8\nconst m8First = $items('Merge8', 0, 0)[0]?.json || {};\nconst tipo_archivo = m8First.tipo_archivo ?? 'N/D';\n\n// === 5) Salida ===\nconst mensaje = errores.length === 0\n  ? `${tipo_archivo} - ‚úÖ Todo Correcto`\n  : `${tipo_archivo} (existentes en OB) - üö´ Error Coincidencias encontradas:\\n- ${errores.join('\\n- ')}`;\n\nreturn [{\n  json: {\n    mensaje,\n    totalErrores: errores.length\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1920,592],"id":"2f91797d-c876-4f8a-b0ea-4801ae40c1b7","name":"FactOB"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'DoctypeOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();    // respeta espacios tal cual\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n// Lee tipo_archivo del primer item de Merge8 (mismo workflow)\nconst m8First = $items('Merge8', 0, 0)[0]?.json || {};\nconst tipo_archivo = m8First.tipo_archivo ?? 'N/D';\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ?  `${tipo_archivo} - Todo Correcto`\n  :  `${tipo_archivo} - Errores encontrados:\\n- ` + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2160,592],"id":"f36f35e5-3f04-49b9-9895-39f35b00ed1e","name":"DtOB"},{"parameters":{"operation":"executeQuery","query":"select taxid from c_bpartner where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2416,336],"id":"2782b39f-c9cd-4b81-bcb2-c64aa96cbfd0","name":"PartnerOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'DoctypeOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Documento transaccion']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2416,592],"id":"d129dcef-6c89-437d-b35c-612ad706d3e7","name":"BPOB"},{"parameters":{"operation":"executeQuery","query":"select name from m_pricelist where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2656,336],"id":"330b34bb-fcf4-413c-b5b6-bba2d098c5ff","name":"PriceListOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PriceListOB';      // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Lista de precios']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia sin tocar espacios internos: reemplaza CR/LF/TAB por un espacio,\n// elimina NBSP/zero-width, normaliza unicode y SOLO trim de bordes.\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');                 // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');   // zero-width + BOM\n  out = out.replace(/[\\r\\n\\t]+/g, ' ');              // CR/LF/TAB -> espacio\n  if (out.normalize) out = out.normalize('NFKC');    // normaliza unicode\n  out = out.trim();                                  // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia exacta por nombre limpio) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) }; // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (conserva espacios internos)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2656,592],"id":"29b4b9e2-80d1-4fe9-9fe8-133e19a8b9b8","name":"ValidaPriceList"},{"parameters":{"operation":"executeQuery","query":"select iso_code from c_currency where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[2896,336],"id":"3b3e705e-73fd-4a41-9fba-e3273cee5bcf","name":"MonedaOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'MonedaOB';         // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'iso_code';        // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Moneda'];          // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (todo a string y limpio, SIN colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO colapsar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (solo coincidencia directa) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2896,592],"id":"4fa0c38b-7404-4226-81d0-b10d1e50f7fc","name":"ValidaCurrency"},{"parameters":{"operation":"executeQuery","query":"select name from fin_paymentmethod where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3136,336],"id":"5b338b84-5ea4-4834-be5f-6c3600f712ba","name":"PaymentMethodOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentMethodOB';  // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Forma de pago'];   // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia caracteres invisibles y saltos a espacios, y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3136,592],"id":"6a2ccafd-3457-45bb-8475-3148635e069c","name":"ValidaPaymentMethod"},{"parameters":{"operation":"executeQuery","query":"select name from c_paymentterm where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3376,336],"id":"56f36f8d-35b3-4ec7-9c6b-93a9e83ea11c","name":"PaymentTermOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'PaymentTermOB';    // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Condiciones de pago']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos a espacios y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> un espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3376,592],"id":"d9fd9446-0d9c-403a-88c2-ae0eb1030350","name":"ValidaPaymentTerm"},{"parameters":{"operation":"executeQuery","query":"select name from m_product where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3600,336],"id":"0173f866-618b-4a73-9693-989a8ff8b471","name":"ProductOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'ProductOB';        // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Producto'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos a espacios y SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> un espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> un espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes; NO tocar espacios internos\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3600,592],"id":"b807ba48-4e0a-4187-81d5-57ed9d22570e","name":"ValidaProduct"},{"parameters":{"operation":"executeQuery","query":"select uomsymbol from c_uom where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3824,336],"id":"13827689-dd7e-46e4-8df0-e3e5d725d666","name":"UnidadOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'UnidadOB';         // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'uomsymbol';       // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Unidad de la orden']; // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos y SOLO recorta bordes (no toca espacios internos normales)\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                 // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3824,592],"id":"12caa9c7-67ca-40f2-8ade-7528f545643c","name":"ValidaUnidad"},{"parameters":{"operation":"executeQuery","query":"select name from c_tax where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4064,336],"id":"c40acc90-263f-47c3-a577-b8bf864b0214","name":"TaxOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"operation":"executeQuery","query":"select name from c_costcenter where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4304,336],"id":"56a93eaa-3224-4247-9ada-90eb2cdfade3","name":"CostCenterOB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"operation":"executeQuery","query":"select name from user1 where isactive='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4544,336],"id":"9d2a8a0f-6f96-48a1-9eba-bf1c26fa92a9","name":"User1OB","executeOnce":true,"credentials":{"postgres":{"id":"yuQbEbYhio1ra0Ss","name":"GasoManta-CafeMar"}}},{"parameters":{"numberInputs":6},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5424,-176],"id":"1e705594-c5bb-4032-97e4-36b2f7157763","name":"Merge2"},{"parameters":{"formTitle":"Saldos Iniciales CxC","formFields":{"values":[{"fieldLabel":"Plantilla","fieldType":"file","multipleFiles":false,"acceptFileTypes":".xlsx","requiredField":true},{"fieldLabel":"Telefono Celular","requiredField":true}]},"options":{}},"type":"n8n-nodes-base.formTrigger","typeVersion":2.2,"position":[-2256,-288],"id":"9bc487f7-5777-450b-80b2-6ce6804ea4c4","name":"CargarProductos","webhookId":"64fe15ed-472c-4fc4-8333-583feea5f13b"},{"parameters":{"inputDataFieldName":"=data","name":"={{ $('Variables1').item.json.fileName }}","driveId":{"__rl":true,"mode":"list","value":"My Drive"},"folderId":{"__rl":true,"value":"={{ $('Variables1').item.json.uploadFilesDirectory }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-784,-304],"id":"9eb796bf-cc91-49aa-a6eb-10e77c5e0189","name":"Upload file1","credentials":{"googleDriveOAuth2Api":{"id":"2D5m9UCVL0y0GKgC","name":"Google Drive account"}}},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"13IxZ60e9aoBpSIIxNBk01_zZxbkVPkow","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Az-ZFrPX8NLT3-AOv8lUBOLu-wS2c34i","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://admchat.duckdns.org/wa-decrypt/decrypt-document","type":"string"},{"id":"e85da8f3-3311-4594-b365-55aadab8176e","name":"fileName","value":"CxC","type":"string"},{"id":"00dbcc54-57ea-4710-9124-a6979416f3cd","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"293163d2-3cb2-4103-a8de-90080923e03f","name":"telefono","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}","type":"string"}]},"includeOtherFields":true,"options":{"stripBinary":true}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-1504,-288],"id":"ba062cdd-3c2a-4a20-810e-639cff01dbfd","name":"Variables1"},{"parameters":{"operation":"binaryToPropery","binaryPropertyName":"Plantilla","options":{}},"type":"n8n-nodes-base.extractFromFile","typeVersion":1,"position":[-2048,-288],"id":"93df98e3-e4d1-4396-8d7d-bef0e1f05a2e","name":"Extract from File"},{"parameters":{"operation":"toBinary","sourceProperty":"data","binaryPropertyName":"={{ $('Extract from File').item.json.data }}","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[-944,-304],"id":"ebe12a02-812c-4016-bc22-902c44470f64","name":"Convert to File"},{"parameters":{"workflowId":{"__rl":true,"value":"={{ $('Variables1').item.json.subworkflowID }}","mode":"id"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"options":{"waitForSubWorkflow":true}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[-1296,-416],"id":"44d06eb1-15cc-443d-9cc6-c6f2f17d54d8","name":"Execute Workflow","alwaysOutputData":true,"notesInFlow":false,"executeOnce":false,"retryOnFail":false},{"parameters":{"mode":"chooseBranch","useDataOfInput":2},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-1088,-304],"id":"3fce2c01-8c46-4600-ba0f-fd92f0489d66","name":"Merge3"},{"parameters":{"workflowId":{"__rl":true,"value":"={{ $('Merge8').item.json.subworkflowID }}","mode":"id","cachedResultUrl":"/workflow/=%7B%7B%20$('Merge8').item.json.subworkflowID%20%7D%7D"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"options":{"waitForSubWorkflow":true}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[-576,128],"id":"d16575fb-9317-42de-8065-ae847f5c34d6","name":"Execute Workflow1","alwaysOutputData":true,"notesInFlow":false,"executeOnce":false,"retryOnFail":false},{"parameters":{"mode":"chooseBranch","useDataOfInput":2},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-368,224],"id":"4bf79211-5baa-45b6-8db6-3fe152b47096","name":"Merge4"},{"parameters":{"method":"POST","url":"=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy","authentication":"predefinedCredentialType","nodeCredentialType":"googleOAuth2Api","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Variables1').item.json.convertedFilesDirectory }}\"]\n}","options":{}},"id":"79382d57-6b77-4a5b-b9dc-3482e3850ef0","name":"Convert File2","type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-624,-304],"credentials":{"googleOAuth2Api":{"id":"N3sd298xjJQFZGOz","name":"Google account"}},"onError":"continueErrorOutput"},{"parameters":{"httpMethod":"POST","path":"tesoreria","responseMode":"lastNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-3104,272],"id":"646fe827-9068-42ff-b74a-8f5ac4c37e82","name":"Webhook","webhookId":"768b9e6a-6baa-4c5b-8ae9-4e5f596eac72"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"a3e61211-0ab1-47f7-89d7-4dcd56af7e7b","leftValue":"={{ $json.kind }}","rightValue":"documento","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Documento"}]},"options":{"fallbackOutput":"extra"}},"type":"n8n-nodes-base.switch","typeVersion":3.2,"position":[-1504,256],"id":"fb8a7356-c7aa-410b-8059-33fcc15d8b61","name":"Switch"},{"parameters":{"method":"POST","url":" https://agileapichat.sidesoftcorp.com/api/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer linea1"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=Documento No Soportado"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-992,480],"id":"6a5d9937-dc82-42ad-b1a8-cbc2ac160cb0","name":"Response"},{"parameters":{"jsCode":"return items.map(item => {\n  const body = item.json.body;\n  const msg = body.message || {};\n  const telefono = $input.first().json.body.key.remoteJid.split('@')[0];\n\n  let messageText = \"\";\n\n  // Caso 1: texto plano\n  if (msg.conversation) {\n    messageText = msg.conversation;\n  }\n\n  // Caso 2: texto extendido (con contexto)\n  else if (msg.extendedTextMessage?.text) {\n    messageText = msg.extendedTextMessage.text;\n  }\n\n  // Caso 3: imagen con caption\n  else if (msg.imageMessage?.caption) {\n    messageText = msg.imageMessage.caption;\n  }\n\n  // Caso 4: video con caption\n  else if (msg.videoMessage?.caption) {\n    messageText = msg.videoMessage.caption;\n  }\n\n  // Caso 5: audio/nota de voz (no trae texto, solo informamos)\n  else if (msg.audioMessage) {\n    messageText = \"[Audio recibido]\";\n  }\n\n  // Caso 6: bot√≥n presionado\n  else if (msg.buttonsResponseMessage?.selectedButtonId) {\n    messageText = msg.buttonsResponseMessage.selectedButtonId;\n  }\n\n  // Caso 7: lista seleccionada\n  else if (msg.listResponseMessage?.singleSelectReply?.selectedRowId) {\n    messageText = msg.listResponseMessage.singleSelectReply.selectedRowId;\n  }\n\n  // Caso 8: sticker\n  else if (msg.stickerMessage) {\n    messageText = \"[Sticker recibido]\";\n  }\n\n  // Caso 9: documento\n  else if (msg.documentMessage?.fileName) {\n    messageText = `[Documento: ${msg.documentMessage.fileName}]`;\n  }\n\n  // Si no hay nada reconocible\n  else {\n    messageText = \"[Mensaje no reconocido]\";\n  }\n\n  return {\n    json: {\n      ...item.json,\n      userMessage: messageText,   // üîπ campo unificado para usar en AI Agent\n      telefono\n    }\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2912,272],"id":"d317831a-a1cc-440e-95e7-8942952ed091","name":"Homologar_msg"},{"parameters":{"method":"POST","url":"={{ $('Merge8').item.json.decryptApi }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"mimetype","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.mimetype }}"},{"name":"mediaKey","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.mediaKey }}"},{"name":"fileEncSha256","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.fileEncSha256 }}"},{"name":"mediaKeyTimestamp","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.mediaKeyTimestamp }}"},{"name":"directPath","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.directPath }}"},{"name":"fileSha256","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.fileSha256 }}"},{"name":"filename","value":"={{ $('DefineTipoArchivo').item.json.raw.message.documentMessage.fileName }}"}]},"options":{"allowUnauthorizedCerts":true}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-192,224],"id":"2183c82b-cfda-435d-9090-2a123dc56625","name":"HTTP Request","retryOnFail":true,"maxTries":5},{"parameters":{"name":"={{ $('Merge8').item.json.media.fileName }}","driveId":{"__rl":true,"value":"My Drive","mode":"list","cachedResultName":"My Drive","cachedResultUrl":"https://drive.google.com/drive/my-drive"},"folderId":{"__rl":true,"value":"={{ $('Merge8').item.json.uploadFilesDirectory }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-16,224],"id":"9bd25e59-99ba-4a93-8b1d-3a559a7d7ef2","name":"Upload file2","credentials":{"googleDriveOAuth2Api":{"id":"2D5m9UCVL0y0GKgC","name":"Google Drive account"}}},{"parameters":{"method":"POST","url":"=https://www.googleapis.com/drive/v3/files/{{ $json.id }}/copy","authentication":"predefinedCredentialType","nodeCredentialType":"googleOAuth2Api","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"convert\": true,\n  \"mimeType\": \"application/vnd.google-apps.spreadsheet\",\n  \"parents\": [\"{{ $('Merge8').item.json.convertedFilesDirectory }}\"]\n}","options":{}},"id":"406b840f-0a70-49d2-9f59-a01bb448885e","name":"Convert File3","type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[144,224],"credentials":{"googleOAuth2Api":{"id":"N3sd298xjJQFZGOz","name":"Google account"}},"onError":"continueErrorOutput"},{"parameters":{"documentId":{"__rl":true,"value":"={{ $json.id }}","mode":"id"},"sheetName":{"__rl":true,"value":"data","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[1024,48],"id":"ccffb8a3-7b89-4db1-bd5d-7158233bdb1c","name":"CxC","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=Error al Convertir Media Intente Nuevamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[400,304],"id":"2f8075bb-d602-4ef3-837a-b3e51e515037","name":"Response1"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}"},{"name":"body","value":"=Error al Convertir Media Intente Nuevamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-272,-128],"id":"2775217c-8efc-4ff8-9ad5-bafa268328af","name":"Response2"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Homologar_msg').item.json.telefono }}"},{"name":"body","value":"=üëã Hola, inicio la revisi√≥n de la plantilla de *{{ $('Merge8').item.json.tipo_archivo }}*, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-1184,240],"id":"a9f0185d-0060-4f0c-a818-cd53049e865d","name":"MsgInicial"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('CargarProductos').item.json['Telefono Celular'] }}"},{"name":"body","value":"=üëã Hola, inicio la revisi√≥n de la plantilla de CxC, este proceso puede demorar un poco, perm√≠tanos un momento... ü§û"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-1824,-288],"id":"f4e2d6aa-ee39-4cd4-993f-08996788c102","name":"MsgInicial2"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"leftValue":"={{ $json.tipo_archivo }}","rightValue":"CXC","operator":{"type":"string","operation":"equals"},"id":"6e25b731-2119-4768-809c-4bb015a029ad"}],"combinator":"and"},"renameOutput":true,"outputKey":"CXC"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"ebc92a7b-9b91-415d-bcab-25f281a9850d","leftValue":"={{ $json.tipo_archivo }}","rightValue":"CXP","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"CXP"}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.2,"position":[-2352,272],"id":"7fc51f55-5690-413b-9320-a3b27b62fa1a","name":"Switch2"},{"parameters":{"assignments":{"assignments":[{"id":"0ff4cbdf-2dbe-4a3d-953e-bed14de88ccc","name":"carga","value":"Y","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[6256,-288],"id":"49615fb2-c864-4f97-8b89-e4ea1cda9037","name":"Cargar?"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"0598b900-622b-439c-acfa-ffb199e6cc09","leftValue":"={{ $('Cargar?').item.json.carga }}","rightValue":"Y","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[6480,-288],"id":"67be2392-5de3-4540-8878-e83ed8747c17","name":"IfCargarCxC"},{"parameters":{"documentId":{"__rl":true,"value":"={{$('Convert File3').first().json.id}}","mode":"id"},"sheetName":{"__rl":true,"value":"data","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[7328,-320],"id":"e01b4a3c-8a15-467b-a917-7531caee9d89","name":"CxCCarga","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"// n8n Function Node\n\n// --- Par√°metros de validaci√≥n ---\nconst COLS_DUP = [\"No documento\", \"No referencia\"];           // columnas a chequear duplicados\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"]; // fechas YMD requeridas\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);            // columnas que s√≠ pueden venir vac√≠as\nconst IGNORE_COLS = new Set([\"row_number\"]);                  // columnas que se ignoran en validaci√≥n y/o se eliminan al salir\n\n// --- Expresiones utilitarias ---\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g;  // controles (excepto \\n/\\r)\nconst PAGE_BREAK_REGEX = /\\f/g;                                    // salto de p√°gina\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;               // saltos de l√≠nea\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\nconst toRowNum = (row, idx) => row?.row_number != null ? row.row_number : (idx + 2);\n\n// Solo recorta bordes; NO colapsa espacios internos\nfunction cleanText(val) {\n  if (typeof val !== \"string\") return val;\n  return val\n    .replace(LINEBREAK_REGEX, \" \")    // saltos de l√≠nea -> espacio\n    .replace(PAGE_BREAK_REGEX, \" \")   // salto de p√°gina -> espacio\n    .replace(CONTROL_CHARS_REGEX, \" \")// otros controles -> espacio\n    .trim();                          // recorta SOLO al inicio/fin\n}\n\nfunction findSpecials(val) {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n}\n\n// --- Proceso principal ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza/normalizaci√≥n campo a campo\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return;\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de fechas YMD (permitimos espacios en bordes)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else if (!COLS_ALLOW_EMPTY.has(col)) {\n      errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n      rowsWithIssues.add(rowNum);\n    }\n  }\n\n  // Duplicados (solo recorte de bordes en la clave)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// Filas con error (ya limpias)\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Salida con errores\nif (errores.length > 0) {\n  const mensaje = `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`;\n  return [{\n    json: {\n      ok: false,\n      mensaje,\n      errores,\n      filasConError\n    }\n  }];\n}\n\n// Salida correcta: items limpios (sin IGNORE_COLS)\nconst salidaLimpia = cleanedItems.map(ci => {\n  const out = { ...ci.row };\n  for (const k of IGNORE_COLS) {\n    if (k in out) delete out[k];\n  }\n  return { json: out };\n});\n\nif (salidaLimpia.length === 0) {\n  return [{ json: { ok: true, mensaje: 'CXC - ‚úÖ Todo Correcto (sin filas)', rows: 0 } }];\n}\n\nreturn salidaLimpia;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7520,-320],"id":"1b08ecb4-2501-4fea-a871-0a0f0126fe61","name":"InitCleaningCarga","alwaysOutputData":false,"executeOnce":false},{"parameters":{"operation":"executeQuery","query":"select ad_client_id from ad_client where ad_client_id not in ('0') ","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[6960,-320],"id":"cfbb1590-be65-4a7c-8d69-46554c2402c3","name":"ADClient","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"select ad_org_id from ad_org where ad_org_id='0'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[7136,-320],"id":"f3e526d6-4ba4-4263-9b92-20a3583e80e7","name":"ADOrg","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"operation":"executeQuery","query":"{{$json.sql_cabecera}}","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[7888,-320],"id":"3f281719-67ee-4d81-8f13-275d28748e45","name":"InsertCabecera","retryOnFail":false,"alwaysOutputData":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}},"onError":"continueRegularOutput"},{"parameters":{},"type":"n8n-nodes-base.noOp","typeVersion":1,"position":[6960,-80],"id":"b0b4c349-499e-466c-a7a5-cb012c20f5d4","name":"No Operation, do nothing1"},{"parameters":{"content":"## **Cargamos la Data?** \n**Cargar** \n","height":288},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[6176,-368],"id":"1676a662-5e59-47fa-ba42-6124570ea6bf","name":"Sticky Note"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Code node: CrearSQLCabecera\n// Mode: Run Once for Each Item\n\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Datos de soporte desde ADClient (un √∫nico registro) ===\nconst adClient = $items(\"ADClient\", 0, 0)[0]?.json;\nconst adClientId = adClient?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n// --- Merge8: trae datos de variables ---\nconst m8Items = $items('Merge8', 0, 0);\nif (!m8Items?.length) throw new Error(\"No se encontraron items del nodo 'Merge8'.\");\nconst merge8First = m8Items[0].json || {};\nconst issotrx  = merge8First.issotrx ?? null;\n\n// === Fila actual (ya limpia) ===\nconst row = $json;\n\n// Si no tienes row_number de Sheets, usa √≠ndice + 2 (cabecera = fila 1)\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Metadatos √∫tiles para logs\nconst _doc = row['No documento'];\nconst _ref = row['No referencia'];\n\n// === Construir SQL de CABECERA (multi-l√≠nea) ===\nlet sql = `\nINSERT INTO c_invoice(\n  c_invoice_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  issotrx, documentno, docstatus, docaction, processing, processed, posted,\n  c_doctype_id, c_doctypetarget_id, c_order_id, description, isprinted, salesrep_id,\n  dateinvoiced, dateprinted, dateacct, c_bpartner_id, c_bpartner_location_id,\n  poreference, isdiscountprinted, dateordered, c_currency_id, paymentrule, c_paymentterm_id,\n  c_charge_id, chargeamt, m_pricelist_id, istaxincluded, c_campaign_id, c_project_id,\n  c_activity_id, createfrom, generateto, ad_user_id, copyfrom, isselfservice, ad_orgtrx_id,\n  user2_id, withholdingamount, taxdate, c_withholding_id, fin_paymentmethod_id, c_costcenter_id,\n  user1_id\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(), '100', now(), '100',\n  ${sqlSafe(issotrx)},\n  ${sqlSafe(row['No documento'])},\n  'DR','CO','N','N','N',\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  (SELECT c_doctype_id FROM c_doctype WHERE name = ${sqlSafe(row['Documento transaccion'])}),\n  NULL,\n  ${sqlSafe(row['Descripcion'])},\n  'N',\n  NULL,\n  to_date(${sqlSafe(row['Fecha de la factura'])}, 'yyyy-mm-dd'),\n  NULL,\n  to_date(${sqlSafe(row['Fecha contable'])}, 'yyyy-mm-dd'),\n  (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])}),\n  (SELECT c_bpartner_location_id\n     FROM c_bpartner_location\n    WHERE c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND isbillto = 'Y'\n    LIMIT 1),\n  ${sqlSafe(row['No referencia'])},\n  'Y',\n  NULL,\n  (select c_currency_id from c_currency where iso_code = ${sqlSafe(row['Moneda'])}),\n  '2',\n  (select c_paymentterm_id from c_paymentterm where name = ${sqlSafe(row['Condiciones de pago'])}),\n  NULL,\n  NULL,\n  (select m_pricelist_id from m_pricelist where name = ${sqlSafe(row['Lista de precios'])}),\n  'N',\n  NULL, NULL, NULL,\n  'N','N',\n  NULL,\n  'N','N',\n  NULL,\n  NULL,\n  0,\n  to_date(${sqlSafe(row['Fecha impuesto'])}, 'yyyy-mm-dd'),\n  NULL,\n  (SELECT fin_paymentmethod_id FROM fin_paymentmethod WHERE name = ${sqlSafe(row['Forma de pago'])}),\n  (SELECT c_costcenter_id FROM c_costcenter WHERE name = ${sqlSafe(row['Centro de costo'])}),\n  (SELECT user1_id FROM user1 WHERE name = ${sqlSafe(row['Usuario1'])})\n);\n`.trim();\n\n// === Normalizaci√≥n m√≠nima ===\n// Quitar saltos de l√≠nea y tabs para que el Postgres node reciba una sola l√≠nea,\n// pero SIN colapsar espacios internos.\nsql = sql\n  .replace(/\\r?\\n|\\r/g, ' ')\n  .replace(/\\t/g, ' ')\n  .trim();\n\n// >>> DEVOLVER UN SOLO OBJETO (no array) <<<\nreturn {\n  json: {\n    ...row,\n    _rowNum,\n    _doc,\n    _ref,\n    sql_cabecera: sql\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7712,-320],"id":"49900233-0ad6-4b40-8b5a-fdd64ff6ae91","name":"CrearSQLCabecera"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"45850144-ae70-437c-bf45-523fa1499141","leftValue":"={{ !!$json.error }}","rightValue":"","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[8080,-320],"id":"70c9b4cf-7a8e-4f24-82ad-105f57c125c6","name":"If"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Code: BuildSQLLinea  (NO colapsa espacios internos)\n\n// Escapa solo comillas simples; NO hace trim ni colapsa espacios del valor\nfunction sqlSafe(v) {\n  if (v === null || v === undefined) return 'NULL';\n  return `'${String(v).replace(/'/g, \"''\")}'`;\n}\n\n// === Meta com√∫n tomada de otros nodos ===\n// ADClient ‚Üí toma el id del nodo Postgres \"ADClient\"\nconst adClientItems = $items(\"ADClient\", 0, 0);\nconst adClientId = adClientItems[0]?.json?.ad_client_id;\nif (!adClientId) {\n  throw new Error(\"ADClient no devolvi√≥ ad_client_id\");\n}\n// --- Merge8: trae datos de variables ---\nconst m8Items = $items('Merge8', 0, 0);\nif (!m8Items?.length) throw new Error(\"No se encontraron items del nodo 'Merge8'.\");\nconst merge8First = m8Items[0].json || {};\nconst issotrx  = merge8First.issotrx ?? null;\n\n// === Meta de la l√≠nea actual ===\nconst row = $json;\n\n// Si tu Function previo no preserva row_number de Sheets,\n// usa √≠ndice + 2 (para contar encabezado):\nconst _rowNum = row.row_number ?? $itemIndex + 2;\n\n// Guarda metadatos √∫tiles para depuraci√≥n:\n$json._rowNum = _rowNum;\n$json._doc    = row['No documento'];   // para relacionar con cabecera\n$json._line   = row['Linea'];          // nro de l√≠nea (si existe)\n$json._prod   = row['Producto'];       // id/nombre producto (si existe)\n\n// === Construye el SQL de la l√≠nea ===\n// (Dejamos el SQL con saltos de l√≠nea para legibilidad; no colapsamos espacios)\nconst sql = `\nINSERT INTO c_invoiceline(\n  c_invoiceline_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,\n  c_invoice_id, c_orderline_id, m_inoutline_id, line, description, m_product_id,\n  qtyinvoiced, pricelist, priceactual, pricelimit, linenetamt,\n  c_charge_id, chargeamt, c_uom_id, c_tax_id, s_resourceassignment_id, taxamt,\n  m_attributesetinstance_id, isdescription, quantityorder, m_product_uom_id,\n  c_invoice_discount_id, c_projectline_id, m_offer_id, pricestd, excludeforwithholding\n) VALUES(\n  get_uuid(),\n  ${sqlSafe(adClientId)},\n  (SELECT ad_org_id FROM ad_org WHERE name = ${sqlSafe(row['Organizacion'])}),\n  'Y', now(),'100', now(),'100',\n  (SELECT c_invoice_id\n     FROM c_invoice\n    WHERE documentno = ${sqlSafe(row['No documento'])}\n      AND c_bpartner_id = (SELECT c_bpartner_id FROM c_bpartner WHERE taxid = ${sqlSafe(row['Tercero'])})\n      AND issotrx = ${sqlSafe(issotrx)}),\n  NULL, NULL,\n  ${row['Linea'] ? sqlSafe(row['Linea']) : '10'},\n  ${sqlSafe(row['Descripcion'])},\n  sswh_m_product_get(${sqlSafe(row['Producto'])}),\n  ${sqlSafe(row['Cnt.'])},\n  0,\n  to_number(${sqlSafe(row['Precio unitario'])}),\n  0,\n  to_number(${sqlSafe(row['Total'])}),\n  NULL, 0,\n  (SELECT c_uom_id FROM c_uom WHERE uomsymbol = ${sqlSafe(row['Unidad de la orden'])}),\n  (SELECT c_tax_id FROM c_tax WHERE name = ${sqlSafe(row['Impuesto'])}),\n  NULL, NULL, NULL,\n  'N', NULL, NULL, NULL, NULL, NULL,\n  to_number(${sqlSafe(row['Precio unitario'])}),\n  'Y'\n);\n`;\n// Nota: NO usamos .trim() ni reemplazos que cambien espacios internos de los valores\n\n$json.sql_linea = sql;\n\n// En modo \"Run Once for Each Item\" devuelve UN SOLO objeto\nreturn { json: $json };\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[8832,-192],"id":"2705afd9-9a7d-4536-975a-6c2c34cddd29","name":"CrearSQLLinea"},{"parameters":{"operation":"executeQuery","query":"select cb.taxid, cbpl.c_bpartner_location_id\nfrom c_bpartner_location cbpl \njoin c_bpartner cb on cb.c_bpartner_id=cbpl.c_bpartner_id and cbpl.isbillto='Y'","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[4800,336],"id":"0707b42c-d760-4c5f-b813-7822758cb000","name":"BPLocationOB","executeOnce":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"c44052ed-6bb8-4a85-ac54-fbf2ecc20b40","leftValue":"={{ $('Unificar Errores Productos').item.json.resultado }}","rightValue":"EXITO","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[6032,-112],"id":"4a219cb4-a62f-4130-b391-7dbee11d445a","name":"IfCxCErrGen"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"=üö´ No se puede proceder con la carga de los Saldos Iniciales"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[6240,16],"id":"466f3ea3-934e-4546-a9e7-173373f69c66","name":"BloqueoCxC","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"=üë©‚Äçüíª Iniciando la carga de {{ $('Merge8').first().json.tipo_archivo }}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[6784,-320],"id":"6b4fffa7-8ba3-4eb0-9af3-3964b4271c07","name":"NotificacionCargaCxC","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"=‚úÖ Cabeceras Cargadas exitosamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[8320,-192],"id":"ace1c826-c6b8-4b87-8fe8-0cbf8fe5d833","name":"CabecerasOK","executeOnce":false},{"parameters":{"documentId":{"__rl":true,"value":"={{$('Convert File3').first().json.id}}","mode":"id"},"sheetName":{"__rl":true,"value":"data","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[8496,-192],"id":"54d102e5-4c8b-4a03-8a4e-070e9fa9fdfe","name":"CxCCarga1","credentials":{"googleSheetsOAuth2Api":{"id":"hXtG2Lkk5qYTHIdj","name":"TestSidesoft"}}},{"parameters":{"jsCode":"// n8n Function Node\n\n// --- Par√°metros de validaci√≥n ---\nconst COLS_DUP = [\"No documento\", \"No referencia\"];           // columnas a chequear duplicados\nconst DATE_COLS = [\"Fecha de la factura\", \"Fecha contable\", \"Fecha impuesto\"]; // fechas YMD requeridas\nconst COLS_ALLOW_EMPTY = new Set([\"Descripcion\"]);            // columnas que s√≠ pueden venir vac√≠as\nconst IGNORE_COLS = new Set([\"row_number\"]);                  // columnas que se ignoran en validaci√≥n y/o se eliminan al salir\n\n// --- Expresiones utilitarias ---\nconst CONTROL_CHARS_REGEX = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g;  // controles (excepto \\n/\\r)\nconst PAGE_BREAK_REGEX = /\\f/g;                                    // salto de p√°gina\nconst LINEBREAK_REGEX = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;               // saltos de l√≠nea\nconst ALLOWED_REGEX = /[A-Za-z0-9\\s√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±¬ø¬°.,:;()\\-_/&\"'[\\]{}@%#¬∞+*?!=<>|\\\\^~`$]/;\n\nconst DATE_REGEX_YMD = /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/;\nfunction isValidYMD(str) {\n  const m = DATE_REGEX_YMD.exec(str);\n  if (!m) return false;\n  const y = parseInt(m[1], 10);\n  const mo = parseInt(m[2], 10);\n  const d = parseInt(m[3], 10);\n  const isLeap = (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));\n  const daysInMonth = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  return mo >= 1 && mo <= 12 && d >= 1 && d <= daysInMonth[mo - 1];\n}\n\nconst toRowNum = (row, idx) => row?.row_number != null ? row.row_number : (idx + 2);\n\n// Solo recorta bordes; NO colapsa espacios internos\nfunction cleanText(val) {\n  if (typeof val !== \"string\") return val;\n  return val\n    .replace(LINEBREAK_REGEX, \" \")    // saltos de l√≠nea -> espacio\n    .replace(PAGE_BREAK_REGEX, \" \")   // salto de p√°gina -> espacio\n    .replace(CONTROL_CHARS_REGEX, \" \")// otros controles -> espacio\n    .trim();                          // recorta SOLO al inicio/fin\n}\n\nfunction findSpecials(val) {\n  if (typeof val !== \"string\") return [];\n  const specials = [];\n  for (let i = 0; i < val.length; i++) {\n    const ch = val[i];\n    if (!ALLOWED_REGEX.test(ch)) specials.push({ ch, pos: i });\n  }\n  return specials;\n}\n\n// --- Proceso principal ---\nconst errores = [];\nconst rowsWithIssues = new Set();\nconst dedupMaps = {};\nfor (const c of COLS_DUP) dedupMaps[c] = {};\n\nconst cleanedItems = items.map((it, idx) => {\n  const row = { ...(it.json || {}) };\n  const rowNum = toRowNum(row, idx);\n\n  // Limpieza/normalizaci√≥n campo a campo\n  Object.keys(row).forEach((k) => {\n    if (IGNORE_COLS.has(k)) return;\n\n    const original = row[k];\n\n    if (typeof original === \"string\") {\n      const cleaned = cleanText(original);\n      row[k] = cleaned;\n\n      if (!COLS_ALLOW_EMPTY.has(k) && cleaned === \"\") {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n\n      const specials = findSpecials(cleaned);\n      if (specials.length > 0) {\n        const uniqChars = [...new Set(specials.map(s => s.ch))].join(' ');\n        errores.push(`Fila ${rowNum}: caracteres especiales no permitidos en \"${k}\" ‚Üí [${uniqChars}]`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else {\n      if (!COLS_ALLOW_EMPTY.has(k) && (original === null || original === undefined)) {\n        errores.push(`Fila ${rowNum}: columna \"${k}\" no puede estar vac√≠a`);\n        rowsWithIssues.add(rowNum);\n      }\n    }\n  });\n\n  // Validaci√≥n de fechas YMD (permitimos espacios en bordes)\n  for (const col of DATE_COLS) {\n    const v = row[col];\n    const s = (v == null) ? \"\" : (typeof v === \"string\" ? v : String(v)).trim();\n    if (s !== \"\") {\n      if (!isValidYMD(s)) {\n        errores.push(`Fila ${rowNum}: formato de fecha inv√°lido en \"${col}\": valor \"${s}\" (se espera aaaa-mm-dd)`);\n        rowsWithIssues.add(rowNum);\n      }\n    } else if (!COLS_ALLOW_EMPTY.has(col)) {\n      errores.push(`Fila ${rowNum}: columna \"${col}\" no puede estar vac√≠a`);\n      rowsWithIssues.add(rowNum);\n    }\n  }\n\n  // Duplicados (solo recorte de bordes en la clave)\n  for (const col of COLS_DUP) {\n    const val = row[col];\n    if (val != null && String(val).trim() !== \"\") {\n      const key = String(val).trim();\n      if (!dedupMaps[col][key]) dedupMaps[col][key] = [];\n      dedupMaps[col][key].push(rowNum);\n    }\n  }\n\n  return { row, rowNum };\n});\n\n// Reporte de duplicados\nfor (const col of COLS_DUP) {\n  for (const [muestra, rowsList] of Object.entries(dedupMaps[col])) {\n    if (rowsList.length > 1) {\n      errores.push(`Duplicado en columna \"${col}\": valor \"${muestra}\" en filas ${rowsList.join(\", \")}`);\n      rowsList.forEach(r => rowsWithIssues.add(r));\n    }\n  }\n}\n\n// Filas con error (ya limpias)\nconst filasConError = cleanedItems\n  .filter(ci => rowsWithIssues.has(ci.rowNum))\n  .map(ci => ci.row);\n\n// Salida con errores\nif (errores.length > 0) {\n  const mensaje = `CXC - üö´ Errores encontrados:\\n- ${errores.join('\\n- ')}`;\n  return [{\n    json: {\n      ok: false,\n      mensaje,\n      errores,\n      filasConError\n    }\n  }];\n}\n\n// Salida correcta: items limpios (sin IGNORE_COLS)\nconst salidaLimpia = cleanedItems.map(ci => {\n  const out = { ...ci.row };\n  for (const k of IGNORE_COLS) {\n    if (k in out) delete out[k];\n  }\n  return { json: out };\n});\n\nif (salidaLimpia.length === 0) {\n  return [{ json: { ok: true, mensaje: 'CXC - ‚úÖ Todo Correcto (sin filas)', rows: 0 } }];\n}\n\nreturn salidaLimpia;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[8672,-192],"id":"7346f18a-54b4-4620-b010-d563b6c98e66","name":"InitCleaningCarga1","alwaysOutputData":false,"executeOnce":false},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"45850144-ae70-437c-bf45-523fa1499141","leftValue":"={{ !!$json.error }}","rightValue":"","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[9168,-192],"id":"ff8a8693-d3e9-4231-95b0-bd0acbfb5431","name":"If1"},{"parameters":{"operation":"executeQuery","query":"{{$json.sql_linea}}","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[9008,-192],"id":"6de440ae-256f-4a90-8388-9faac59ae17b","name":"InsertLineas1","retryOnFail":false,"alwaysOutputData":true,"credentials":{"postgres":{"id":"zeZbTZ9HenPQQGlt","name":"PMOMaestrosOB"}},"onError":"continueRegularOutput"},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"=‚úÖ Lineas Cargadas exitosamente"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[9424,-96],"id":"7c1daa23-76df-4936-beaa-409f8bde85d3","name":"CabecerasOK1","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"=üö´ Cabeceras Registro no se completo, revise los logs"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[8320,-384],"id":"9b8b5514-7c6b-4b42-b6d1-eac230d3020b","name":"BloqueoCxC1","executeOnce":false},{"parameters":{"method":"POST","url":"https://agileapichat.sidesoftcorp.com/api/messages/send","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"Bearer pmo"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"bodyParameters":{"parameters":[{"name":"number","value":"={{ $('Merge8').first().json.telefono }}"},{"name":"body","value":"=üö´ Lineas Registro no se completo, revise los logs"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[9424,-304],"id":"4d91e47d-59b4-45c7-bb15-a568ed744410","name":"BloqueoCxC2","executeOnce":false},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'TaxOB';            // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Impuesto'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4064,592],"id":"f5e710c9-5a25-4f70-b730-ee2d1ad75ba2","name":"ValidaTax"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'CostCenterOB';     // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Centro de costo']; // Columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4304,592],"id":"66c80a3e-ec6e-478b-bd71-37b7da640ecb","name":"ValidaCosCenter"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'User1OB';          // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'name';            // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Usuario1'];        // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles y saltos; SOLO recorta bordes\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes (no tocar espacios intermedios)\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* no existe en cat√°logo`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4544,592],"id":"e13c2159-d606-46b0-bc6f-9890b2b53874","name":"ValidaUser1"},{"parameters":{"jsCode":"// === Configuraci√≥n ===\nconst SHEET_NODE = 'CxC';                 // Nombre del nodo de Google Sheets\nconst POSTGRES_NODE = 'BPLocationOB';     // Nombre del nodo Postgres\nconst POSTGRES_FIELD = 'taxid';           // √öNICA columna devuelta por Postgres a comparar\nconst COLS_VALIDAR = ['Tercero'];         // columnas del Sheet a validar contra Postgres\n\n// Opcionales\nconst TREAT_EMPTY_AS_ERROR = false; // true para marcar vac√≠o como error\nconst UPPERCASE_MATCH = false;      // true para comparar ignorando may/min\n\n// --- Helpers de normalizaci√≥n (solo bordes; NO colapsar espacios internos) ---\nconst toStr = (v) => {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n};\n\n// Limpia invisibles/saltos y SOLO recorta bordes (no toca espacios intermedios)\nconst clean = (s) => {\n  let out = toStr(s);\n  out = out.replace(/\\u00A0/g, ' ');               // NBSP -> espacio normal\n  out = out.replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // zero-width + BOM\n  out = out.replace(/\\r\\n|\\r|\\n/g, ' ');           // saltos de l√≠nea -> espacio\n  out = out.replace(/\\t/g, ' ');                   // tab -> espacio\n  if (out.normalize) out = out.normalize('NFKC');  // normaliza unicode\n  out = out.trim();                                // SOLO bordes\n  if (UPPERCASE_MATCH) out = out.toUpperCase();\n  return out;\n};\n\n// --- Resolver columnas efectivas a validar (coincidencia directa, sin colapsar espacios) ---\nfunction resolveSheetColsExact(allKeys, baseCols) {\n  const keyMap = new Map(); // headerLimpioUpper -> headerOriginal\n  for (const k of allKeys) keyMap.set(clean(k).toUpperCase(), k);\n\n  const resolved = [];\n  for (const col of baseCols) {\n    const upper = clean(col).toUpperCase();\n    const match = keyMap.get(upper);\n    if (match) resolved.push(match);\n  }\n  return resolved;\n}\n\n// 1) HOJA: columnas del Sheet (exact match) + _row\nconst sheetItems = ($items(SHEET_NODE) || []);\nif (!sheetItems.length) {\n  return [{ json: { mensaje: `CxC - No hay datos desde el nodo Sheet \"${SHEET_NODE}\"` } }];\n}\nconst sampleRow = sheetItems[0]?.json || {};\nconst allKeys = Object.keys(sampleRow || {});\nconst EFFECTIVE_COLS = resolveSheetColsExact(allKeys, COLS_VALIDAR);\n\nif (!EFFECTIVE_COLS.length) {\n  return [{ json: { mensaje: `CxC - No se encontraron columnas para validar (buscadas: ${COLS_VALIDAR.join(', ')})` } }];\n}\n\nconst hoja = sheetItems.map((it, i) => {\n  const row = it.json || {};\n  const out = { _row: row.row_number ?? (i + 2) };   // asume encabezado en fila 1\n  for (const c of EFFECTIVE_COLS) out[c] = clean(row[c]);\n  return out;\n});\n\n// 2) POSTGRES: array de strings (columna √∫nica), limpios + SET para b√∫squeda O(1)\nconst postgres = ($items(POSTGRES_NODE) || [])\n  .map(it => it?.json?.[POSTGRES_FIELD])\n  .map(clean)\n  .filter(v => v !== '');\nconst postgresSet = new Set(postgres);\n\n// 3) Comparar cada fila/columna contra postgresSet\nconst faltantes = [];\nconst hojaVal = hoja.map(r => {\n  const missingCols = [];\n  for (const col of EFFECTIVE_COLS) {\n    const val = r[col]; // ya limpio (solo bordes)\n    if (val === '' && !TREAT_EMPTY_AS_ERROR) continue; // vac√≠o permitido si no se trata como error\n    if (!postgresSet.has(val)) {\n      missingCols.push({ columna: col, valor: val });\n      faltantes.push({ fila: r._row, columna: col, valor: val });\n    }\n  }\n  return { ...r, esValido: missingCols.length === 0, faltantes: missingCols };\n});\n\n// 4) Mensaje global\nconst mensaje = faltantes.length === 0\n  ? 'CxC - Todo Correcto'\n  : 'CxC - Errores encontrados:\\n- ' + faltantes\n      .map(e => `Fila ${e.fila} - Columna \"${e.columna}\" valor *${e.valor}* Tercero sin Direccion`)\n      .join('\\n- ');\n\n// 5) Salida √∫nica (solo mensaje)\nreturn [{ json: { mensaje } }];\n\n/** Si prefieres la salida detallada, usa esto:\nreturn [{\n  json: {\n    hoja: hojaVal,      // filas con validaci√≥n por fila\n    postgres,           // lista de valores v√°lidos tra√≠dos de Postgres\n    faltantes,          // plano: fila/columna/valor no encontrados\n    totalErrores: faltantes.length,\n    mensaje\n  }\n}];\n**/\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4800,592],"id":"55990658-6ee3-4c8f-9db2-d11cc12262fc","name":"ValidaBPLocation"},{"parameters":{"content":"## Validacion que no Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)","height":576,"width":224},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[1856,208],"id":"84674bae-9111-46ae-9020-54591fd5a855","name":"Sticky Note1"},{"parameters":{"content":"## Validacion que si Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)","height":576,"width":208,"color":6},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[1648,208],"id":"b8f0e8dc-5614-43f7-b1ad-e041fb0c8f0e","name":"Sticky Note2"},{"parameters":{"content":"## Validacion que si Exista \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)","height":576,"width":2880,"color":6},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[2080,208],"id":"1881be36-4337-4866-ba6b-659ffdbb63a1","name":"Sticky Note3"},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"13IxZ60e9aoBpSIIxNBk01_zZxbkVPkow","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Az-ZFrPX8NLT3-AOv8lUBOLu-wS2c34i","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://agente.alldigital-marketing.com/wa-decrypt/decrypt-document","type":"string"},{"id":"f197f9b9-0992-47b5-8faf-85fecda67503","name":"issotrx","value":"Y","type":"string"},{"id":"1071c733-64c4-46b4-9933-ad3c843c05fb","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"343aeec5-aa95-461c-9272-d17dedf033ca","name":"telefono","value":"={{ $('Homologar_msg').item.json.telefono }}","type":"string"}]},"includeOtherFields":true,"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-2016,112],"id":"678b7cbc-8327-43a0-9a3f-7c81c0ba7770","name":"VarCxC"},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-1712,256],"id":"3adff947-5c97-481f-aa9c-7c73d45a5344","name":"Merge8"},{"parameters":{"assignments":{"assignments":[{"id":"49f12a44-11ae-4849-94b4-4c0b492c3641","name":"uploadFilesDirectory","value":"1hhic6Um17LbZv1B3fCQr27X-SASoagsH","type":"string"},{"id":"ff554178-aa16-4be5-bfb3-9368f7a56607","name":"convertedFilesDirectory","value":"1Ujakb61OzHsUIEXRQtT2oz7LutRh-THi","type":"string"},{"id":"6fb746c8-33c8-48f2-8d85-b2ff886625d5","name":"decryptApi","value":"https://agente.alldigital-marketing.com/wa-decrypt/decrypt-document","type":"string"},{"id":"f197f9b9-0992-47b5-8faf-85fecda67503","name":"issotrx","value":"N","type":"string"},{"id":"1071c733-64c4-46b4-9933-ad3c843c05fb","name":"subworkflowID","value":"gqt6yXfnufkwZYCz","type":"string"},{"id":"343aeec5-aa95-461c-9272-d17dedf033ca","name":"telefono","value":"={{ $('Homologar_msg').item.json.telefono }}","type":"string"}]},"includeOtherFields":true,"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-2016,384],"id":"0e5fe5fd-c797-40bb-ab5e-3c620404aebe","name":"VarCxP"},{"parameters":{"jsCode":"// Usa el fileName que viene del mensaje de WhatsApp\nconst fileName = String(\n  $json.raw?.message?.documentMessage?.fileName || ''\n);\nconst ext = (fileName.split('.').pop() || '').toLowerCase();\nconst mime = String($json.raw?.message?.documentMessage?.mimetype || '');\n\nlet tipo = '';\nif (/cxp/i.test(fileName)) tipo = 'CXP';\nelse if (/cxc/i.test(fileName)) tipo = 'CXC';\nelse if (ext === 'xlsx') tipo = 'XLSX';\nelse if (ext === 'csv') tipo = 'CSV';\nelse tipo = 'OTRO';\n\nreturn [{\n  json: {\n    ...$json,\n    archivo_nombre: fileName,\n    archivo_ext: ext,\n    archivo_mime: mime,\n    tipo_archivo: tipo\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2560,272],"id":"4b42620e-468a-44b6-8324-70c9c185bf7e","name":"ValidaExtensionyNombre"},{"parameters":{"jsCode":"// Clasifica: 'texto' | 'imagen' | 'audio' | 'video' | 'documento'\n// Mantiene SIEMPRE el mismo formato de retorno:\n// { kind, text, media, raw, sender, timestamp }\n\nfunction unwrap(m) {\n  if (!m) return m;\n  if (m.ephemeralMessage?.message) return unwrap(m.ephemeralMessage.message);\n  if (m.viewOnceMessage?.message) return unwrap(m.viewOnceMessage.message);\n  if (m.viewOnceMessageV2?.message) return unwrap(m.viewOnceMessageV2.message);\n  return m;\n}\n\nfunction toNum(x) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction isImageMime(mt) {\n  return typeof mt === \"string\" && mt.toLowerCase().startsWith(\"image/\");\n}\n\nfunction isImageFilename(name) {\n  if (!name) return false;\n  return /\\.(jpe?g|png|webp|gif|bmp|tif?f)$/i.test(String(name));\n}\n\nfunction detectar(body) {\n  const msg = unwrap(body?.message || {});\n  if (!msg) return { kind: \"desconocido\", text: \"\", media: null, raw: body };\n\n  // === AUDIO ===\n  if (msg.audioMessage) {\n    const a = msg.audioMessage;\n    const url = a.url || \"\";\n    return {\n      kind: \"audio\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: a.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: a.mediaKey || null,\n        directPath: a.directPath || null,\n        seconds: typeof a.seconds === \"number\" ? a.seconds : toNum(a.seconds),\n        ptt: Boolean(a.ptt)\n      },\n      raw: body\n    };\n  }\n\n  // === VIDEO ===\n  if (msg.videoMessage) {\n    const v = msg.videoMessage;\n    const url = v.url || \"\";\n    return {\n      kind: \"video\",\n      text: v.caption || \"\",\n      media: {\n        url,\n        mimetype: v.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: v.mediaKey || null,\n        directPath: v.directPath || null,\n        seconds: typeof v.seconds === \"number\" ? v.seconds : toNum(v.seconds),\n        gifPlayback: Boolean(v.gifPlayback)\n      },\n      raw: body\n    };\n  }\n\n  // === STICKER (tratar como IMAGEN) ===\n  if (msg.stickerMessage) {\n    const s = msg.stickerMessage;\n    const url = s.url || \"\";\n    return {\n      kind: \"imagen\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: s.mimetype || \"image/webp\",\n        encrypted: url.includes(\".enc\"),\n        mediaKey: s.mediaKey || null,\n        directPath: s.directPath || null,\n        isSticker: true,\n        isAnimated: Boolean(s.isAnimated)\n      },\n      raw: body\n    };\n  }\n\n  // === IMAGEN ===\n  if (msg.imageMessage) {\n    const i = msg.imageMessage;\n    const url = i.url || \"\";\n    return {\n      kind: \"imagen\",\n      text: i.caption || \"\",\n      media: {\n        url,\n        mimetype: i.mimetype || null,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: i.mediaKey || null,\n        directPath: i.directPath || null\n      },\n      raw: body\n    };\n  }\n\n  // === DOCUMENTO (si es imagen -> clasificar como IMAGEN; si no, DOCUMENTO) ===\n  if (msg.documentMessage) {\n    const d = msg.documentMessage;\n    const url = d.url || \"\";\n    const fileName = d.fileName || d.title || null;\n    const mime = d.mimetype || null;\n\n    if (isImageMime(mime) || isImageFilename(fileName)) {\n      // document enviado como imagen -> tratar como imagen\n      return {\n        kind: \"imagen\",\n        text: \"\",\n        media: {\n          url,\n          mimetype: mime || \"image/jpeg\",\n          encrypted: url.includes(\".enc\"),\n          mediaKey: d.mediaKey || null,\n          directPath: d.directPath || null,\n          fromDocument: true,\n          fileName,\n          fileLength: toNum(d.fileLength),\n          fileSha256: d.fileSha256 || null,\n          fileEncSha256: d.fileEncSha256 || null,\n          mediaKeyTimestamp: toNum(d.mediaKeyTimestamp)\n        },\n        raw: body\n      };\n    }\n\n    // documento \"normal\"\n    return {\n      kind: \"documento\",\n      text: \"\",\n      media: {\n        url,\n        mimetype: mime,\n        encrypted: url.includes(\".enc\"),\n        mediaKey: d.mediaKey || null,\n        directPath: d.directPath || null,\n        fileName,\n        fileLength: toNum(d.fileLength),\n        pageCount: toNum(d.pageCount),\n        fileSha256: d.fileSha256 || null,\n        fileEncSha256: d.fileEncSha256 || null,\n        mediaKeyTimestamp: toNum(d.mediaKeyTimestamp),\n        // miniatura (si existe)\n        thumbnail: {\n          jpegThumbnail: d.jpegThumbnail || null,\n          thumbnailDirectPath: d.thumbnailDirectPath || null,\n          thumbnailSha256: d.thumbnailSha256 || null,\n          thumbnailEncSha256: d.thumbnailEncSha256 || null,\n          width: toNum(d.thumbnailWidth),\n          height: toNum(d.thumbnailHeight)\n        }\n      },\n      raw: body\n    };\n  }\n\n  // === TEXTO ===\n  if (msg.conversation || msg.extendedTextMessage?.text) {\n    return {\n      kind: \"texto\",\n      text: msg.conversation || msg.extendedTextMessage?.text || \"\",\n      media: null,\n      raw: body\n    };\n  }\n\n  // Desconocido\n  return { kind: \"desconocido\", text: \"\", media: null, raw: body };\n}\n\nreturn items.map(it => {\n  const body = it.json?.body ?? it.json;\n  const out = detectar(body);\n  const ts = body?.messageTimestamp ? new Date(Number(body.messageTimestamp) * 1000).toISOString() : null;\n\n  return {\n    json: {\n      kind: out.kind,      // 'audio' | 'video' | 'imagen' | 'documento' | 'texto' | 'desconocido'\n      text: out.text,\n      media: out.media,\n      raw: out.raw,\n      sender: {\n        name: body?.pushName || \"\",\n        remoteJid: body?.key?.remoteJid || \"\",\n        fromMe: Boolean(body?.key?.fromMe),\n        id: body?.key?.id || null\n      },\n      timestamp: ts\n    }\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2736,272],"id":"8b990d8e-33dc-4269-aef3-c5c01a48a0f8","name":"DefineTipoArchivo"},{"parameters":{"jsCode":"// Lee los items que salieron de Merge8 (runIndex 0, outputIndex 0)\nconst merged = $items('Merge8', 0, 0);\n\n// Campos a extraer (los de la imagen)\nconst FIELDS = [\n  'archivo_nombre',\n  'archivo_ext',\n  'archivo_mime',\n  'tipo_archivo',\n  'uploadFilesDirectory',\n  'convertedFilesDirectory',\n  'decryptApi',\n  'issotrx',\n  'subworkflowID',\n  'telefono'\n];\n\n// Construye respuesta con count + items, manteniendo index y hasBinary\nconst items = merged.map((it, i) => {\n  const out = {};\n  for (const k of FIELDS) out[k] = it.json?.[k] ?? null;\n  return {\n    index: i,\n    json: out,\n    hasBinary: !!it.binary\n  };\n});\n\nreturn [\n  {\n    json: {\n      count: items.length,\n      items\n    }\n  }\n];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-848,128],"id":"6d3bd5e9-6e24-441c-9498-94783bd7ffdc","name":"loadvariables"}],"connections":{"Code3":{"main":[[{"node":"Merge","type":"main","index":1},{"node":"FacturasOB","type":"main","index":0}]]},"Unificar Errores Productos":{"main":[[{"node":"Confirmacion","type":"main","index":0}]]},"Merge":{"main":[[{"node":"Merge2","type":"main","index":3}]]},"InitCleaning":{"main":[[{"node":"Merge","type":"main","index":0}]]},"AdOrgOB":{"main":[[{"node":"Code3","type":"main","index":0}]]},"FacturasOB":{"main":[[{"node":"FactOB","type":"main","index":0}]]},"DoctypeOB":{"main":[[{"node":"DtOB","type":"main","index":0}]]},"FactOB":{"main":[[{"node":"Merge","type":"main","index":2},{"node":"DoctypeOB","type":"main","index":0}]]},"DtOB":{"main":[[{"node":"Merge","type":"main","index":3},{"node":"PartnerOB","type":"main","index":0}]]},"PartnerOB":{"main":[[{"node":"BPOB","type":"main","index":0}]]},"BPOB":{"main":[[{"node":"Merge","type":"main","index":4},{"node":"PriceListOB","type":"main","index":0}]]},"PriceListOB":{"main":[[{"node":"ValidaPriceList","type":"main","index":0}]]},"ValidaPriceList":{"main":[[{"node":"MonedaOB","type":"main","index":0},{"node":"Merge2","type":"main","index":4}]]},"MonedaOB":{"main":[[{"node":"ValidaCurrency","type":"main","index":0}]]},"PaymentMethodOB":{"main":[[{"node":"ValidaPaymentMethod","type":"main","index":0}]]},"ValidaPaymentMethod":{"main":[[{"node":"PaymentTermOB","type":"main","index":0},{"node":"Merge","type":"main","index":6}]]},"PaymentTermOB":{"main":[[{"node":"ValidaPaymentTerm","type":"main","index":0}]]},"ValidaCurrency":{"main":[[{"node":"PaymentMethodOB","type":"main","index":0},{"node":"Merge","type":"main","index":5}]]},"ValidaPaymentTerm":{"main":[[{"node":"Merge","type":"main","index":7},{"node":"ProductOB","type":"main","index":0}]]},"ProductOB":{"main":[[{"node":"ValidaProduct","type":"main","index":0}]]},"ValidaProduct":{"main":[[{"node":"UnidadOB","type":"main","index":0},{"node":"Merge","type":"main","index":8}]]},"UnidadOB":{"main":[[{"node":"ValidaUnidad","type":"main","index":0}]]},"ValidaUnidad":{"main":[[{"node":"Merge","type":"main","index":9},{"node":"TaxOB","type":"main","index":0}]]},"TaxOB":{"main":[[{"node":"ValidaTax","type":"main","index":0}]]},"CostCenterOB":{"main":[[{"node":"ValidaCosCenter","type":"main","index":0}]]},"User1OB":{"main":[[{"node":"ValidaUser1","type":"main","index":0}]]},"Merge2":{"main":[[{"node":"Unificar Errores Productos","type":"main","index":0}]]},"CargarProductos":{"main":[[{"node":"Extract from File","type":"main","index":0}]]},"Upload file1":{"main":[[{"node":"Convert File2","type":"main","index":0}]]},"Variables1":{"main":[[{"node":"Execute Workflow","type":"main","index":0},{"node":"Merge3","type":"main","index":1}]]},"Extract from File":{"main":[[{"node":"MsgInicial2","type":"main","index":0}]]},"Convert to File":{"main":[[{"node":"Upload file1","type":"main","index":0}]]},"Execute Workflow":{"main":[[{"node":"Merge3","type":"main","index":0}]]},"Merge3":{"main":[[{"node":"Convert to File","type":"main","index":0}]]},"Execute Workflow1":{"main":[[{"node":"Merge4","type":"main","index":0}]]},"Merge4":{"main":[[{"node":"HTTP Request","type":"main","index":0}]]},"Convert File2":{"main":[[{"node":"CxC","type":"main","index":0}],[{"node":"Response2","type":"main","index":0}]]},"Webhook":{"main":[[{"node":"Homologar_msg","type":"main","index":0}]]},"Switch":{"main":[[{"node":"MsgInicial","type":"main","index":0}],[{"node":"Response","type":"main","index":0}]]},"Homologar_msg":{"main":[[{"node":"DefineTipoArchivo","type":"main","index":0}]]},"HTTP Request":{"main":[[{"node":"Upload file2","type":"main","index":0}]]},"Upload file2":{"main":[[{"node":"Convert File3","type":"main","index":0}]]},"Convert File3":{"main":[[{"node":"CxC","type":"main","index":0}],[{"node":"Response1","type":"main","index":0}]]},"CxC":{"main":[[{"node":"InitCleaning","type":"main","index":0},{"node":"AdOrgOB","type":"main","index":0}]]},"MsgInicial":{"main":[[{"node":"Merge4","type":"main","index":1},{"node":"loadvariables","type":"main","index":0}]]},"MsgInicial2":{"main":[[{"node":"Variables1","type":"main","index":0}]]},"Switch2":{"main":[[{"node":"VarCxC","type":"main","index":0}],[{"node":"VarCxP","type":"main","index":0}]]},"Confirmacion":{"main":[[{"node":"IfCxCErrGen","type":"main","index":0}]]},"Cargar?":{"main":[[{"node":"IfCargarCxC","type":"main","index":0}]]},"IfCargarCxC":{"main":[[{"node":"NotificacionCargaCxC","type":"main","index":0}],[{"node":"No Operation, do nothing1","type":"main","index":0}]]},"CxCCarga":{"main":[[{"node":"InitCleaningCarga","type":"main","index":0}]]},"ADClient":{"main":[[{"node":"ADOrg","type":"main","index":0}]]},"InitCleaningCarga":{"main":[[{"node":"CrearSQLCabecera","type":"main","index":0}]]},"ADOrg":{"main":[[{"node":"CxCCarga","type":"main","index":0}]]},"InsertCabecera":{"main":[[{"node":"If","type":"main","index":0}]]},"CrearSQLCabecera":{"main":[[{"node":"InsertCabecera","type":"main","index":0}]]},"If":{"main":[[{"node":"BloqueoCxC1","type":"main","index":0}],[{"node":"CabecerasOK","type":"main","index":0}]]},"CrearSQLLinea":{"main":[[{"node":"InsertLineas1","type":"main","index":0}]]},"BPLocationOB":{"main":[[{"node":"ValidaBPLocation","type":"main","index":0}]]},"IfCxCErrGen":{"main":[[{"node":"Cargar?","type":"main","index":0}],[{"node":"BloqueoCxC","type":"main","index":0}]]},"NotificacionCargaCxC":{"main":[[{"node":"ADClient","type":"main","index":0}]]},"CxCCarga1":{"main":[[{"node":"InitCleaningCarga1","type":"main","index":0}]]},"CabecerasOK":{"main":[[{"node":"CxCCarga1","type":"main","index":0}]]},"InitCleaningCarga1":{"main":[[{"node":"CrearSQLLinea","type":"main","index":0}]]},"InsertLineas1":{"main":[[{"node":"If1","type":"main","index":0}]]},"If1":{"main":[[{"node":"BloqueoCxC2","type":"main","index":0}],[{"node":"CabecerasOK1","type":"main","index":0}]]},"ValidaTax":{"main":[[{"node":"CostCenterOB","type":"main","index":0},{"node":"Merge2","type":"main","index":0}]]},"ValidaCosCenter":{"main":[[{"node":"User1OB","type":"main","index":0},{"node":"Merge2","type":"main","index":1}]]},"ValidaUser1":{"main":[[{"node":"Merge2","type":"main","index":2},{"node":"BPLocationOB","type":"main","index":0}]]},"ValidaBPLocation":{"main":[[{"node":"Merge2","type":"main","index":5}]]},"VarCxC":{"main":[[{"node":"Merge8","type":"main","index":0}]]},"VarCxP":{"main":[[{"node":"Merge8","type":"main","index":1}]]},"ValidaExtensionyNombre":{"main":[[{"node":"Switch2","type":"main","index":0}]]},"DefineTipoArchivo":{"main":[[{"node":"ValidaExtensionyNombre","type":"main","index":0}]]},"Merge8":{"main":[[{"node":"Switch","type":"main","index":0}]]},"loadvariables":{"main":[[{"node":"Execute Workflow1","type":"main","index":0}]]},"Response1":{"main":[[]]}},"settings":{"executionOrder":"v1","callerPolicy":"workflowsFromSameOwner"},"staticData":{"node:Google Drive Trigger":{"lastTimeChecked":"2025-10-08T14:27:45Z"}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"d109f2d8-9b6d-4fbf-8980-a86b074d0af9","triggerCount":2,"shared":[{"createdAt":"2025-10-08T17:07:11.761Z","updatedAt":"2025-10-08T17:07:11.761Z","role":"workflow:owner","workflowId":"C7EDvLI28JCxQyp3","projectId":"Bev2pwmvUzes1BM7"}],"tags":[]}